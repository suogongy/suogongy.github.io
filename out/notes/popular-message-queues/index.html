<!DOCTYPE html><html lang="zh-CN"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/55b7a9e84b417e65.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-c81f7fd28659d64f.js"/><script src="/_next/static/chunks/fd9d1056-9f91b5e418130764.js" async=""></script><script src="/_next/static/chunks/117-ee7b0ec54963e50f.js" async=""></script><script src="/_next/static/chunks/main-app-c180f1b9030bf4f6.js" async=""></script><script src="/_next/static/chunks/972-17ea62b17795b286.js" async=""></script><script src="/_next/static/chunks/app/%5Bcategory%5D/%5Bslug%5D/page-234087874853c0eb.js" async=""></script><script src="/_next/static/chunks/app/layout-8486db2c9a537bdb.js" async=""></script><title>热门MQ详解 - Personal GitHub Page</title><meta name="description" content="深入分析主流消息队列的技术特点、架构设计、性能差异和选型建议，帮助开发者选择合适的消息中间件。"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css"/><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body><div class="app"><header class="header "><nav class="nav-container"><a class="nav-brand" href="/"><i class="fas fa-terminal"></i>Rudy Yang</a><ul class="nav-menu"><li><a class="nav-link " href="/"><i class="fas fa-home"></i> 首页</a></li><li><a class="nav-link " href="/about/"><i class="fas fa-user"></i> 关于</a></li><li><a class="nav-link " href="/projects/"><i class="fas fa-code"></i> 项目</a></li><li><a class="nav-link " href="/notes/"><i class="fas fa-book"></i> 笔记</a></li><li><a class="nav-link " href="/articles/"><i class="fas fa-pen"></i> 随笔</a></li></ul></nav></header><main class="main-content"><div><a class="back-button" style="display:inline-block;background:var(--primary-color);color:white;border:none;padding:10px 20px;border-radius:6px;cursor:pointer;margin-bottom:20px;text-decoration:none" href="/notes/">← 返回<!-- -->笔记<!-- -->列表</a><article class="section"><header class="article-header"><h1 class="article-title">热门MQ详解</h1><div class="article-meta"><div class="article-meta-info"><span class="article-date">2024-10-14</span><span class="article-category">• <!-- -->笔记</span></div><div class="article-tags"><span class="tag">消息队列</span><span class="tag">Kafka</span><span class="tag">RocketMQ</span><span class="tag">RabbitMQ</span><span class="tag">技术选型</span></div></div></header><div class="card markdown-content"><h1>热门MQ详解</h1>
<blockquote>
<p>消息队列是分布式系统的重要组件，选择合适的MQ对系统架构至关重要</p>
</blockquote>
<h2>消息队列概述</h2>
<h3>1. 消息队列的作用</h3>
<pre><code>消息队列核心价值：
├── 解耦
│   ├── 生产者与消费者解耦
│   ├── 业务逻辑与技术实现解耦
│   └── 系统模块间解耦
├── 异步
│   ├── 提升系统响应速度
│   ├── 改善用户体验
│   └── 提高系统吞吐量
├── 削峰
│   ├── 平滑流量峰值
│   ├── 保护后端系统
│   └── 提升系统稳定性
└── 可靠性
    ├── 消息持久化
    ├── 重试机制
    └── 事务支持
</code></pre>
<h3>2. 主流MQ对比</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>Kafka</th>
<th>RocketMQ</th>
<th>RabbitMQ</th>
<th>ActiveMQ</th>
</tr>
</thead>
<tbody><tr>
<td>吞吐量</td>
<td>极高</td>
<td>高</td>
<td>中等</td>
<td>中等</td>
</tr>
<tr>
<td>延迟</td>
<td>低</td>
<td>低</td>
<td>低</td>
<td>中等</td>
</tr>
<tr>
<td>可靠性</td>
<td>高</td>
<td>高</td>
<td>高</td>
<td>中等</td>
</tr>
<tr>
<td>复杂度</td>
<td>高</td>
<td>中等</td>
<td>低</td>
<td>低</td>
</tr>
<tr>
<td>生态</td>
<td>丰富</td>
<td>良好</td>
<td>一般</td>
<td>一般</td>
</tr>
</tbody></table>
<h2>Kafka详解</h2>
<h3>1. Kafka架构</h3>
<pre><code>Kafka架构图：
┌─────────────────────────────────────────────────────────────┐
│                    Kafka Cluster                            │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐           │
│  │  Broker 1   │  │  Broker 2   │  │  Broker 3   │           │
│  │             │  │             │  │             │           │
│  │ ┌─────────┐ │  │ ┌─────────┐ │  │ ┌─────────┐ │           │
│  │ │ Topic A │ │  │ │ Topic A │ │  │ │ Topic A │ │           │
│  │ └─────────┘ │  │ └─────────┘ │  │ └─────────┘ │           │
│  │ ┌─────────┐ │  │ ┌─────────┐ │  │ ┌─────────┐ │           │
│  │ │ Topic B │ │  │ │ Topic B │ │  │ │ Topic B │ │           │
│  │ └─────────┘ │  │ └─────────┘ │  │ └─────────┘ │           │
│  └─────────────┘  └─────────────┘  └─────────────┘           │
└─────────────────────────────────────────────────────────────┘
         ↑                    ↑                    ↑
    ┌─────────────┐     ┌─────────────┐     ┌─────────────┐
    │   Producer  │     │  Producer   │     │  Producer   │
    └─────────────┘     └─────────────┘     └─────────────┘
         ↓                    ↓                    ↓
    ┌─────────────┐     ┌─────────────┐     ┌─────────────┐
    │   Consumer  │     │  Consumer   │     │  Consumer   │
    │    Group    │     │   Group     │     │   Group     │
    └─────────────┘     └─────────────┘     └─────────────┘
</code></pre>
<h3>2. Kafka核心概念</h3>
<p><strong>Partition机制</strong></p>
<pre><code class="language-java">// Kafka生产者配置
Properties props = new Properties();
props.put(&quot;bootstrap.servers&quot;, &quot;localhost:9092&quot;);
props.put(&quot;key.serializer&quot;, &quot;org.apache.kafka.common.serialization.StringSerializer&quot;);
props.put(&quot;value.serializer&quot;, &quot;org.apache.kafka.common.serialization.StringSerializer&quot;);

// 创建生产者
KafkaProducer&lt;String, String&gt; producer = new KafkaProducer&lt;&gt;(props);

// 发送消息（指定分区）
ProducerRecord&lt;String, String&gt; record = 
    new ProducerRecord&lt;&gt;(&quot;topic-name&quot;, 0, &quot;key&quot;, &quot;value&quot;);

// 自定义分区策略
public class CustomPartitioner implements Partitioner {
    @Override
    public int partition(String topic, Object key, byte[] keyBytes, 
                       Object value, byte[] valueBytes, Cluster cluster) {
        // 自定义分区逻辑
        return Math.abs(key.hashCode()) % cluster.partitionCountForTopic(topic);
    }
}
</code></pre>
<p><strong>Consumer Group</strong></p>
<pre><code class="language-java">// Kafka消费者配置
Properties props = new Properties();
props.put(&quot;bootstrap.servers&quot;, &quot;localhost:9092&quot;);
props.put(&quot;group.id&quot;, &quot;consumer-group-1&quot;);
props.put(&quot;enable.auto.commit&quot;, &quot;true&quot;);
props.put(&quot;auto.commit.interval.ms&quot;, &quot;1000&quot;);
props.put(&quot;key.deserializer&quot;, &quot;org.apache.kafka.common.serialization.StringDeserializer&quot;);
props.put(&quot;value.deserializer&quot;, &quot;org.apache.kafka.common.serialization.StringDeserializer&quot;);

// 创建消费者
KafkaConsumer&lt;String, String&gt; consumer = new KafkaConsumer&lt;&gt;(props);

// 订阅主题
consumer.subscribe(Arrays.asList(&quot;topic-1&quot;, &quot;topic-2&quot;));

// 消费消息
while (true) {
    ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(100));
    for (ConsumerRecord&lt;String, String&gt; record : records) {
        System.out.printf(&quot;offset = %d, key = %s, value = %s%n&quot;, 
                         record.offset(), record.key(), record.value());
    }
}
</code></pre>
<h3>3. Kafka性能优化</h3>
<p><strong>生产者优化</strong></p>
<pre><code class="language-java">// 生产者性能优化配置
props.put(&quot;batch.size&quot;, 16384);           // 批量大小
props.put(&quot;linger.ms&quot;, 5);               // 等待时间
props.put(&quot;compression.type&quot;, &quot;snappy&quot;); // 压缩类型
props.put(&quot;acks&quot;, &quot;all&quot;);                // 确认机制
props.put(&quot;retries&quot;, 3);                 // 重试次数
props.put(&quot;max.in.flight.requests.per.connection&quot;, 5);

// 异步发送优化
List&lt;Future&lt;RecordMetadata&gt;&gt; futures = new ArrayList&lt;&gt;();

for (int i = 0; i &lt; 1000; i++) {
    ProducerRecord&lt;String, String&gt; record = 
        new ProducerRecord&lt;&gt;(&quot;topic-name&quot;, &quot;key-&quot; + i, &quot;value-&quot; + i);
    
    Future&lt;RecordMetadata&gt; future = producer.send(record, (metadata, exception) -&gt; {
        if (exception != null) {
            // 处理发送失败
            exception.printStackTrace();
        }
    });
    
    futures.add(future);
}

// 等待所有消息发送完成
for (Future&lt;RecordMetadata&gt; future : futures) {
    try {
        future.get();
    } catch (Exception e) {
        e.printStackTrace();
    }
}
</code></pre>
<h2>RocketMQ详解</h2>
<h3>1. RocketMQ架构</h3>
<pre><code>RocketMQ架构图：
┌─────────────────────────────────────────────────────────────┐
│                    Name Server                              │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐           │
│  │ NameServer1 │  │ NameServer2 │  │ NameServer3 │           │
│  └─────────────┘  └─────────────┘  └─────────────┘           │
└─────────────────────────────────────────────────────────────┘
         ↓                    ↓                    ↓
┌─────────────────────────────────────────────────────────────┐
│                    Broker Cluster                           │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐           │
│  │  Master 1   │  │  Master 2   │  │  Master 3   │           │
│  │             │  │             │  │             │           │
│  │ ┌─────────┐ │  │ ┌─────────┐ │  │ ┌─────────┐ │           │
│  │ │ Topic A │ │  │ │ Topic B │ │  │ │ Topic C │ │           │
│  │ └─────────┘ │  │ └─────────┘ │  │ └─────────┘ │           │
│  └─────────────┘  └─────────────┘  └─────────────┘           │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐           │
│  │  Slave 1    │  │  Slave 2    │  │  Slave 3    │           │
│  └─────────────┘  └─────────────┘  └─────────────┘           │
└─────────────────────────────────────────────────────────────┘
         ↑                    ↑                    ↑
    ┌─────────────┐     ┌─────────────┐     ┌─────────────┐
    │   Producer  │     │  Producer   │     │  Producer   │
    └─────────────┘     └─────────────┘     └─────────────┘
         ↓                    ↓                    ↓
    ┌─────────────┐     ┌─────────────┐     ┌─────────────┐
    │   Consumer  │     │  Consumer   │     │  Consumer   │
    └─────────────┘     └─────────────┘     └─────────────┘
</code></pre>
<h3>2. RocketMQ特性</h3>
<p><strong>事务消息</strong></p>
<pre><code class="language-java">// 事务消息生产者
TransactionMQProducer producer = new TransactionMQProducer(&quot;transaction-producer-group&quot;);
producer.setNamesrvAddr(&quot;localhost:9876&quot;);
producer.setTransactionListener(new TransactionListener() {
    
    @Override
    public LocalTransactionState executeLocalTransaction(Message msg, Object arg) {
        // 执行本地事务
        try {
            // 本地业务逻辑
            boolean success = processLocalTransaction(msg);
            return success ? LocalTransactionState.COMMIT_MESSAGE : 
                           LocalTransactionState.ROLLBACK_MESSAGE;
        } catch (Exception e) {
            return LocalTransactionState.ROLLBACK_MESSAGE;
        }
    }
    
    @Override
    public LocalTransactionState checkLocalTransaction(Message msg) {
        // 检查本地事务状态
        boolean success = checkLocalTransactionStatus(msg);
        return success ? LocalTransactionState.COMMIT_MESSAGE : 
                       LocalTransactionState.ROLLBACK_MESSAGE;
    }
});

// 发送事务消息
Message msg = new Message(&quot;topic-name&quot;, &quot;tag&quot;, &quot;key&quot;, &quot;message body&quot;.getBytes());
TransactionSendResult result = producer.sendMessageInTransaction(msg, null);
</code></pre>
<p><strong>顺序消息</strong></p>
<pre><code class="language-java">// 顺序消息生产者
DefaultMQProducer producer = new DefaultMQProducer(&quot;order-producer-group&quot;);
producer.setNamesrvAddr(&quot;localhost:9876&quot;);
producer.start();

// 发送顺序消息
for (int i = 0; i &lt; 10; i++) {
    Message msg = new Message(&quot;order-topic&quot;, &quot;order&quot;, 
        (&quot;order-&quot; + i).getBytes());
    
    // 使用相同的orderId作为选择队列的key
    SendResult result = producer.send(msg, new MessageQueueSelector() {
        @Override
        public MessageQueue select(List&lt;MessageQueue&gt; mqs, Message msg, Object arg) {
            String orderId = (String) arg;
            int index = Math.abs(orderId.hashCode()) % mqs.size();
            return mqs.get(index);
        }
    }, &quot;orderId-123&quot;);
}

// 顺序消息消费者
DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(&quot;order-consumer-group&quot;);
consumer.setNamesrvAddr(&quot;localhost:9876&quot;);
consumer.subscribe(&quot;order-topic&quot;, &quot;*&quot;);
consumer.registerMessageListener(new MessageListenerOrderly() {
    @Override
    public ConsumeOrderlyStatus consumeMessage(
        List&lt;MessageExt&gt; msgs, ConsumeOrderlyContext context) {
        
        for (MessageExt msg : msgs) {
            // 顺序处理消息
            processOrderMessage(msg);
        }
        
        return ConsumeOrderlyStatus.SUCCESS;
    }
});
consumer.start();
</code></pre>
<h2>RabbitMQ详解</h2>
<h3>1. RabbitMQ架构</h3>
<pre><code>RabbitMQ架构图：
┌─────────────────────────────────────────────────────────────┐
│                    RabbitMQ                                │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐           │
│  │   Exchange  │  │   Exchange  │  │   Exchange  │           │
│  │    Direct   │  │   Topic     │  │   Fanout    │           │
│  └─────────────┘  └─────────────┘  └─────────────┘           │
│         ↓                   ↓                   ↓           │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │                   Queue                                │ │
│  │  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐   │ │
│  │  │ Queue 1 │  │ Queue 2 │  │ Queue 3 │  │ Queue 4 │   │ │
│  │  └─────────┘  └─────────┘  └─────────┘  └─────────┘   │ │
│  └─────────────────────────────────────────────────────────┘ │
│         ↓                   ↓                   ↓           │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐           │
│  │   Consumer  │  │   Consumer  │  │   Consumer  │           │
│  └─────────────┘  └─────────────┘  └─────────────┘           │
└─────────────────────────────────────────────────────────────┘
</code></pre>
<h3>2. RabbitMQ特性</h3>
<p><strong>交换机类型</strong></p>
<pre><code class="language-java">// Direct Exchange（直连交换机）
@Configuration
public class RabbitConfig {
    
    @Bean
    public DirectExchange directExchange() {
        return new DirectExchange(&quot;direct.exchange&quot;);
    }
    
    @Bean
    public Queue directQueue1() {
        return QueueBuilder.durable(&quot;direct.queue.1&quot;).build();
    }
    
    @Bean
    public Binding directBinding1() {
        return BindingBuilder.bind(directQueue1())
            .to(directExchange()).with(&quot;routing.key.1&quot;);
    }
}

// Topic Exchange（主题交换机）
@Bean
public TopicExchange topicExchange() {
    return new TopicExchange(&quot;topic.exchange&quot;);
}

@Bean
public Queue topicQueue1() {
    return QueueBuilder.durable(&quot;topic.queue.1&quot;).build();
}

@Bean
public Binding topicBinding1() {
    return BindingBuilder.bind(topicQueue1())
        .to(topicExchange()).with(&quot;*.error&quot;);
}

// Fanout Exchange（扇出交换机）
@Bean
public FanoutExchange fanoutExchange() {
    return new FanoutExchange(&quot;fanout.exchange&quot;);
}

@Bean
public Queue fanoutQueue1() {
    return QueueBuilder.durable(&quot;fanout.queue.1&quot;).build();
}

@Bean
public Binding fanoutBinding1() {
    return BindingBuilder.bind(fanoutQueue1()).to(fanoutExchange());
}
</code></pre>
<p><strong>消息确认机制</strong></p>
<pre><code class="language-java">// 发送者确认
@Bean
public RabbitTemplate rabbitTemplate(ConnectionFactory connectionFactory) {
    RabbitTemplate template = new RabbitTemplate(connectionFactory);
    template.setConfirmCallback((correlationData, ack, cause) -&gt; {
        if (ack) {
            System.out.println(&quot;消息发送成功: &quot; + correlationData.getId());
        } else {
            System.err.println(&quot;消息发送失败: &quot; + cause);
        }
    });
    
    template.setReturnCallback((message, replyCode, replyText, exchange, routingKey) -&gt; {
        System.err.println(&quot;消息返回: &quot; + message);
    });
    
    return template;
}

// 消费者确认
@RabbitListener(queues = &quot;test.queue&quot;)
public void handleMessage(Message message, Channel channel) {
    try {
        // 处理消息
        String content = new String(message.getBody());
        processMessage(content);
        
        // 手动确认
        channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);
    } catch (Exception e) {
        try {
            // 拒绝消息（不重新入队）
            channel.basicNack(message.getMessageProperties().getDeliveryTag(), 
                            false, false);
        } catch (IOException ioException) {
            ioException.printStackTrace();
        }
    }
}
</code></pre>
<h2>MQ选型指南</h2>
<h3>1. 选型维度</h3>
<pre><code>MQ选型评估维度：
├── 性能要求
│   ├── 吞吐量
│   ├── 延迟
│   └── 并发能力
├── 功能需求
│   ├── 消息顺序
│   ├── 事务消息
│   ├── 消息重试
│   └── 死信队列
├── 可靠性
│   ├── 数据持久化
│   ├── 集群支持
│   ├── 故障恢复
│   └── 数据备份
├── 运维复杂度
│   ├── 部署难度
│   ├── 监控能力
│   ├── 故障排查
│   └── 扩展性
└── 生态系统
    ├── 社区活跃度
    ├── 文档完整性
    ├── 工具支持
    └── 学习成本
</code></pre>
<h3>2. 选型决策树</h3>
<pre><code>选型决策流程：
是否需要高吞吐量？
├── 是 → 是否需要强顺序性？
│   ├── 是 → RocketMQ
│   └── 否 → Kafka
└── 否 → 是否需要复杂路由？
    ├── 是 → RabbitMQ
    └── 否 → ActiveMQ/RocketMQ
</code></pre>
<h3>3. 最佳实践</h3>
<p><strong>消息设计原则</strong></p>
<pre><code class="language-java">// 消息结构设计
public class MessageEntity {
    private String messageId;    // 消息唯一ID
    private String topic;        // 主题
    private String tag;          // 标签
    private String body;         // 消息体
    private Long timestamp;      // 时间戳
    private Integer retryCount;  // 重试次数
    private Map&lt;String, String&gt; properties; // 扩展属性
}

// 消息生产者最佳实践
@Component
public class MessageProducer {
    
    @Autowired
    private KafkaTemplate&lt;String, String&gt; kafkaTemplate;
    
    public void sendMessage(String topic, Object message) {
        try {
            // 构建消息
            MessageEntity entity = new MessageEntity();
            entity.setMessageId(UUID.randomUUID().toString());
            entity.setTopic(topic);
            entity.setBody(JSON.toJSONString(message));
            entity.setTimestamp(System.currentTimeMillis());
            
            // 发送消息
            kafkaTemplate.send(topic, entity.getMessageId(), 
                JSON.toJSONString(entity))
                .addCallback(success -&gt; {
                    // 发送成功回调
                    log.info(&quot;消息发送成功: {}&quot;, entity.getMessageId());
                }, failure -&gt; {
                    // 发送失败回调
                    log.error(&quot;消息发送失败: {}&quot;, entity.getMessageId(), failure);
                    // 重试或补偿
                });
        } catch (Exception e) {
            log.error(&quot;发送消息异常&quot;, e);
        }
    }
}
</code></pre>
<h2>总结</h2>
<p>消息队列选型是一个重要的架构决策，需要综合考虑：</p>
<ol>
<li><strong>Kafka</strong>：适合大数据场景，吞吐量极高，延迟较低</li>
<li><strong>RocketMQ</strong>：适合金融场景，可靠性高，功能丰富</li>
<li><strong>RabbitMQ</strong>：适合企业应用，路由灵活，易于使用</li>
<li><strong>ActiveMQ</strong>：适合传统应用，成熟稳定，学习成本低</li>
</ol>
<p>选择MQ时，应该根据具体的业务需求、技术团队熟悉程度和运维能力来决定。没有最好的MQ，只有最适合的MQ。</p>
</div></article></div></main></div><script src="/_next/static/chunks/webpack-c81f7fd28659d64f.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/55b7a9e84b417e65.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"2:I[2846,[],\"\"]\n5:I[4707,[],\"\"]\n8:I[6423,[],\"\"]\nb:I[1060,[],\"\"]\n6:[\"category\",\"notes\",\"d\"]\n7:[\"slug\",\"popular-message-queues\",\"d\"]\nc:[]\n0:[\"$\",\"$L2\",null,{\"buildId\":\"build\",\"assetPrefix\":\"\",\"urlParts\":[\"\",\"notes\",\"popular-message-queues\",\"\"],\"initialTree\":[\"\",{\"children\":[[\"category\",\"notes\",\"d\"],{\"children\":[[\"slug\",\"popular-message-queues\",\"d\"],{\"children\":[\"__PAGE__?{\\\"category\\\":\\\"notes\\\",\\\"slug\\\":\\\"popular-message-queues\\\"}\",{}]}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"category\",\"notes\",\"d\"],{\"children\":[[\"slug\",\"popular-message-queues\",\"d\"],{\"children\":[\"__PAGE__\",{},[[\"$L3\",\"$L4\",null],null],null]},[null,[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$6\",\"children\",\"$7\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}]],null]},[null,[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$6\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}]],null]},[[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/55b7a9e84b417e65.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],\"$L9\"],null],null],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$La\"],\"globalErrorComponent\":\"$b\",\"missingSlots\":\"$Wc\"}]\n"])</script><script>self.__next_f.push([1,"d:I[2972,[\"972\",\"static/chunks/972-17ea62b17795b286.js\",\"621\",\"static/chunks/app/%5Bcategory%5D/%5Bslug%5D/page-234087874853c0eb.js\"],\"\"]\nf:I[7140,[\"972\",\"static/chunks/972-17ea62b17795b286.js\",\"185\",\"static/chunks/app/layout-8486db2c9a537bdb.js\"],\"default\"]\ne:T5b5f,"])</script><script>self.__next_f.push([1,"\u003ch1\u003e热门MQ详解\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e消息队列是分布式系统的重要组件，选择合适的MQ对系统架构至关重要\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003e消息队列概述\u003c/h2\u003e\n\u003ch3\u003e1. 消息队列的作用\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003e消息队列核心价值：\n├── 解耦\n│   ├── 生产者与消费者解耦\n│   ├── 业务逻辑与技术实现解耦\n│   └── 系统模块间解耦\n├── 异步\n│   ├── 提升系统响应速度\n│   ├── 改善用户体验\n│   └── 提高系统吞吐量\n├── 削峰\n│   ├── 平滑流量峰值\n│   ├── 保护后端系统\n│   └── 提升系统稳定性\n└── 可靠性\n    ├── 消息持久化\n    ├── 重试机制\n    └── 事务支持\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e2. 主流MQ对比\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e特性\u003c/th\u003e\n\u003cth\u003eKafka\u003c/th\u003e\n\u003cth\u003eRocketMQ\u003c/th\u003e\n\u003cth\u003eRabbitMQ\u003c/th\u003e\n\u003cth\u003eActiveMQ\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e吞吐量\u003c/td\u003e\n\u003ctd\u003e极高\u003c/td\u003e\n\u003ctd\u003e高\u003c/td\u003e\n\u003ctd\u003e中等\u003c/td\u003e\n\u003ctd\u003e中等\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e延迟\u003c/td\u003e\n\u003ctd\u003e低\u003c/td\u003e\n\u003ctd\u003e低\u003c/td\u003e\n\u003ctd\u003e低\u003c/td\u003e\n\u003ctd\u003e中等\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e可靠性\u003c/td\u003e\n\u003ctd\u003e高\u003c/td\u003e\n\u003ctd\u003e高\u003c/td\u003e\n\u003ctd\u003e高\u003c/td\u003e\n\u003ctd\u003e中等\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e复杂度\u003c/td\u003e\n\u003ctd\u003e高\u003c/td\u003e\n\u003ctd\u003e中等\u003c/td\u003e\n\u003ctd\u003e低\u003c/td\u003e\n\u003ctd\u003e低\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e生态\u003c/td\u003e\n\u003ctd\u003e丰富\u003c/td\u003e\n\u003ctd\u003e良好\u003c/td\u003e\n\u003ctd\u003e一般\u003c/td\u003e\n\u003ctd\u003e一般\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch2\u003eKafka详解\u003c/h2\u003e\n\u003ch3\u003e1. Kafka架构\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003eKafka架构图：\n┌─────────────────────────────────────────────────────────────┐\n│                    Kafka Cluster                            │\n├─────────────────────────────────────────────────────────────┤\n│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐           │\n│  │  Broker 1   │  │  Broker 2   │  │  Broker 3   │           │\n│  │             │  │             │  │             │           │\n│  │ ┌─────────┐ │  │ ┌─────────┐ │  │ ┌─────────┐ │           │\n│  │ │ Topic A │ │  │ │ Topic A │ │  │ │ Topic A │ │           │\n│  │ └─────────┘ │  │ └─────────┘ │  │ └─────────┘ │           │\n│  │ ┌─────────┐ │  │ ┌─────────┐ │  │ ┌─────────┐ │           │\n│  │ │ Topic B │ │  │ │ Topic B │ │  │ │ Topic B │ │           │\n│  │ └─────────┘ │  │ └─────────┘ │  │ └─────────┘ │           │\n│  └─────────────┘  └─────────────┘  └─────────────┘           │\n└─────────────────────────────────────────────────────────────┘\n         ↑                    ↑                    ↑\n    ┌─────────────┐     ┌─────────────┐     ┌─────────────┐\n    │   Producer  │     │  Producer   │     │  Producer   │\n    └─────────────┘     └─────────────┘     └─────────────┘\n         ↓                    ↓                    ↓\n    ┌─────────────┐     ┌─────────────┐     ┌─────────────┐\n    │   Consumer  │     │  Consumer   │     │  Consumer   │\n    │    Group    │     │   Group     │     │   Group     │\n    └─────────────┘     └─────────────┘     └─────────────┘\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e2. Kafka核心概念\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003ePartition机制\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// Kafka生产者配置\nProperties props = new Properties();\nprops.put(\u0026quot;bootstrap.servers\u0026quot;, \u0026quot;localhost:9092\u0026quot;);\nprops.put(\u0026quot;key.serializer\u0026quot;, \u0026quot;org.apache.kafka.common.serialization.StringSerializer\u0026quot;);\nprops.put(\u0026quot;value.serializer\u0026quot;, \u0026quot;org.apache.kafka.common.serialization.StringSerializer\u0026quot;);\n\n// 创建生产者\nKafkaProducer\u0026lt;String, String\u0026gt; producer = new KafkaProducer\u0026lt;\u0026gt;(props);\n\n// 发送消息（指定分区）\nProducerRecord\u0026lt;String, String\u0026gt; record = \n    new ProducerRecord\u0026lt;\u0026gt;(\u0026quot;topic-name\u0026quot;, 0, \u0026quot;key\u0026quot;, \u0026quot;value\u0026quot;);\n\n// 自定义分区策略\npublic class CustomPartitioner implements Partitioner {\n    @Override\n    public int partition(String topic, Object key, byte[] keyBytes, \n                       Object value, byte[] valueBytes, Cluster cluster) {\n        // 自定义分区逻辑\n        return Math.abs(key.hashCode()) % cluster.partitionCountForTopic(topic);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eConsumer Group\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// Kafka消费者配置\nProperties props = new Properties();\nprops.put(\u0026quot;bootstrap.servers\u0026quot;, \u0026quot;localhost:9092\u0026quot;);\nprops.put(\u0026quot;group.id\u0026quot;, \u0026quot;consumer-group-1\u0026quot;);\nprops.put(\u0026quot;enable.auto.commit\u0026quot;, \u0026quot;true\u0026quot;);\nprops.put(\u0026quot;auto.commit.interval.ms\u0026quot;, \u0026quot;1000\u0026quot;);\nprops.put(\u0026quot;key.deserializer\u0026quot;, \u0026quot;org.apache.kafka.common.serialization.StringDeserializer\u0026quot;);\nprops.put(\u0026quot;value.deserializer\u0026quot;, \u0026quot;org.apache.kafka.common.serialization.StringDeserializer\u0026quot;);\n\n// 创建消费者\nKafkaConsumer\u0026lt;String, String\u0026gt; consumer = new KafkaConsumer\u0026lt;\u0026gt;(props);\n\n// 订阅主题\nconsumer.subscribe(Arrays.asList(\u0026quot;topic-1\u0026quot;, \u0026quot;topic-2\u0026quot;));\n\n// 消费消息\nwhile (true) {\n    ConsumerRecords\u0026lt;String, String\u0026gt; records = consumer.poll(Duration.ofMillis(100));\n    for (ConsumerRecord\u0026lt;String, String\u0026gt; record : records) {\n        System.out.printf(\u0026quot;offset = %d, key = %s, value = %s%n\u0026quot;, \n                         record.offset(), record.key(), record.value());\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e3. Kafka性能优化\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e生产者优化\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// 生产者性能优化配置\nprops.put(\u0026quot;batch.size\u0026quot;, 16384);           // 批量大小\nprops.put(\u0026quot;linger.ms\u0026quot;, 5);               // 等待时间\nprops.put(\u0026quot;compression.type\u0026quot;, \u0026quot;snappy\u0026quot;); // 压缩类型\nprops.put(\u0026quot;acks\u0026quot;, \u0026quot;all\u0026quot;);                // 确认机制\nprops.put(\u0026quot;retries\u0026quot;, 3);                 // 重试次数\nprops.put(\u0026quot;max.in.flight.requests.per.connection\u0026quot;, 5);\n\n// 异步发送优化\nList\u0026lt;Future\u0026lt;RecordMetadata\u0026gt;\u0026gt; futures = new ArrayList\u0026lt;\u0026gt;();\n\nfor (int i = 0; i \u0026lt; 1000; i++) {\n    ProducerRecord\u0026lt;String, String\u0026gt; record = \n        new ProducerRecord\u0026lt;\u0026gt;(\u0026quot;topic-name\u0026quot;, \u0026quot;key-\u0026quot; + i, \u0026quot;value-\u0026quot; + i);\n    \n    Future\u0026lt;RecordMetadata\u0026gt; future = producer.send(record, (metadata, exception) -\u0026gt; {\n        if (exception != null) {\n            // 处理发送失败\n            exception.printStackTrace();\n        }\n    });\n    \n    futures.add(future);\n}\n\n// 等待所有消息发送完成\nfor (Future\u0026lt;RecordMetadata\u0026gt; future : futures) {\n    try {\n        future.get();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eRocketMQ详解\u003c/h2\u003e\n\u003ch3\u003e1. RocketMQ架构\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003eRocketMQ架构图：\n┌─────────────────────────────────────────────────────────────┐\n│                    Name Server                              │\n│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐           │\n│  │ NameServer1 │  │ NameServer2 │  │ NameServer3 │           │\n│  └─────────────┘  └─────────────┘  └─────────────┘           │\n└─────────────────────────────────────────────────────────────┘\n         ↓                    ↓                    ↓\n┌─────────────────────────────────────────────────────────────┐\n│                    Broker Cluster                           │\n├─────────────────────────────────────────────────────────────┤\n│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐           │\n│  │  Master 1   │  │  Master 2   │  │  Master 3   │           │\n│  │             │  │             │  │             │           │\n│  │ ┌─────────┐ │  │ ┌─────────┐ │  │ ┌─────────┐ │           │\n│  │ │ Topic A │ │  │ │ Topic B │ │  │ │ Topic C │ │           │\n│  │ └─────────┘ │  │ └─────────┘ │  │ └─────────┘ │           │\n│  └─────────────┘  └─────────────┘  └─────────────┘           │\n│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐           │\n│  │  Slave 1    │  │  Slave 2    │  │  Slave 3    │           │\n│  └─────────────┘  └─────────────┘  └─────────────┘           │\n└─────────────────────────────────────────────────────────────┘\n         ↑                    ↑                    ↑\n    ┌─────────────┐     ┌─────────────┐     ┌─────────────┐\n    │   Producer  │     │  Producer   │     │  Producer   │\n    └─────────────┘     └─────────────┘     └─────────────┘\n         ↓                    ↓                    ↓\n    ┌─────────────┐     ┌─────────────┐     ┌─────────────┐\n    │   Consumer  │     │  Consumer   │     │  Consumer   │\n    └─────────────┘     └─────────────┘     └─────────────┘\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e2. RocketMQ特性\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e事务消息\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// 事务消息生产者\nTransactionMQProducer producer = new TransactionMQProducer(\u0026quot;transaction-producer-group\u0026quot;);\nproducer.setNamesrvAddr(\u0026quot;localhost:9876\u0026quot;);\nproducer.setTransactionListener(new TransactionListener() {\n    \n    @Override\n    public LocalTransactionState executeLocalTransaction(Message msg, Object arg) {\n        // 执行本地事务\n        try {\n            // 本地业务逻辑\n            boolean success = processLocalTransaction(msg);\n            return success ? LocalTransactionState.COMMIT_MESSAGE : \n                           LocalTransactionState.ROLLBACK_MESSAGE;\n        } catch (Exception e) {\n            return LocalTransactionState.ROLLBACK_MESSAGE;\n        }\n    }\n    \n    @Override\n    public LocalTransactionState checkLocalTransaction(Message msg) {\n        // 检查本地事务状态\n        boolean success = checkLocalTransactionStatus(msg);\n        return success ? LocalTransactionState.COMMIT_MESSAGE : \n                       LocalTransactionState.ROLLBACK_MESSAGE;\n    }\n});\n\n// 发送事务消息\nMessage msg = new Message(\u0026quot;topic-name\u0026quot;, \u0026quot;tag\u0026quot;, \u0026quot;key\u0026quot;, \u0026quot;message body\u0026quot;.getBytes());\nTransactionSendResult result = producer.sendMessageInTransaction(msg, null);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e顺序消息\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// 顺序消息生产者\nDefaultMQProducer producer = new DefaultMQProducer(\u0026quot;order-producer-group\u0026quot;);\nproducer.setNamesrvAddr(\u0026quot;localhost:9876\u0026quot;);\nproducer.start();\n\n// 发送顺序消息\nfor (int i = 0; i \u0026lt; 10; i++) {\n    Message msg = new Message(\u0026quot;order-topic\u0026quot;, \u0026quot;order\u0026quot;, \n        (\u0026quot;order-\u0026quot; + i).getBytes());\n    \n    // 使用相同的orderId作为选择队列的key\n    SendResult result = producer.send(msg, new MessageQueueSelector() {\n        @Override\n        public MessageQueue select(List\u0026lt;MessageQueue\u0026gt; mqs, Message msg, Object arg) {\n            String orderId = (String) arg;\n            int index = Math.abs(orderId.hashCode()) % mqs.size();\n            return mqs.get(index);\n        }\n    }, \u0026quot;orderId-123\u0026quot;);\n}\n\n// 顺序消息消费者\nDefaultMQPushConsumer consumer = new DefaultMQPushConsumer(\u0026quot;order-consumer-group\u0026quot;);\nconsumer.setNamesrvAddr(\u0026quot;localhost:9876\u0026quot;);\nconsumer.subscribe(\u0026quot;order-topic\u0026quot;, \u0026quot;*\u0026quot;);\nconsumer.registerMessageListener(new MessageListenerOrderly() {\n    @Override\n    public ConsumeOrderlyStatus consumeMessage(\n        List\u0026lt;MessageExt\u0026gt; msgs, ConsumeOrderlyContext context) {\n        \n        for (MessageExt msg : msgs) {\n            // 顺序处理消息\n            processOrderMessage(msg);\n        }\n        \n        return ConsumeOrderlyStatus.SUCCESS;\n    }\n});\nconsumer.start();\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eRabbitMQ详解\u003c/h2\u003e\n\u003ch3\u003e1. RabbitMQ架构\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003eRabbitMQ架构图：\n┌─────────────────────────────────────────────────────────────┐\n│                    RabbitMQ                                │\n├─────────────────────────────────────────────────────────────┤\n│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐           │\n│  │   Exchange  │  │   Exchange  │  │   Exchange  │           │\n│  │    Direct   │  │   Topic     │  │   Fanout    │           │\n│  └─────────────┘  └─────────────┘  └─────────────┘           │\n│         ↓                   ↓                   ↓           │\n│  ┌─────────────────────────────────────────────────────────┐ │\n│  │                   Queue                                │ │\n│  │  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐   │ │\n│  │  │ Queue 1 │  │ Queue 2 │  │ Queue 3 │  │ Queue 4 │   │ │\n│  │  └─────────┘  └─────────┘  └─────────┘  └─────────┘   │ │\n│  └─────────────────────────────────────────────────────────┘ │\n│         ↓                   ↓                   ↓           │\n│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐           │\n│  │   Consumer  │  │   Consumer  │  │   Consumer  │           │\n│  └─────────────┘  └─────────────┘  └─────────────┘           │\n└─────────────────────────────────────────────────────────────┘\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e2. RabbitMQ特性\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e交换机类型\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// Direct Exchange（直连交换机）\n@Configuration\npublic class RabbitConfig {\n    \n    @Bean\n    public DirectExchange directExchange() {\n        return new DirectExchange(\u0026quot;direct.exchange\u0026quot;);\n    }\n    \n    @Bean\n    public Queue directQueue1() {\n        return QueueBuilder.durable(\u0026quot;direct.queue.1\u0026quot;).build();\n    }\n    \n    @Bean\n    public Binding directBinding1() {\n        return BindingBuilder.bind(directQueue1())\n            .to(directExchange()).with(\u0026quot;routing.key.1\u0026quot;);\n    }\n}\n\n// Topic Exchange（主题交换机）\n@Bean\npublic TopicExchange topicExchange() {\n    return new TopicExchange(\u0026quot;topic.exchange\u0026quot;);\n}\n\n@Bean\npublic Queue topicQueue1() {\n    return QueueBuilder.durable(\u0026quot;topic.queue.1\u0026quot;).build();\n}\n\n@Bean\npublic Binding topicBinding1() {\n    return BindingBuilder.bind(topicQueue1())\n        .to(topicExchange()).with(\u0026quot;*.error\u0026quot;);\n}\n\n// Fanout Exchange（扇出交换机）\n@Bean\npublic FanoutExchange fanoutExchange() {\n    return new FanoutExchange(\u0026quot;fanout.exchange\u0026quot;);\n}\n\n@Bean\npublic Queue fanoutQueue1() {\n    return QueueBuilder.durable(\u0026quot;fanout.queue.1\u0026quot;).build();\n}\n\n@Bean\npublic Binding fanoutBinding1() {\n    return BindingBuilder.bind(fanoutQueue1()).to(fanoutExchange());\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e消息确认机制\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// 发送者确认\n@Bean\npublic RabbitTemplate rabbitTemplate(ConnectionFactory connectionFactory) {\n    RabbitTemplate template = new RabbitTemplate(connectionFactory);\n    template.setConfirmCallback((correlationData, ack, cause) -\u0026gt; {\n        if (ack) {\n            System.out.println(\u0026quot;消息发送成功: \u0026quot; + correlationData.getId());\n        } else {\n            System.err.println(\u0026quot;消息发送失败: \u0026quot; + cause);\n        }\n    });\n    \n    template.setReturnCallback((message, replyCode, replyText, exchange, routingKey) -\u0026gt; {\n        System.err.println(\u0026quot;消息返回: \u0026quot; + message);\n    });\n    \n    return template;\n}\n\n// 消费者确认\n@RabbitListener(queues = \u0026quot;test.queue\u0026quot;)\npublic void handleMessage(Message message, Channel channel) {\n    try {\n        // 处理消息\n        String content = new String(message.getBody());\n        processMessage(content);\n        \n        // 手动确认\n        channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);\n    } catch (Exception e) {\n        try {\n            // 拒绝消息（不重新入队）\n            channel.basicNack(message.getMessageProperties().getDeliveryTag(), \n                            false, false);\n        } catch (IOException ioException) {\n            ioException.printStackTrace();\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eMQ选型指南\u003c/h2\u003e\n\u003ch3\u003e1. 选型维度\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003eMQ选型评估维度：\n├── 性能要求\n│   ├── 吞吐量\n│   ├── 延迟\n│   └── 并发能力\n├── 功能需求\n│   ├── 消息顺序\n│   ├── 事务消息\n│   ├── 消息重试\n│   └── 死信队列\n├── 可靠性\n│   ├── 数据持久化\n│   ├── 集群支持\n│   ├── 故障恢复\n│   └── 数据备份\n├── 运维复杂度\n│   ├── 部署难度\n│   ├── 监控能力\n│   ├── 故障排查\n│   └── 扩展性\n└── 生态系统\n    ├── 社区活跃度\n    ├── 文档完整性\n    ├── 工具支持\n    └── 学习成本\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e2. 选型决策树\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003e选型决策流程：\n是否需要高吞吐量？\n├── 是 → 是否需要强顺序性？\n│   ├── 是 → RocketMQ\n│   └── 否 → Kafka\n└── 否 → 是否需要复杂路由？\n    ├── 是 → RabbitMQ\n    └── 否 → ActiveMQ/RocketMQ\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e3. 最佳实践\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e消息设计原则\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// 消息结构设计\npublic class MessageEntity {\n    private String messageId;    // 消息唯一ID\n    private String topic;        // 主题\n    private String tag;          // 标签\n    private String body;         // 消息体\n    private Long timestamp;      // 时间戳\n    private Integer retryCount;  // 重试次数\n    private Map\u0026lt;String, String\u0026gt; properties; // 扩展属性\n}\n\n// 消息生产者最佳实践\n@Component\npublic class MessageProducer {\n    \n    @Autowired\n    private KafkaTemplate\u0026lt;String, String\u0026gt; kafkaTemplate;\n    \n    public void sendMessage(String topic, Object message) {\n        try {\n            // 构建消息\n            MessageEntity entity = new MessageEntity();\n            entity.setMessageId(UUID.randomUUID().toString());\n            entity.setTopic(topic);\n            entity.setBody(JSON.toJSONString(message));\n            entity.setTimestamp(System.currentTimeMillis());\n            \n            // 发送消息\n            kafkaTemplate.send(topic, entity.getMessageId(), \n                JSON.toJSONString(entity))\n                .addCallback(success -\u0026gt; {\n                    // 发送成功回调\n                    log.info(\u0026quot;消息发送成功: {}\u0026quot;, entity.getMessageId());\n                }, failure -\u0026gt; {\n                    // 发送失败回调\n                    log.error(\u0026quot;消息发送失败: {}\u0026quot;, entity.getMessageId(), failure);\n                    // 重试或补偿\n                });\n        } catch (Exception e) {\n            log.error(\u0026quot;发送消息异常\u0026quot;, e);\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e总结\u003c/h2\u003e\n\u003cp\u003e消息队列选型是一个重要的架构决策，需要综合考虑：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eKafka\u003c/strong\u003e：适合大数据场景，吞吐量极高，延迟较低\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eRocketMQ\u003c/strong\u003e：适合金融场景，可靠性高，功能丰富\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eRabbitMQ\u003c/strong\u003e：适合企业应用，路由灵活，易于使用\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eActiveMQ\u003c/strong\u003e：适合传统应用，成熟稳定，学习成本低\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e选择MQ时，应该根据具体的业务需求、技术团队熟悉程度和运维能力来决定。没有最好的MQ，只有最适合的MQ。\u003c/p\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"children\":[[\"$\",\"$Ld\",null,{\"href\":\"/notes\",\"className\":\"back-button\",\"style\":{\"display\":\"inline-block\",\"background\":\"var(--primary-color)\",\"color\":\"white\",\"border\":\"none\",\"padding\":\"10px 20px\",\"borderRadius\":\"6px\",\"cursor\":\"pointer\",\"marginBottom\":\"20px\",\"textDecoration\":\"none\"},\"children\":[\"← 返回\",\"笔记\",\"列表\"]}],[\"$\",\"article\",null,{\"className\":\"section\",\"children\":[[\"$\",\"header\",null,{\"className\":\"article-header\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"article-title\",\"children\":\"热门MQ详解\"}],[\"$\",\"div\",null,{\"className\":\"article-meta\",\"children\":[[\"$\",\"div\",null,{\"className\":\"article-meta-info\",\"children\":[[\"$\",\"span\",null,{\"className\":\"article-date\",\"children\":\"2024-10-14\"}],[\"$\",\"span\",null,{\"className\":\"article-category\",\"children\":[\"• \",\"笔记\"]}]]}],[\"$\",\"div\",null,{\"className\":\"article-tags\",\"children\":[[\"$\",\"span\",\"消息队列\",{\"className\":\"tag\",\"children\":\"消息队列\"}],[\"$\",\"span\",\"Kafka\",{\"className\":\"tag\",\"children\":\"Kafka\"}],[\"$\",\"span\",\"RocketMQ\",{\"className\":\"tag\",\"children\":\"RocketMQ\"}],[\"$\",\"span\",\"RabbitMQ\",{\"className\":\"tag\",\"children\":\"RabbitMQ\"}],[\"$\",\"span\",\"技术选型\",{\"className\":\"tag\",\"children\":\"技术选型\"}]]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"card markdown-content\",\"dangerouslySetInnerHTML\":{\"__html\":\"$e\"}}]]}]]}]\n"])</script><script>self.__next_f.push([1,"9:[\"$\",\"html\",null,{\"lang\":\"zh-CN\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"link\",null,{\"rel\":\"stylesheet\",\"href\":\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css\"}],[\"$\",\"link\",null,{\"rel\":\"stylesheet\",\"href\":\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css\"}]]}],[\"$\",\"body\",null,{\"children\":[\"$\",\"div\",null,{\"className\":\"app\",\"children\":[[\"$\",\"$Lf\",null,{\"siteConfig\":{\"name\":\"Rudy Yang\",\"bio\":\"JAVA | AI | WEB3\",\"social\":[{\"name\":\"github\",\"icon\":\"fab fa-github\",\"url\":\"https://github.com/suogongy\"},{\"name\":\"twitter\",\"icon\":\"fab fa-twitter\",\"url\":\"https://twitter.com/suogongy\"},{\"name\":\"email\",\"icon\":\"fas fa-envelope\",\"url\":\"mailto:haiyuan1832@163.com\"}]}}],[\"$\",\"main\",null,{\"className\":\"main-content\",\"children\":[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"热门MQ详解 - Personal GitHub Page\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"深入分析主流消息队列的技术特点、架构设计、性能差异和选型建议，帮助开发者选择合适的消息中间件。\"}]]\n3:null\n"])</script></body></html>