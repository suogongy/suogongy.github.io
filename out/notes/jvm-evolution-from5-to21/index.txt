3:I[4707,[],""]
6:I[6423,[],""]
4:["category","notes","d"]
5:["slug","jvm-evolution-from5-to21","d"]
0:["build",[[["",{"children":[["category","notes","d"],{"children":[["slug","jvm-evolution-from5-to21","d"],{"children":["__PAGE__?{\"category\":\"notes\",\"slug\":\"jvm-evolution-from5-to21\"}",{}]}]}]},"$undefined","$undefined",true],["",{"children":[["category","notes","d"],{"children":[["slug","jvm-evolution-from5-to21","d"],{"children":["__PAGE__",{},[["$L1","$L2",null],null],null]},[null,["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","$4","children","$5","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L6",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined"}]],null]},[null,["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","$4","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L6",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined"}]],null]},[[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/55b7a9e84b417e65.css","precedence":"next","crossOrigin":"$undefined"}]],"$L7"],null],null],["$L8",null]]]]
9:I[2972,["972","static/chunks/972-17ea62b17795b286.js","621","static/chunks/app/%5Bcategory%5D/%5Bslug%5D/page-234087874853c0eb.js"],""]
b:I[7140,["972","static/chunks/972-17ea62b17795b286.js","185","static/chunks/app/layout-8486db2c9a537bdb.js"],"default"]
a:T39cb,<h1>JVM的发展之路，从5到21</h1>
<blockquote>
<p>Java虚拟机的演进历程，是Java技术持续创新和性能提升的重要见证</p>
</blockquote>
<h2>引言</h2>
<p>Java虚拟机（JVM）是Java技术的核心，它为Java程序提供了跨平台的能力。从Java 5到Java 21，JVM在性能、内存管理、垃圾回收、编译优化等方面都取得了巨大的进步。本文将详细介绍JVM在这一时期的重要发展和变化。</p>
<h2>Java 5 (Tiger, 2004年) - 里程碑式的改进</h2>
<h3>1. 垃圾回收器改进</h3>
<p><strong>CMS垃圾回收器</strong></p>
<ul>
<li>引入了CMS（Concurrent Mark Sweep）收集器</li>
<li>以获取最短回收停顿时间为目标</li>
<li>标记-清除算法，支持并发标记和并发清除</li>
<li>适用于对响应时间有要求的场景</li>
</ul>
<p><strong>内存模型改进</strong></p>
<ul>
<li>完善了Java内存模型（JMM）</li>
<li>引入了happens-before原则</li>
<li>提供了更好的并发编程支持</li>
<li>增强了volatile和synchronized的语义</li>
</ul>
<h3>2. 编译器优化</h3>
<p><strong>逃逸分析</strong></p>
<ul>
<li>引入逃逸分析技术</li>
<li>优化对象分配和同步</li>
<li>支持标量替换和栈上分配</li>
<li>提升了程序执行效率</li>
</ul>
<p><strong>循环优化</strong></p>
<ul>
<li>改进了循环优化技术</li>
<li>支持循环展开和循环不变量外提</li>
<li>提升了数值计算的性能</li>
</ul>
<h3>3. 监控和诊断</h3>
<p><strong>JMX improvements</strong></p>
<ul>
<li>增强了JMX监控能力</li>
<li>提供了更丰富的运行时信息</li>
<li>支持更细粒度的监控和管理</li>
</ul>
<p><strong>代码示例</strong>：</p>
<pre><code class="language-java">// Java 5中的泛型和并发编程示例
import java.util.concurrent.*;
import java.util.*;

public class Java5Features {
    private Map&lt;String, List&lt;Integer&gt;&gt; genericMap = new HashMap&lt;&gt;();
    
    public void demonstrateConcurrency() {
        // 使用线程池和并发集合
        ExecutorService executor = Executors.newFixedThreadPool(4);
        BlockingQueue&lt;String&gt; queue = new LinkedBlockingQueue&lt;&gt;();
        
        // 提交任务
        Future&lt;String&gt; future = executor.submit(() -&gt; {
            return &quot;Task completed&quot;;
        });
    }
}
</code></pre>
<h2>Java 6 (Mustang, 2006年) - 性能优化年</h2>
<h3>1. 垃圾回收优化</h3>
<p><strong>Parallel Old GC</strong></p>
<ul>
<li>引入Parallel Old收集器</li>
<li>支持老年代的并行回收</li>
<li>提升了多核环境下的回收效率</li>
<li>适合吞吐量优先的应用</li>
</ul>
<p><strong>内存管理改进</strong></p>
<ul>
<li>优化了内存分配策略</li>
<li>改进了TLAB（Thread Local Allocation Buffer）</li>
<li>提升了多线程内存分配性能</li>
</ul>
<h3>2. 编译器升级</h3>
<p><strong>JIT编译优化</strong></p>
<ul>
<li>改进了即时编译器</li>
<li>支持更多的编译优化技术</li>
<li>提升了热点代码的执行效率</li>
<li>增强了分层编译能力</li>
</ul>
<h3>3. 监控工具</h3>
<p><strong>VisualVM</strong></p>
<ul>
<li>集成了多种监控工具</li>
<li>提供了可视化的性能分析</li>
<li>支持内存、CPU、线程等多维度监控</li>
<li>简化了性能调优工作</li>
</ul>
<p><strong>配置示例</strong>：</p>
<pre><code class="language-bash"># Java 6 JVM调优参数示例
-Xms2g -Xmx4g  # 堆内存设置
-XX:+UseParallelGC  # 使用并行垃圾回收器
-XX:+PrintGCDetails  # 打印GC详细信息
-XX:+HeapDumpOnOutOfMemoryError  # OOM时生成堆转储
</code></pre>
<h2>Java 7 (Dolphin, 2011年) - 功能增强</h2>
<h3>1. 垃圾回收器改进</h3>
<p><strong>G1垃圾回收器</strong></p>
<ul>
<li>引入G1（Garbage First）收集器</li>
<li>基于区域的内存布局</li>
<li>支持可预测的停顿时间</li>
<li>适合大内存应用</li>
</ul>
<p><strong>JVM启动优化</strong></p>
<ul>
<li>改进了JVM启动性能</li>
<li>优化了类加载过程</li>
<li>减少了启动时间和内存占用</li>
</ul>
<h3>2. 动态语言支持</h3>
<p><strong>InvokeDynamic</strong></p>
<ul>
<li>引入 invokedynamic 指令</li>
<li>支持动态语言在JVM上运行</li>
<li>提升了动态语言的执行效率</li>
<li>为JVM生态系统扩展奠定基础</li>
</ul>
<h3>3. 压缩指针</h3>
<p><strong>Compressed Oops</strong></p>
<ul>
<li>引入压缩普通对象指针</li>
<li>在64位系统上节省内存</li>
<li>提升了内存利用效率</li>
<li>减少了GC压力</li>
</ul>
<p><strong>G1配置示例</strong>：</p>
<pre><code class="language-bash"># G1垃圾回收器配置
-XX:+UseG1GC  # 启用G1收集器
-XX:MaxGCPauseMillis=200  # 最大GC停顿时间
-XX:G1HeapRegionSize=16m  # G1区域大小
-XX:G1NewSizePercent=30  # 新生代比例
</code></pre>
<h2>Java 8 (Spider, 2014年) - 里程碑式更新</h2>
<h3>1. Metaspace取代PermGen</h3>
<p><strong>永久代移除</strong></p>
<ul>
<li>移除了永久代（PermGen）</li>
<li>引入Metaspace（元空间）</li>
<li>使用本地内存存储类元数据</li>
<li>解决了永久代的内存溢出问题</li>
</ul>
<p><strong>内存管理改进</strong></p>
<ul>
<li>自动调整Metaspace大小</li>
<li>支持更灵活的内存管理</li>
<li>减少了内存相关的配置</li>
</ul>
<h3>2. Lambda表达式支持</h3>
<p><strong>函数式编程</strong></p>
<ul>
<li>支持Lambda表达式</li>
<li>引入函数式接口</li>
<li>提升了代码的简洁性和可读性</li>
<li>为Stream API奠定基础</li>
</ul>
<p><strong>性能优化</strong></p>
<ul>
<li>优化了Lambda表达式的执行</li>
<li>引入 invokedynamic 指令优化</li>
<li>提升了函数式编程的性能</li>
</ul>
<h3>3. 并发增强</h3>
<p><strong>CompletableFuture</strong></p>
<ul>
<li>引入CompletableFuture类</li>
<li>支持异步编程的新模式</li>
<li>提供了更强大的异步组合能力</li>
<li>简化了并发编程</li>
</ul>
<p><strong>代码示例</strong>：</p>
<pre><code class="language-java">// Java 8新特性示例
import java.util.stream.*;
import java.util.concurrent.CompletableFuture;
import java.util.*;

public class Java8Features {
    
    public void demonstrateStreams() {
        List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;);
        
        // Stream API使用
        List&lt;String&gt; result = list.stream()
            .filter(s -&gt; s.startsWith(&quot;a&quot;))
            .map(String::toUpperCase)
            .collect(Collectors.toList());
    }
    
    public void demonstrateAsync() {
        // CompletableFuture异步编程
        CompletableFuture&lt;String&gt; future = CompletableFuture
            .supplyAsync(() -&gt; &quot;Hello&quot;)
            .thenApply(s -&gt; s + &quot; World&quot;)
            .thenAccept(System.out::println);
    }
}
</code></pre>
<h2>Java 9-11 - 模块化和持续优化</h2>
<h3>1. Java 9 (2017年)</h3>
<p><strong>模块化系统</strong></p>
<ul>
<li>引入Jigsaw模块系统</li>
<li>提供了更好的封装性</li>
<li>减少了内存占用</li>
<li>提升了启动性能</li>
</ul>
<p><strong>G1默认GC</strong></p>
<ul>
<li>G1成为默认垃圾回收器</li>
<li>改进了G1的性能和稳定性</li>
<li>提供了更好的GC日志</li>
</ul>
<p><strong>JShell</strong></p>
<ul>
<li>引入Java REPL工具</li>
<li>支持交互式编程</li>
<li>简化了Java学习和测试</li>
</ul>
<h3>2. Java 10 (2018年)</h3>
<p><strong>局部变量类型推断</strong></p>
<ul>
<li>引入var关键字</li>
<li>支持局部变量类型推断</li>
<li>提升了代码的简洁性</li>
<li>保持了类型安全</li>
</ul>
<p><strong>性能优化</strong></p>
<ul>
<li>改进了G1垃圾回收器</li>
<li>优化了JIT编译</li>
<li>提升了容器环境的性能</li>
</ul>
<h3>3. Java 11 (2018年) - LTS版本</h3>
<p><strong>ZGC引入</strong></p>
<ul>
<li>引入ZGC（Z Garbage Collector）</li>
<li>支持TB级堆内存</li>
<li>停顿时间控制在毫秒级</li>
<li>适合大内存、低延迟应用</li>
</ul>
<p><strong>HTTP Client</strong></p>
<ul>
<li>标准化HTTP Client API</li>
<li>支持HTTP/2和WebSocket</li>
<li>提供了现代化的HTTP编程接口</li>
</ul>
<p><strong>性能提升</strong></p>
<ul>
<li>进一步优化了G1收集器</li>
<li>改进了字符串操作性能</li>
<li>增强了JIT编译优化</li>
</ul>
<p><strong>ZGC配置示例</strong>：</p>
<pre><code class="language-bash"># ZGC配置参数
-XX:+UseZGC  # 启用ZGC收集器
-XX:+UnlockExperimentalVMOptions  # 解锁实验性选项
-Xms4g -Xmx4g  # 堆内存设置
-XX:ZAllocationSpikeTolerance=5  # 分配峰值容忍度
</code></pre>
<h2>Java 12-17 - 新特性持续涌现</h2>
<h3>1. Java 12 (2019年)</h3>
<p><strong>Shenandoah GC</strong></p>
<ul>
<li>引入Shenandoah收集器</li>
<li>支持并发垃圾回收</li>
<li>提供更短的停顿时间</li>
<li>适合低延迟应用</li>
</ul>
<p><strong>JVM常量API</strong></p>
<ul>
<li>引入JVM常量API</li>
<li>提供了更好的字节码操作能力</li>
<li>支持动态语言实现</li>
</ul>
<h3>2. Java 13-17的重要改进</h3>
<p><strong>记录类型（Records）</strong></p>
<ul>
<li>Java 14引入记录类型</li>
<li>简化了数据载体类的编写</li>
<li>提供了不可变性保证</li>
<li>减少了样板代码</li>
</ul>
<p><strong>模式匹配</strong></p>
<ul>
<li>引入模式匹配特性</li>
<li>简化了instanceof操作</li>
<li>增强了代码可读性</li>
<li>逐步完善中</li>
</ul>
<p><strong>密封类（Sealed Classes）</strong></p>
<ul>
<li>Java 17引入密封类</li>
<li>提供了更好的继承控制</li>
<li>增强了类型系统的表达能力</li>
<li>支持更精确的建模</li>
</ul>
<p><strong>代码示例</strong>：</p>
<pre><code class="language-java">// Java 14+ 新特性示例
public record Point(int x, int y) {}  // 记录类型

// 模式匹配示例
if (obj instanceof String s) {
    System.out.println(s.toUpperCase());
}

// 密封类示例
public sealed interface Shape 
    permits Circle, Rectangle, Triangle {}
    
final class Circle implements Shape {
    private final double radius;
}
</code></pre>
<h2>Java 21 (2023年) - 最新LTS版本</h2>
<h3>1. 虚拟线程（Virtual Threads）</h3>
<p><strong>Project Loom</strong></p>
<ul>
<li>引入虚拟线程技术</li>
<li>轻量级线程实现</li>
<li>大幅提升并发编程能力</li>
<li>支持百万级并发连接</li>
</ul>
<p><strong>性能优势</strong></p>
<ul>
<li>减少了线程创建和切换开销</li>
<li>提升了I/O密集型应用性能</li>
<li>简化了并发编程模型</li>
<li>更好的资源利用率</li>
</ul>
<h3>2. 分代ZGC</h3>
<p><strong>Generational ZGC</strong></p>
<ul>
<li>引入分代ZGC</li>
<li>支持分代垃圾回收</li>
<li>提升了垃圾回收效率</li>
<li>减少了GC停顿时间</li>
</ul>
<h3>3. 向量API（第四轮孵化）</h3>
<p><strong>Vector API</strong></p>
<ul>
<li>提供了向量计算能力</li>
<li>支持SIMD指令优化</li>
<li>提升了数值计算性能</li>
<li>适合科学计算应用</li>
</ul>
<p><strong>虚拟线程示例</strong>：</p>
<pre><code class="language-java">// Java 21虚拟线程示例
import java.util.concurrent.*;
import java.util.stream.*;

public class VirtualThreads {
    
    public void demonstrateVirtualThreads() {
        // 创建虚拟线程
        try (ExecutorService executor = Executors.newVirtualThreadPerTaskExecutor()) {
            
            // 提交大量任务
            List&lt;Future&lt;String&gt;&gt; futures = IntStream.range(0, 1_000_000)
                .mapToObj(i -&gt; executor.submit(() -&gt; {
                    Thread.sleep(Duration.ofMillis(10));
                    return &quot;Task &quot; + i + &quot; completed&quot;;
                }))
                .toList();
                
            // 等待所有任务完成
            futures.forEach(future -&gt; {
                try {
                    future.get();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            });
        }
    }
}
</code></pre>
<h2>JVM性能调优最佳实践</h2>
<h3>1. 内存配置</h3>
<p><strong>堆内存设置</strong></p>
<pre><code class="language-bash"># 基础内存配置
-Xms4g -Xmx4g  # 初始和最大堆内存
-XX:NewRatio=2  # 新生代与老年代比例
-XX:SurvivorRatio=8  # Eden与Survivor比例
</code></pre>
<p><strong>元空间配置</strong></p>
<pre><code class="language-bash"># Metaspace配置
-XX:MetaspaceSize=256m  # 初始元空间大小
-XX:MaxMetaspaceSize=512m  # 最大元空间大小
</code></pre>
<h3>2. 垃圾回收选择</h3>
<p><strong>不同场景的GC选择</strong></p>
<pre><code class="language-bash"># 吞吐量优先 - Parallel GC
-XX:+UseParallelGC

# 低延迟优先 - G1 GC
-XX:+UseG1GC -XX:MaxGCPauseMillis=200

# 超低延迟 - ZGC
-XX:+UseZGC -Xmx8g

# 极低延迟 - Shenandoah GC
-XX:+UseShenandoahGC
</code></pre>
<h3>3. 监控和诊断</h3>
<p><strong>JVM监控参数</strong></p>
<pre><code class="language-bash"># GC日志配置
-XX:+PrintGCDetails
-XX:+PrintGCDateStamps
-XX:+PrintGCTimeStamps
-Xloggc:/path/to/gc.log

# OOM处理
-XX:+HeapDumpOnOutOfMemoryError
-XX:HeapDumpPath=/path/to/dump.hprof
</code></pre>
<h3>4. 性能优化建议</h3>
<p><strong>代码优化</strong></p>
<ul>
<li>减少对象创建和内存分配</li>
<li>使用对象池和缓存机制</li>
<li>避免内存泄漏和资源浪费</li>
<li>合理使用集合类和数据结构</li>
</ul>
<p><strong>并发优化</strong></p>
<ul>
<li>合理使用线程池和并发工具</li>
<li>避免过度同步和锁竞争</li>
<li>利用无锁数据结构和算法</li>
<li>考虑使用虚拟线程提升并发性能</li>
</ul>
<h2>总结</h2>
<p>从Java 5到Java 21，JVM经历了巨大的发展和变化。主要改进包括：</p>
<ol>
<li><strong>垃圾回收技术</strong>：从简单的Serial GC到先进的ZGC和Shenandoah，停顿时间从秒级降低到毫秒级</li>
<li><strong>内存管理</strong>：从永久代到元空间，从压缩指针到更高效的内存布局</li>
<li><strong>编译优化</strong>：JIT编译器不断优化，支持更多的编译技术和优化策略</li>
<li><strong>并发支持</strong>：从基础的synchronized到虚拟线程，并发编程能力大幅提升</li>
<li><strong>监控诊断</strong>：从基础的JMX到丰富的监控工具和诊断能力</li>
</ol>
<p>这些改进使得Java在现代应用场景中保持了强大的竞争力，无论是传统企业应用还是云原生应用，都能找到合适的JVM配置和优化方案。随着Java技术的持续发展，JVM将继续演进，为开发者提供更好的性能和更丰富的功能。</p>
2:["$","div",null,{"children":[["$","$L9",null,{"href":"/notes","className":"back-button","style":{"display":"inline-block","background":"var(--primary-color)","color":"white","border":"none","padding":"10px 20px","borderRadius":"6px","cursor":"pointer","marginBottom":"20px","textDecoration":"none"},"children":["← 返回","笔记","列表"]}],["$","article",null,{"className":"section","children":[["$","header",null,{"className":"article-header","children":[["$","h1",null,{"className":"article-title","children":"JVM的发展之路，从5到21"}],["$","div",null,{"className":"article-meta","children":[["$","div",null,{"className":"article-meta-info","children":[["$","span",null,{"className":"article-date","children":"2024-10-14"}],["$","span",null,{"className":"article-category","children":["• ","笔记"]}]]}],["$","div",null,{"className":"article-tags","children":[["$","span","JVM",{"className":"tag","children":"JVM"}],["$","span","Java",{"className":"tag","children":"Java"}],["$","span","虚拟机",{"className":"tag","children":"虚拟机"}],["$","span","性能优化",{"className":"tag","children":"性能优化"}],["$","span","垃圾回收",{"className":"tag","children":"垃圾回收"}]]}]]}]]}],["$","div",null,{"className":"card markdown-content","dangerouslySetInnerHTML":{"__html":"$a"}}]]}]]}]
7:["$","html",null,{"lang":"zh-CN","children":[["$","head",null,{"children":[["$","link",null,{"rel":"stylesheet","href":"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"}],["$","link",null,{"rel":"stylesheet","href":"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css"}]]}],["$","body",null,{"children":["$","div",null,{"className":"app","children":[["$","$Lb",null,{"siteConfig":{"name":"Rudy Yang","bio":"JAVA | AI | WEB3","social":[{"name":"github","icon":"fab fa-github","url":"https://github.com/suogongy"},{"name":"twitter","icon":"fab fa-twitter","url":"https://twitter.com/suogongy"},{"name":"email","icon":"fas fa-envelope","url":"mailto:haiyuan1832@163.com"}]}}],["$","main",null,{"className":"main-content","children":["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L6",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":"404"}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],"notFoundStyles":[]}]}]]}]}]]}]
8:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"JVM的发展之路，从5到21 - Personal GitHub Page"}],["$","meta","3",{"name":"description","content":"Java虚拟机(JVM)作为Java技术的核心，从Java 5到Java 21经历了巨大的发展和变化。本文详细介绍JVM的重要演进历程、关键特性改进和性能优化。"}]]
1:null
