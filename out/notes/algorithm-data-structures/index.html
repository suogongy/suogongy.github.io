<!DOCTYPE html><html lang="zh-CN"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/55b7a9e84b417e65.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-c81f7fd28659d64f.js"/><script src="/_next/static/chunks/fd9d1056-9f91b5e418130764.js" async=""></script><script src="/_next/static/chunks/117-ee7b0ec54963e50f.js" async=""></script><script src="/_next/static/chunks/main-app-c180f1b9030bf4f6.js" async=""></script><script src="/_next/static/chunks/972-17ea62b17795b286.js" async=""></script><script src="/_next/static/chunks/app/%5Bcategory%5D/%5Bslug%5D/page-234087874853c0eb.js" async=""></script><script src="/_next/static/chunks/app/layout-8486db2c9a537bdb.js" async=""></script><title>热门算法数据结构详解 - Personal GitHub Page</title><meta name="description" content="深入解析程序员必须掌握的核心算法和数据结构，包括时间复杂度、空间复杂度分析，以及实际应用场景。"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css"/><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body><div class="app"><header class="header "><nav class="nav-container"><a class="nav-brand" href="/"><i class="fas fa-terminal"></i>Rudy Yang</a><ul class="nav-menu"><li><a class="nav-link " href="/"><i class="fas fa-home"></i> 首页</a></li><li><a class="nav-link " href="/about/"><i class="fas fa-user"></i> 关于</a></li><li><a class="nav-link " href="/projects/"><i class="fas fa-code"></i> 项目</a></li><li><a class="nav-link " href="/notes/"><i class="fas fa-book"></i> 笔记</a></li><li><a class="nav-link " href="/articles/"><i class="fas fa-pen"></i> 随笔</a></li></ul></nav></header><main class="main-content"><div><a class="back-button" style="display:inline-block;background:var(--primary-color);color:white;border:none;padding:10px 20px;border-radius:6px;cursor:pointer;margin-bottom:20px;text-decoration:none" href="/notes/">← 返回<!-- -->笔记<!-- -->列表</a><article class="section"><header class="article-header"><h1 class="article-title">热门算法数据结构详解</h1><div class="article-meta"><div class="article-meta-info"><span class="article-date">2024-10-14</span><span class="article-category">• <!-- -->笔记</span></div><div class="article-tags"><span class="tag">算法</span><span class="tag">数据结构</span><span class="tag">时间复杂度</span><span class="tag">空间复杂度</span><span class="tag">面试</span></div></div></header><div class="card markdown-content"><h1>热门算法数据结构详解</h1>
<blockquote>
<p>掌握算法和数据结构是程序员的核心技能，也是技术面试的重点</p>
</blockquote>
<h2>时间复杂度和空间复杂度</h2>
<h3>1. 复杂度分析</h3>
<pre><code>时间复杂度等级：
O(1) &lt; O(log n) &lt; O(n) &lt; O(n log n) &lt; O(n²) &lt; O(n³) &lt; O(2^n) &lt; O(n!)

常见复杂度分析：
├── O(1) - 常数时间
│   ├── 数组访问：arr[i]
│   ├── 哈希表查找：map.get(key)
│   └── 栈操作：push/pop
├── O(log n) - 对数时间
│   ├── 二分查找
│   ├── 平衡二叉树操作
│   └── 堆操作
├── O(n) - 线性时间
│   ├── 数组遍历
│   ├── 链表遍历
│   └── 哈希表遍历
├── O(n log n) - 线性对数时间
│   ├── 快速排序
│   ├── 归并排序
│   └── 堆排序
└── O(n²) - 平方时间
    ├── 冒泡排序
    ├── 选择排序
    └── 插入排序
</code></pre>
<h3>2. 复杂度计算示例</h3>
<pre><code class="language-java">// 时间复杂度分析示例
public class ComplexityAnalysis {
    
    // O(1) - 常数时间
    public int getFirst(int[] arr) {
        return arr[0]; // 只执行一次操作
    }
    
    // O(n) - 线性时间
    public int findMax(int[] arr) {
        int max = arr[0];
        for (int i = 1; i &lt; arr.length; i++) { // 执行n次
            if (arr[i] &gt; max) {
                max = arr[i];
            }
        }
        return max;
    }
    
    // O(n²) - 平方时间
    public void bubbleSort(int[] arr) {
        for (int i = 0; i &lt; arr.length; i++) { // 外层循环n次
            for (int j = 0; j &lt; arr.length - 1 - i; j++) { // 内层循环n次
                if (arr[j] &gt; arr[j + 1]) {
                    swap(arr, j, j + 1);
                }
            }
        }
    }
    
    // O(log n) - 对数时间
    public int binarySearch(int[] arr, int target) {
        int left = 0, right = arr.length - 1;
        while (left &lt;= right) { // 每次循环范围减半
            int mid = left + (right - left) / 2;
            if (arr[mid] == target) {
                return mid;
            } else if (arr[mid] &lt; target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return -1;
    }
}
</code></pre>
<h2>核心数据结构</h2>
<h3>1. 数组（Array）</h3>
<p><strong>基本操作</strong></p>
<pre><code class="language-java">public class ArrayOperations {
    
    // 动态数组实现
    public class DynamicArray {
        private int[] data;
        private int size;
        private int capacity;
        
        public DynamicArray(int initialCapacity) {
            this.capacity = initialCapacity;
            this.data = new int[capacity];
            this.size = 0;
        }
        
        // 添加元素 - O(1)平均，O(n)最坏
        public void add(int element) {
            if (size == capacity) {
                resize();
            }
            data[size++] = element;
        }
        
        // 在指定位置插入 - O(n)
        public void insert(int index, int element) {
            if (index &lt; 0 || index &gt; size) {
                throw new IndexOutOfBoundsException();
            }
            
            if (size == capacity) {
                resize();
            }
            
            // 向后移动元素
            for (int i = size - 1; i &gt;= index; i--) {
                data[i + 1] = data[i];
            }
            
            data[index] = element;
            size++;
        }
        
        // 删除元素 - O(n)
        public int remove(int index) {
            if (index &lt; 0 || index &gt;= size) {
                throw new IndexOutOfBoundsException();
            }
            
            int removed = data[index];
            
            // 向前移动元素
            for (int i = index; i &lt; size - 1; i++) {
                data[i] = data[i + 1];
            }
            
            size--;
            return removed;
        }
        
        // 扩容 - O(n)
        private void resize() {
            capacity *= 2;
            int[] newData = new int[capacity];
            System.arraycopy(data, 0, newData, 0, size);
            data = newData;
        }
    }
}
</code></pre>
<h3>2. 链表（Linked List）</h3>
<p><strong>单链表实现</strong></p>
<pre><code class="language-java">public class LinkedList {
    
    private class Node {
        int data;
        Node next;
        
        Node(int data) {
            this.data = data;
            this.next = null;
        }
    }
    
    private Node head;
    private int size;
    
    // 头部插入 - O(1)
    public void addFirst(int data) {
        Node newNode = new Node(data);
        newNode.next = head;
        head = newNode;
        size++;
    }
    
    // 尾部插入 - O(n)
    public void addLast(int data) {
        Node newNode = new Node(data);
        
        if (head == null) {
            head = newNode;
        } else {
            Node current = head;
            while (current.next != null) {
                current = current.next;
            }
            current.next = newNode;
        }
        size++;
    }
    
    // 在指定位置插入 - O(n)
    public void insert(int index, int data) {
        if (index &lt; 0 || index &gt; size) {
            throw new IndexOutOfBoundsException();
        }
        
        if (index == 0) {
            addFirst(data);
        } else {
            Node newNode = new Node(data);
            Node prev = getNode(index - 1);
            newNode.next = prev.next;
            prev.next = newNode;
            size++;
        }
    }
    
    // 删除节点 - O(n)
    public int remove(int index) {
        if (index &lt; 0 || index &gt;= size) {
            throw new IndexOutOfBoundsException();
        }
        
        if (index == 0) {
            return removeFirst();
        } else {
            Node prev = getNode(index - 1);
            Node removed = prev.next;
            prev.next = removed.next;
            size--;
            return removed.data;
        }
    }
    
    // 反转链表 - O(n)
    public void reverse() {
        Node prev = null;
        Node current = head;
        Node next = null;
        
        while (current != null) {
            next = current.next;
            current.next = prev;
            prev = current;
            current = next;
        }
        
        head = prev;
    }
    
    // 检测环 - Floyd算法
    public boolean hasCycle() {
        Node slow = head;
        Node fast = head;
        
        while (fast != null &amp;&amp; fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
            
            if (slow == fast) {
                return true;
            }
        }
        
        return false;
    }
    
    private Node getNode(int index) {
        Node current = head;
        for (int i = 0; i &lt; index; i++) {
            current = current.next;
        }
        return current;
    }
}
</code></pre>
<h3>3. 栈和队列（Stack &amp; Queue）</h3>
<p><strong>栈实现</strong></p>
<pre><code class="language-java">public class Stack {
    private int[] data;
    private int top;
    private int capacity;
    
    public Stack(int capacity) {
        this.capacity = capacity;
        this.data = new int[capacity];
        this.top = -1;
    }
    
    // 入栈 - O(1)
    public void push(int element) {
        if (isFull()) {
            throw new StackOverflowError();
        }
        data[++top] = element;
    }
    
    // 出栈 - O(1)
    public int pop() {
        if (isEmpty()) {
            throw new EmptyStackException();
        }
        return data[top--];
    }
    
    // 查看栈顶元素 - O(1)
    public int peek() {
        if (isEmpty()) {
            throw new EmptyStackException();
        }
        return data[top];
    }
    
    public boolean isEmpty() {
        return top == -1;
    }
    
    public boolean isFull() {
        return top == capacity - 1;
    }
}
</code></pre>
<p><strong>队列实现</strong></p>
<pre><code class="language-java">public class Queue {
    private int[] data;
    private int front;
    private int rear;
    private int size;
    private int capacity;
    
    public Queue(int capacity) {
        this.capacity = capacity;
        this.data = new int[capacity];
        this.front = 0;
        this.rear = -1;
        this.size = 0;
    }
    
    // 入队 - O(1)
    public void enqueue(int element) {
        if (isFull()) {
            throw new IllegalStateException(&quot;Queue is full&quot;);
        }
        
        rear = (rear + 1) % capacity;
        data[rear] = element;
        size++;
    }
    
    // 出队 - O(1)
    public int dequeue() {
        if (isEmpty()) {
            throw new IllegalStateException(&quot;Queue is empty&quot;);
        }
        
        int element = data[front];
        front = (front + 1) % capacity;
        size--;
        return element;
    }
    
    // 查看队首元素 - O(1)
    public int peek() {
        if (isEmpty()) {
            throw new IllegalStateException(&quot;Queue is empty&quot;);
        }
        return data[front];
    }
    
    public boolean isEmpty() {
        return size == 0;
    }
    
    public boolean isFull() {
        return size == capacity;
    }
}
</code></pre>
<h3>4. 哈希表（Hash Table）</h3>
<p><strong>哈希表实现</strong></p>
<pre><code class="language-java">public class HashMap&lt;K, V&gt; {
    
    private class Entry&lt;K, V&gt; {
        K key;
        V value;
        Entry&lt;K, V&gt; next;
        
        Entry(K key, V value) {
            this.key = key;
            this.value = value;
            this.next = null;
        }
    }
    
    private Entry&lt;K, V&gt;[] table;
    private int size;
    private int capacity;
    
    public HashMap(int capacity) {
        this.capacity = capacity;
        this.table = new Entry[capacity];
        this.size = 0;
    }
    
    // 哈希函数
    private int hash(K key) {
        return Math.abs(key.hashCode()) % capacity;
    }
    
    // 插入键值对 - O(1)平均，O(n)最坏
    public void put(K key, V value) {
        int index = hash(key);
        Entry&lt;K, V&gt; entry = table[index];
        
        // 检查是否已存在
        while (entry != null) {
            if (entry.key.equals(key)) {
                entry.value = value;
                return;
            }
            entry = entry.next;
        }
        
        // 插入新节点
        Entry&lt;K, V&gt; newEntry = new Entry&lt;&gt;(key, value);
        newEntry.next = table[index];
        table[index] = newEntry;
        size++;
        
        // 检查是否需要扩容
        if (size &gt; capacity * 0.75) {
            resize();
        }
    }
    
    // 获取值 - O(1)平均，O(n)最坏
    public V get(K key) {
        int index = hash(key);
        Entry&lt;K, V&gt; entry = table[index];
        
        while (entry != null) {
            if (entry.key.equals(key)) {
                return entry.value;
            }
            entry = entry.next;
        }
        
        return null;
    }
    
    // 删除键值对 - O(1)平均，O(n)最坏
    public V remove(K key) {
        int index = hash(key);
        Entry&lt;K, V&gt; entry = table[index];
        Entry&lt;K, V&gt; prev = null;
        
        while (entry != null) {
            if (entry.key.equals(key)) {
                if (prev == null) {
                    table[index] = entry.next;
                } else {
                    prev.next = entry.next;
                }
                size--;
                return entry.value;
            }
            prev = entry;
            entry = entry.next;
        }
        
        return null;
    }
    
    // 扩容 - O(n)
    private void resize() {
        capacity *= 2;
        Entry&lt;K, V&gt;[] oldTable = table;
        table = new Entry[capacity];
        size = 0;
        
        for (Entry&lt;K, V&gt; entry : oldTable) {
            while (entry != null) {
                put(entry.key, entry.value);
                entry = entry.next;
            }
        }
    }
}
</code></pre>
<h3>5. 二叉树（Binary Tree）</h3>
<p><strong>二叉搜索树实现</strong></p>
<pre><code class="language-java">public class BinarySearchTree {
    
    private class Node {
        int data;
        Node left;
        Node right;
        
        Node(int data) {
            this.data = data;
            this.left = null;
            this.right = null;
        }
    }
    
    private Node root;
    
    // 插入节点 - O(h)，h为树的高度
    public void insert(int data) {
        root = insert(root, data);
    }
    
    private Node insert(Node node, int data) {
        if (node == null) {
            return new Node(data);
        }
        
        if (data &lt; node.data) {
            node.left = insert(node.left, data);
        } else if (data &gt; node.data) {
            node.right = insert(node.right, data);
        }
        
        return node;
    }
    
    // 查找节点 - O(h)
    public boolean search(int data) {
        return search(root, data);
    }
    
    private boolean search(Node node, int data) {
        if (node == null) {
            return false;
        }
        
        if (data == node.data) {
            return true;
        } else if (data &lt; node.data) {
            return search(node.left, data);
        } else {
            return search(node.right, data);
        }
    }
    
    // 删除节点 - O(h)
    public void delete(int data) {
        root = delete(root, data);
    }
    
    private Node delete(Node node, int data) {
        if (node == null) {
            return null;
        }
        
        if (data &lt; node.data) {
            node.left = delete(node.left, data);
        } else if (data &gt; node.data) {
            node.right = delete(node.right, data);
        } else {
            // 找到要删除的节点
            
            // 情况1：没有子节点
            if (node.left == null &amp;&amp; node.right == null) {
                return null;
            }
            
            // 情况2：只有一个子节点
            if (node.left == null) {
                return node.right;
            }
            if (node.right == null) {
                return node.left;
            }
            
            // 情况3：有两个子节点
            Node minNode = findMin(node.right);
            node.data = minNode.data;
            node.right = delete(node.right, minNode.data);
        }
        
        return node;
    }
    
    private Node findMin(Node node) {
        while (node.left != null) {
            node = node.left;
        }
        return node;
    }
    
    // 中序遍历 - O(n)
    public void inorderTraversal() {
        inorderTraversal(root);
        System.out.println();
    }
    
    private void inorderTraversal(Node node) {
        if (node != null) {
            inorderTraversal(node.left);
            System.out.print(node.data + &quot; &quot;);
            inorderTraversal(node.right);
        }
    }
    
    // 前序遍历 - O(n)
    public void preorderTraversal() {
        preorderTraversal(root);
        System.out.println();
    }
    
    private void preorderTraversal(Node node) {
        if (node != null) {
            System.out.print(node.data + &quot; &quot;);
            preorderTraversal(node.left);
            preorderTraversal(node.right);
        }
    }
    
    // 后序遍历 - O(n)
    public void postorderTraversal() {
        postorderTraversal(root);
        System.out.println();
    }
    
    private void postorderTraversal(Node node) {
        if (node != null) {
            postorderTraversal(node.left);
            postorderTraversal(node.right);
            System.out.print(node.data + &quot; &quot;);
        }
    }
}
</code></pre>
<h3>6. 堆（Heap）</h3>
<p><strong>最大堆实现</strong></p>
<pre><code class="language-java">public class MaxHeap {
    private int[] heap;
    private int size;
    private int capacity;
    
    public MaxHeap(int capacity) {
        this.capacity = capacity;
        this.heap = new int[capacity];
        this.size = 0;
    }
    
    // 获取父节点索引
    private int parent(int i) {
        return (i - 1) / 2;
    }
    
    // 获取左子节点索引
    private int left(int i) {
        return 2 * i + 1;
    }
    
    // 获取右子节点索引
    private int right(int i) {
        return 2 * i + 2;
    }
    
    // 插入元素 - O(log n)
    public void insert(int data) {
        if (size &gt;= capacity) {
            throw new IllegalStateException(&quot;Heap is full&quot;);
        }
        
        heap[size] = data;
        int current = size;
        
        // 向上调整
        while (current &gt; 0 &amp;&amp; heap[current] &gt; heap[parent(current)]) {
            swap(current, parent(current));
            current = parent(current);
        }
        
        size++;
    }
    
    // 删除最大元素 - O(log n)
    public int extractMax() {
        if (size &lt;= 0) {
            throw new IllegalStateException(&quot;Heap is empty&quot;);
        }
        
        int max = heap[0];
        heap[0] = heap[size - 1];
        size--;
        
        // 向下调整
        heapify(0);
        
        return max;
    }
    
    // 堆化 - O(log n)
    private void heapify(int i) {
        int largest = i;
        int left = left(i);
        int right = right(i);
        
        if (left &lt; size &amp;&amp; heap[left] &gt; heap[largest]) {
            largest = left;
        }
        
        if (right &lt; size &amp;&amp; heap[right] &gt; heap[largest]) {
            largest = right;
        }
        
        if (largest != i) {
            swap(i, largest);
            heapify(largest);
        }
    }
    
    // 构建堆 - O(n)
    public void buildHeap(int[] array) {
        this.heap = array;
        this.size = array.length;
        this.capacity = array.length;
        
        // 从最后一个非叶子节点开始堆化
        for (int i = size / 2 - 1; i &gt;= 0; i--) {
            heapify(i);
        }
    }
    
    // 堆排序 - O(n log n)
    public void heapSort() {
        // 构建最大堆
        buildHeap(heap);
        
        // 逐个提取最大元素
        for (int i = size - 1; i &gt; 0; i--) {
            swap(0, i);
            size--;
            heapify(0);
        }
    }
    
    private void swap(int i, int j) {
        int temp = heap[i];
        heap[i] = heap[j];
        heap[j] = temp;
    }
}
</code></pre>
<h2>核心算法</h2>
<h3>1. 排序算法</h3>
<p><strong>快速排序</strong></p>
<pre><code class="language-java">public class QuickSort {
    
    // 快速排序 - O(n log n)平均，O(n²)最坏
    public void sort(int[] arr) {
        quickSort(arr, 0, arr.length - 1);
    }
    
    private void quickSort(int[] arr, int low, int high) {
        if (low &lt; high) {
            int pivotIndex = partition(arr, low, high);
            quickSort(arr, low, pivotIndex - 1);
            quickSort(arr, pivotIndex + 1, high);
        }
    }
    
    private int partition(int[] arr, int low, int high) {
        int pivot = arr[high];
        int i = low - 1;
        
        for (int j = low; j &lt; high; j++) {
            if (arr[j] &lt;= pivot) {
                i++;
                swap(arr, i, j);
            }
        }
        
        swap(arr, i + 1, high);
        return i + 1;
    }
    
    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
</code></pre>
<p><strong>归并排序</strong></p>
<pre><code class="language-java">public class MergeSort {
    
    // 归并排序 - O(n log n)
    public void sort(int[] arr) {
        if (arr.length &lt; 2) {
            return;
        }
        
        int[] temp = new int[arr.length];
        mergeSort(arr, temp, 0, arr.length - 1);
    }
    
    private void mergeSort(int[] arr, int[] temp, int left, int right) {
        if (left &lt; right) {
            int mid = left + (right - left) / 2;
            mergeSort(arr, temp, left, mid);
            mergeSort(arr, temp, mid + 1, right);
            merge(arr, temp, left, mid, right);
        }
    }
    
    private void merge(int[] arr, int[] temp, int left, int mid, int right) {
        // 复制到临时数组
        for (int i = left; i &lt;= right; i++) {
            temp[i] = arr[i];
        }
        
        int i = left, j = mid + 1, k = left;
        
        // 合并两个有序数组
        while (i &lt;= mid &amp;&amp; j &lt;= right) {
            if (temp[i] &lt;= temp[j]) {
                arr[k++] = temp[i++];
            } else {
                arr[k++] = temp[j++];
            }
        }
        
        // 复制剩余元素
        while (i &lt;= mid) {
            arr[k++] = temp[i++];
        }
    }
}
</code></pre>
<h3>2. 搜索算法</h3>
<p><strong>二分查找</strong></p>
<pre><code class="language-java">public class BinarySearch {
    
    // 递归实现 - O(log n)
    public int searchRecursive(int[] arr, int target) {
        return searchRecursive(arr, target, 0, arr.length - 1);
    }
    
    private int searchRecursive(int[] arr, int target, int left, int right) {
        if (left &gt; right) {
            return -1;
        }
        
        int mid = left + (right - left) / 2;
        
        if (arr[mid] == target) {
            return mid;
        } else if (arr[mid] &lt; target) {
            return searchRecursive(arr, target, mid + 1, right);
        } else {
            return searchRecursive(arr, target, left, mid - 1);
        }
    }
    
    // 迭代实现 - O(log n)
    public int searchIterative(int[] arr, int target) {
        int left = 0, right = arr.length - 1;
        
        while (left &lt;= right) {
            int mid = left + (right - left) / 2;
            
            if (arr[mid] == target) {
                return mid;
            } else if (arr[mid] &lt; target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        
        return -1;
    }
    
    // 查找第一个等于target的元素
    public int findFirst(int[] arr, int target) {
        int left = 0, right = arr.length - 1;
        int result = -1;
        
        while (left &lt;= right) {
            int mid = left + (right - left) / 2;
            
            if (arr[mid] == target) {
                result = mid;
                right = mid - 1; // 继续向左查找
            } else if (arr[mid] &lt; target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        
        return result;
    }
    
    // 查找最后一个等于target的元素
    public int findLast(int[] arr, int target) {
        int left = 0, right = arr.length - 1;
        int result = -1;
        
        while (left &lt;= right) {
            int mid = left + (right - left) / 2;
            
            if (arr[mid] == target) {
                result = mid;
                left = mid + 1; // 继续向右查找
            } else if (arr[mid] &lt; target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        
        return result;
    }
}
</code></pre>
<h3>3. 动态规划</h3>
<p><strong>斐波那契数列</strong></p>
<pre><code class="language-java">public class Fibonacci {
    
    // 递归实现 - O(2^n)
    public int fibonacciRecursive(int n) {
        if (n &lt;= 1) {
            return n;
        }
        return fibonacciRecursive(n - 1) + fibonacciRecursive(n - 2);
    }
    
    // 记忆化递归 - O(n)
    public int fibonacciMemoization(int n) {
        int[] memo = new int[n + 1];
        return fibonacciMemoization(n, memo);
    }
    
    private int fibonacciMemoization(int n, int[] memo) {
        if (n &lt;= 1) {
            return n;
        }
        
        if (memo[n] != 0) {
            return memo[n];
        }
        
        memo[n] = fibonacciMemoization(n - 1, memo) + 
                 fibonacciMemoization(n - 2, memo);
        return memo[n];
    }
    
    // 动态规划 - O(n)
    public int fibonacciDP(int n) {
        if (n &lt;= 1) {
            return n;
        }
        
        int[] dp = new int[n + 1];
        dp[0] = 0;
        dp[1] = 1;
        
        for (int i = 2; i &lt;= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        
        return dp[n];
    }
    
    // 空间优化 - O(n)
    public int fibonacciOptimized(int n) {
        if (n &lt;= 1) {
            return n;
        }
        
        int prev = 0, curr = 1;
        
        for (int i = 2; i &lt;= n; i++) {
            int next = prev + curr;
            prev = curr;
            curr = next;
        }
        
        return curr;
    }
}
</code></pre>
<p><strong>最长公共子序列</strong></p>
<pre><code class="language-java">public class LongestCommonSubsequence {
    
    // 动态规划实现 - O(m*n)
    public int lcs(String text1, String text2) {
        int m = text1.length();
        int n = text2.length();
        
        int[][] dp = new int[m + 1][n + 1];
        
        for (int i = 1; i &lt;= m; i++) {
            for (int j = 1; j &lt;= n; j++) {
                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        
        return dp[m][n];
    }
    
    // 空间优化 - O(min(m,n))
    public int lcsOptimized(String text1, String text2) {
        if (text1.length() &lt; text2.length()) {
            return lcsOptimized(text2, text1);
        }
        
        int m = text1.length();
        int n = text2.length();
        
        int[] dp = new int[n + 1];
        
        for (int i = 1; i &lt;= m; i++) {
            int prev = 0;
            for (int j = 1; j &lt;= n; j++) {
                int temp = dp[j];
                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                    dp[j] = prev + 1;
                } else {
                    dp[j] = Math.max(dp[j], dp[j - 1]);
                }
                prev = temp;
            }
        }
        
        return dp[n];
    }
}
</code></pre>
<h3>4. 贪心算法</h3>
<p><strong>活动选择问题</strong></p>
<pre><code class="language-java">public class ActivitySelection {
    
    static class Activity {
        int start;
        int end;
        
        Activity(int start, int end) {
            this.start = start;
            this.end = end;
        }
    }
    
    // 贪心算法实现 - O(n log n)
    public List&lt;Integer&gt; activitySelection(Activity[] activities) {
        // 按结束时间排序
        Arrays.sort(activities, (a, b) -&gt; a.end - b.end);
        
        List&lt;Integer&gt; selected = new ArrayList&lt;&gt;();
        selected.add(0); // 选择第一个活动
        
        int lastEnd = activities[0].end;
        
        for (int i = 1; i &lt; activities.length; i++) {
            if (activities[i].start &gt;= lastEnd) {
                selected.add(i);
                lastEnd = activities[i].end;
            }
        }
        
        return selected;
    }
}
</code></pre>
<p><strong>霍夫曼编码</strong></p>
<pre><code class="language-java">public class HuffmanCoding {
    
    static class HuffmanNode implements Comparable&lt;HuffmanNode&gt; {
        char data;
        int frequency;
        HuffmanNode left, right;
        
        HuffmanNode(char data, int frequency) {
            this.data = data;
            this.frequency = frequency;
        }
        
        @Override
        public int compareTo(HuffmanNode other) {
            return this.frequency - other.frequency;
        }
    }
    
    // 构建霍夫曼树 - O(n log n)
    public HuffmanNode buildHuffmanTree(Map&lt;Character, Integer&gt; frequencyMap) {
        PriorityQueue&lt;HuffmanNode&gt; pq = new PriorityQueue&lt;&gt;();
        
        // 创建叶子节点
        for (Map.Entry&lt;Character, Integer&gt; entry : frequencyMap.entrySet()) {
            pq.add(new HuffmanNode(entry.getKey(), entry.getValue()));
        }
        
        // 构建霍夫曼树
        while (pq.size() &gt; 1) {
            HuffmanNode left = pq.poll();
            HuffmanNode right = pq.poll();
            
            HuffmanNode parent = new HuffmanNode(&#39;\0&#39;, 
                left.frequency + right.frequency);
            parent.left = left;
            parent.right = right;
            
            pq.add(parent);
        }
        
        return pq.poll();
    }
    
    // 生成霍夫曼编码 - O(n)
    public Map&lt;Character, String&gt; generateHuffmanCodes(HuffmanNode root) {
        Map&lt;Character, String&gt; codes = new HashMap&lt;&gt;();
        generateHuffmanCodes(root, &quot;&quot;, codes);
        return codes;
    }
    
    private void generateHuffmanCodes(HuffmanNode node, String code, 
                                    Map&lt;Character, String&gt; codes) {
        if (node == null) {
            return;
        }
        
        if (node.data != &#39;\0&#39;) {
            codes.put(node.data, code);
            return;
        }
        
        generateHuffmanCodes(node.left, code + &quot;0&quot;, codes);
        generateHuffmanCodes(node.right, code + &quot;1&quot;, codes);
    }
}
</code></pre>
<h2>总结</h2>
<p>掌握算法和数据结构需要：</p>
<ol>
<li><strong>理论基础</strong>：理解各种算法的原理和复杂度</li>
<li><strong>实践练习</strong>：通过编码实现加深理解</li>
<li><strong>应用场景</strong>：了解不同算法的适用场景</li>
<li><strong>优化技巧</strong>：学会优化算法的时间和空间复杂度</li>
<li><strong>持续学习</strong>：关注算法领域的新发展和最佳实践</li>
</ol>
<p>通过系统学习和大量练习，可以逐步提升算法能力，在面试和实际工作中都能游刃有余。</p>
</div></article></div></main></div><script src="/_next/static/chunks/webpack-c81f7fd28659d64f.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/55b7a9e84b417e65.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"2:I[2846,[],\"\"]\n5:I[4707,[],\"\"]\n8:I[6423,[],\"\"]\nb:I[1060,[],\"\"]\n6:[\"category\",\"notes\",\"d\"]\n7:[\"slug\",\"algorithm-data-structures\",\"d\"]\nc:[]\n0:[\"$\",\"$L2\",null,{\"buildId\":\"build\",\"assetPrefix\":\"\",\"urlParts\":[\"\",\"notes\",\"algorithm-data-structures\",\"\"],\"initialTree\":[\"\",{\"children\":[[\"category\",\"notes\",\"d\"],{\"children\":[[\"slug\",\"algorithm-data-structures\",\"d\"],{\"children\":[\"__PAGE__?{\\\"category\\\":\\\"notes\\\",\\\"slug\\\":\\\"algorithm-data-structures\\\"}\",{}]}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"category\",\"notes\",\"d\"],{\"children\":[[\"slug\",\"algorithm-data-structures\",\"d\"],{\"children\":[\"__PAGE__\",{},[[\"$L3\",\"$L4\",null],null],null]},[null,[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$6\",\"children\",\"$7\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}]],null]},[null,[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$6\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}]],null]},[[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/55b7a9e84b417e65.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],\"$L9\"],null],null],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$La\"],\"globalErrorComponent\":\"$b\",\"missingSlots\":\"$Wc\"}]\n"])</script><script>self.__next_f.push([1,"d:I[2972,[\"972\",\"static/chunks/972-17ea62b17795b286.js\",\"621\",\"static/chunks/app/%5Bcategory%5D/%5Bslug%5D/page-234087874853c0eb.js\"],\"\"]\nf:I[7140,[\"972\",\"static/chunks/972-17ea62b17795b286.js\",\"185\",\"static/chunks/app/layout-8486db2c9a537bdb.js\"],\"default\"]\ne:T777e,"])</script><script>self.__next_f.push([1,"\u003ch1\u003e热门算法数据结构详解\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e掌握算法和数据结构是程序员的核心技能，也是技术面试的重点\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003e时间复杂度和空间复杂度\u003c/h2\u003e\n\u003ch3\u003e1. 复杂度分析\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003e时间复杂度等级：\nO(1) \u0026lt; O(log n) \u0026lt; O(n) \u0026lt; O(n log n) \u0026lt; O(n²) \u0026lt; O(n³) \u0026lt; O(2^n) \u0026lt; O(n!)\n\n常见复杂度分析：\n├── O(1) - 常数时间\n│   ├── 数组访问：arr[i]\n│   ├── 哈希表查找：map.get(key)\n│   └── 栈操作：push/pop\n├── O(log n) - 对数时间\n│   ├── 二分查找\n│   ├── 平衡二叉树操作\n│   └── 堆操作\n├── O(n) - 线性时间\n│   ├── 数组遍历\n│   ├── 链表遍历\n│   └── 哈希表遍历\n├── O(n log n) - 线性对数时间\n│   ├── 快速排序\n│   ├── 归并排序\n│   └── 堆排序\n└── O(n²) - 平方时间\n    ├── 冒泡排序\n    ├── 选择排序\n    └── 插入排序\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e2. 复杂度计算示例\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// 时间复杂度分析示例\npublic class ComplexityAnalysis {\n    \n    // O(1) - 常数时间\n    public int getFirst(int[] arr) {\n        return arr[0]; // 只执行一次操作\n    }\n    \n    // O(n) - 线性时间\n    public int findMax(int[] arr) {\n        int max = arr[0];\n        for (int i = 1; i \u0026lt; arr.length; i++) { // 执行n次\n            if (arr[i] \u0026gt; max) {\n                max = arr[i];\n            }\n        }\n        return max;\n    }\n    \n    // O(n²) - 平方时间\n    public void bubbleSort(int[] arr) {\n        for (int i = 0; i \u0026lt; arr.length; i++) { // 外层循环n次\n            for (int j = 0; j \u0026lt; arr.length - 1 - i; j++) { // 内层循环n次\n                if (arr[j] \u0026gt; arr[j + 1]) {\n                    swap(arr, j, j + 1);\n                }\n            }\n        }\n    }\n    \n    // O(log n) - 对数时间\n    public int binarySearch(int[] arr, int target) {\n        int left = 0, right = arr.length - 1;\n        while (left \u0026lt;= right) { // 每次循环范围减半\n            int mid = left + (right - left) / 2;\n            if (arr[mid] == target) {\n                return mid;\n            } else if (arr[mid] \u0026lt; target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        return -1;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e核心数据结构\u003c/h2\u003e\n\u003ch3\u003e1. 数组（Array）\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e基本操作\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class ArrayOperations {\n    \n    // 动态数组实现\n    public class DynamicArray {\n        private int[] data;\n        private int size;\n        private int capacity;\n        \n        public DynamicArray(int initialCapacity) {\n            this.capacity = initialCapacity;\n            this.data = new int[capacity];\n            this.size = 0;\n        }\n        \n        // 添加元素 - O(1)平均，O(n)最坏\n        public void add(int element) {\n            if (size == capacity) {\n                resize();\n            }\n            data[size++] = element;\n        }\n        \n        // 在指定位置插入 - O(n)\n        public void insert(int index, int element) {\n            if (index \u0026lt; 0 || index \u0026gt; size) {\n                throw new IndexOutOfBoundsException();\n            }\n            \n            if (size == capacity) {\n                resize();\n            }\n            \n            // 向后移动元素\n            for (int i = size - 1; i \u0026gt;= index; i--) {\n                data[i + 1] = data[i];\n            }\n            \n            data[index] = element;\n            size++;\n        }\n        \n        // 删除元素 - O(n)\n        public int remove(int index) {\n            if (index \u0026lt; 0 || index \u0026gt;= size) {\n                throw new IndexOutOfBoundsException();\n            }\n            \n            int removed = data[index];\n            \n            // 向前移动元素\n            for (int i = index; i \u0026lt; size - 1; i++) {\n                data[i] = data[i + 1];\n            }\n            \n            size--;\n            return removed;\n        }\n        \n        // 扩容 - O(n)\n        private void resize() {\n            capacity *= 2;\n            int[] newData = new int[capacity];\n            System.arraycopy(data, 0, newData, 0, size);\n            data = newData;\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e2. 链表（Linked List）\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e单链表实现\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class LinkedList {\n    \n    private class Node {\n        int data;\n        Node next;\n        \n        Node(int data) {\n            this.data = data;\n            this.next = null;\n        }\n    }\n    \n    private Node head;\n    private int size;\n    \n    // 头部插入 - O(1)\n    public void addFirst(int data) {\n        Node newNode = new Node(data);\n        newNode.next = head;\n        head = newNode;\n        size++;\n    }\n    \n    // 尾部插入 - O(n)\n    public void addLast(int data) {\n        Node newNode = new Node(data);\n        \n        if (head == null) {\n            head = newNode;\n        } else {\n            Node current = head;\n            while (current.next != null) {\n                current = current.next;\n            }\n            current.next = newNode;\n        }\n        size++;\n    }\n    \n    // 在指定位置插入 - O(n)\n    public void insert(int index, int data) {\n        if (index \u0026lt; 0 || index \u0026gt; size) {\n            throw new IndexOutOfBoundsException();\n        }\n        \n        if (index == 0) {\n            addFirst(data);\n        } else {\n            Node newNode = new Node(data);\n            Node prev = getNode(index - 1);\n            newNode.next = prev.next;\n            prev.next = newNode;\n            size++;\n        }\n    }\n    \n    // 删除节点 - O(n)\n    public int remove(int index) {\n        if (index \u0026lt; 0 || index \u0026gt;= size) {\n            throw new IndexOutOfBoundsException();\n        }\n        \n        if (index == 0) {\n            return removeFirst();\n        } else {\n            Node prev = getNode(index - 1);\n            Node removed = prev.next;\n            prev.next = removed.next;\n            size--;\n            return removed.data;\n        }\n    }\n    \n    // 反转链表 - O(n)\n    public void reverse() {\n        Node prev = null;\n        Node current = head;\n        Node next = null;\n        \n        while (current != null) {\n            next = current.next;\n            current.next = prev;\n            prev = current;\n            current = next;\n        }\n        \n        head = prev;\n    }\n    \n    // 检测环 - Floyd算法\n    public boolean hasCycle() {\n        Node slow = head;\n        Node fast = head;\n        \n        while (fast != null \u0026amp;\u0026amp; fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            \n            if (slow == fast) {\n                return true;\n            }\n        }\n        \n        return false;\n    }\n    \n    private Node getNode(int index) {\n        Node current = head;\n        for (int i = 0; i \u0026lt; index; i++) {\n            current = current.next;\n        }\n        return current;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e3. 栈和队列（Stack \u0026amp; Queue）\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e栈实现\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class Stack {\n    private int[] data;\n    private int top;\n    private int capacity;\n    \n    public Stack(int capacity) {\n        this.capacity = capacity;\n        this.data = new int[capacity];\n        this.top = -1;\n    }\n    \n    // 入栈 - O(1)\n    public void push(int element) {\n        if (isFull()) {\n            throw new StackOverflowError();\n        }\n        data[++top] = element;\n    }\n    \n    // 出栈 - O(1)\n    public int pop() {\n        if (isEmpty()) {\n            throw new EmptyStackException();\n        }\n        return data[top--];\n    }\n    \n    // 查看栈顶元素 - O(1)\n    public int peek() {\n        if (isEmpty()) {\n            throw new EmptyStackException();\n        }\n        return data[top];\n    }\n    \n    public boolean isEmpty() {\n        return top == -1;\n    }\n    \n    public boolean isFull() {\n        return top == capacity - 1;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e队列实现\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class Queue {\n    private int[] data;\n    private int front;\n    private int rear;\n    private int size;\n    private int capacity;\n    \n    public Queue(int capacity) {\n        this.capacity = capacity;\n        this.data = new int[capacity];\n        this.front = 0;\n        this.rear = -1;\n        this.size = 0;\n    }\n    \n    // 入队 - O(1)\n    public void enqueue(int element) {\n        if (isFull()) {\n            throw new IllegalStateException(\u0026quot;Queue is full\u0026quot;);\n        }\n        \n        rear = (rear + 1) % capacity;\n        data[rear] = element;\n        size++;\n    }\n    \n    // 出队 - O(1)\n    public int dequeue() {\n        if (isEmpty()) {\n            throw new IllegalStateException(\u0026quot;Queue is empty\u0026quot;);\n        }\n        \n        int element = data[front];\n        front = (front + 1) % capacity;\n        size--;\n        return element;\n    }\n    \n    // 查看队首元素 - O(1)\n    public int peek() {\n        if (isEmpty()) {\n            throw new IllegalStateException(\u0026quot;Queue is empty\u0026quot;);\n        }\n        return data[front];\n    }\n    \n    public boolean isEmpty() {\n        return size == 0;\n    }\n    \n    public boolean isFull() {\n        return size == capacity;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e4. 哈希表（Hash Table）\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e哈希表实现\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class HashMap\u0026lt;K, V\u0026gt; {\n    \n    private class Entry\u0026lt;K, V\u0026gt; {\n        K key;\n        V value;\n        Entry\u0026lt;K, V\u0026gt; next;\n        \n        Entry(K key, V value) {\n            this.key = key;\n            this.value = value;\n            this.next = null;\n        }\n    }\n    \n    private Entry\u0026lt;K, V\u0026gt;[] table;\n    private int size;\n    private int capacity;\n    \n    public HashMap(int capacity) {\n        this.capacity = capacity;\n        this.table = new Entry[capacity];\n        this.size = 0;\n    }\n    \n    // 哈希函数\n    private int hash(K key) {\n        return Math.abs(key.hashCode()) % capacity;\n    }\n    \n    // 插入键值对 - O(1)平均，O(n)最坏\n    public void put(K key, V value) {\n        int index = hash(key);\n        Entry\u0026lt;K, V\u0026gt; entry = table[index];\n        \n        // 检查是否已存在\n        while (entry != null) {\n            if (entry.key.equals(key)) {\n                entry.value = value;\n                return;\n            }\n            entry = entry.next;\n        }\n        \n        // 插入新节点\n        Entry\u0026lt;K, V\u0026gt; newEntry = new Entry\u0026lt;\u0026gt;(key, value);\n        newEntry.next = table[index];\n        table[index] = newEntry;\n        size++;\n        \n        // 检查是否需要扩容\n        if (size \u0026gt; capacity * 0.75) {\n            resize();\n        }\n    }\n    \n    // 获取值 - O(1)平均，O(n)最坏\n    public V get(K key) {\n        int index = hash(key);\n        Entry\u0026lt;K, V\u0026gt; entry = table[index];\n        \n        while (entry != null) {\n            if (entry.key.equals(key)) {\n                return entry.value;\n            }\n            entry = entry.next;\n        }\n        \n        return null;\n    }\n    \n    // 删除键值对 - O(1)平均，O(n)最坏\n    public V remove(K key) {\n        int index = hash(key);\n        Entry\u0026lt;K, V\u0026gt; entry = table[index];\n        Entry\u0026lt;K, V\u0026gt; prev = null;\n        \n        while (entry != null) {\n            if (entry.key.equals(key)) {\n                if (prev == null) {\n                    table[index] = entry.next;\n                } else {\n                    prev.next = entry.next;\n                }\n                size--;\n                return entry.value;\n            }\n            prev = entry;\n            entry = entry.next;\n        }\n        \n        return null;\n    }\n    \n    // 扩容 - O(n)\n    private void resize() {\n        capacity *= 2;\n        Entry\u0026lt;K, V\u0026gt;[] oldTable = table;\n        table = new Entry[capacity];\n        size = 0;\n        \n        for (Entry\u0026lt;K, V\u0026gt; entry : oldTable) {\n            while (entry != null) {\n                put(entry.key, entry.value);\n                entry = entry.next;\n            }\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e5. 二叉树（Binary Tree）\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e二叉搜索树实现\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class BinarySearchTree {\n    \n    private class Node {\n        int data;\n        Node left;\n        Node right;\n        \n        Node(int data) {\n            this.data = data;\n            this.left = null;\n            this.right = null;\n        }\n    }\n    \n    private Node root;\n    \n    // 插入节点 - O(h)，h为树的高度\n    public void insert(int data) {\n        root = insert(root, data);\n    }\n    \n    private Node insert(Node node, int data) {\n        if (node == null) {\n            return new Node(data);\n        }\n        \n        if (data \u0026lt; node.data) {\n            node.left = insert(node.left, data);\n        } else if (data \u0026gt; node.data) {\n            node.right = insert(node.right, data);\n        }\n        \n        return node;\n    }\n    \n    // 查找节点 - O(h)\n    public boolean search(int data) {\n        return search(root, data);\n    }\n    \n    private boolean search(Node node, int data) {\n        if (node == null) {\n            return false;\n        }\n        \n        if (data == node.data) {\n            return true;\n        } else if (data \u0026lt; node.data) {\n            return search(node.left, data);\n        } else {\n            return search(node.right, data);\n        }\n    }\n    \n    // 删除节点 - O(h)\n    public void delete(int data) {\n        root = delete(root, data);\n    }\n    \n    private Node delete(Node node, int data) {\n        if (node == null) {\n            return null;\n        }\n        \n        if (data \u0026lt; node.data) {\n            node.left = delete(node.left, data);\n        } else if (data \u0026gt; node.data) {\n            node.right = delete(node.right, data);\n        } else {\n            // 找到要删除的节点\n            \n            // 情况1：没有子节点\n            if (node.left == null \u0026amp;\u0026amp; node.right == null) {\n                return null;\n            }\n            \n            // 情况2：只有一个子节点\n            if (node.left == null) {\n                return node.right;\n            }\n            if (node.right == null) {\n                return node.left;\n            }\n            \n            // 情况3：有两个子节点\n            Node minNode = findMin(node.right);\n            node.data = minNode.data;\n            node.right = delete(node.right, minNode.data);\n        }\n        \n        return node;\n    }\n    \n    private Node findMin(Node node) {\n        while (node.left != null) {\n            node = node.left;\n        }\n        return node;\n    }\n    \n    // 中序遍历 - O(n)\n    public void inorderTraversal() {\n        inorderTraversal(root);\n        System.out.println();\n    }\n    \n    private void inorderTraversal(Node node) {\n        if (node != null) {\n            inorderTraversal(node.left);\n            System.out.print(node.data + \u0026quot; \u0026quot;);\n            inorderTraversal(node.right);\n        }\n    }\n    \n    // 前序遍历 - O(n)\n    public void preorderTraversal() {\n        preorderTraversal(root);\n        System.out.println();\n    }\n    \n    private void preorderTraversal(Node node) {\n        if (node != null) {\n            System.out.print(node.data + \u0026quot; \u0026quot;);\n            preorderTraversal(node.left);\n            preorderTraversal(node.right);\n        }\n    }\n    \n    // 后序遍历 - O(n)\n    public void postorderTraversal() {\n        postorderTraversal(root);\n        System.out.println();\n    }\n    \n    private void postorderTraversal(Node node) {\n        if (node != null) {\n            postorderTraversal(node.left);\n            postorderTraversal(node.right);\n            System.out.print(node.data + \u0026quot; \u0026quot;);\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e6. 堆（Heap）\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e最大堆实现\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class MaxHeap {\n    private int[] heap;\n    private int size;\n    private int capacity;\n    \n    public MaxHeap(int capacity) {\n        this.capacity = capacity;\n        this.heap = new int[capacity];\n        this.size = 0;\n    }\n    \n    // 获取父节点索引\n    private int parent(int i) {\n        return (i - 1) / 2;\n    }\n    \n    // 获取左子节点索引\n    private int left(int i) {\n        return 2 * i + 1;\n    }\n    \n    // 获取右子节点索引\n    private int right(int i) {\n        return 2 * i + 2;\n    }\n    \n    // 插入元素 - O(log n)\n    public void insert(int data) {\n        if (size \u0026gt;= capacity) {\n            throw new IllegalStateException(\u0026quot;Heap is full\u0026quot;);\n        }\n        \n        heap[size] = data;\n        int current = size;\n        \n        // 向上调整\n        while (current \u0026gt; 0 \u0026amp;\u0026amp; heap[current] \u0026gt; heap[parent(current)]) {\n            swap(current, parent(current));\n            current = parent(current);\n        }\n        \n        size++;\n    }\n    \n    // 删除最大元素 - O(log n)\n    public int extractMax() {\n        if (size \u0026lt;= 0) {\n            throw new IllegalStateException(\u0026quot;Heap is empty\u0026quot;);\n        }\n        \n        int max = heap[0];\n        heap[0] = heap[size - 1];\n        size--;\n        \n        // 向下调整\n        heapify(0);\n        \n        return max;\n    }\n    \n    // 堆化 - O(log n)\n    private void heapify(int i) {\n        int largest = i;\n        int left = left(i);\n        int right = right(i);\n        \n        if (left \u0026lt; size \u0026amp;\u0026amp; heap[left] \u0026gt; heap[largest]) {\n            largest = left;\n        }\n        \n        if (right \u0026lt; size \u0026amp;\u0026amp; heap[right] \u0026gt; heap[largest]) {\n            largest = right;\n        }\n        \n        if (largest != i) {\n            swap(i, largest);\n            heapify(largest);\n        }\n    }\n    \n    // 构建堆 - O(n)\n    public void buildHeap(int[] array) {\n        this.heap = array;\n        this.size = array.length;\n        this.capacity = array.length;\n        \n        // 从最后一个非叶子节点开始堆化\n        for (int i = size / 2 - 1; i \u0026gt;= 0; i--) {\n            heapify(i);\n        }\n    }\n    \n    // 堆排序 - O(n log n)\n    public void heapSort() {\n        // 构建最大堆\n        buildHeap(heap);\n        \n        // 逐个提取最大元素\n        for (int i = size - 1; i \u0026gt; 0; i--) {\n            swap(0, i);\n            size--;\n            heapify(0);\n        }\n    }\n    \n    private void swap(int i, int j) {\n        int temp = heap[i];\n        heap[i] = heap[j];\n        heap[j] = temp;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e核心算法\u003c/h2\u003e\n\u003ch3\u003e1. 排序算法\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e快速排序\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class QuickSort {\n    \n    // 快速排序 - O(n log n)平均，O(n²)最坏\n    public void sort(int[] arr) {\n        quickSort(arr, 0, arr.length - 1);\n    }\n    \n    private void quickSort(int[] arr, int low, int high) {\n        if (low \u0026lt; high) {\n            int pivotIndex = partition(arr, low, high);\n            quickSort(arr, low, pivotIndex - 1);\n            quickSort(arr, pivotIndex + 1, high);\n        }\n    }\n    \n    private int partition(int[] arr, int low, int high) {\n        int pivot = arr[high];\n        int i = low - 1;\n        \n        for (int j = low; j \u0026lt; high; j++) {\n            if (arr[j] \u0026lt;= pivot) {\n                i++;\n                swap(arr, i, j);\n            }\n        }\n        \n        swap(arr, i + 1, high);\n        return i + 1;\n    }\n    \n    private void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e归并排序\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class MergeSort {\n    \n    // 归并排序 - O(n log n)\n    public void sort(int[] arr) {\n        if (arr.length \u0026lt; 2) {\n            return;\n        }\n        \n        int[] temp = new int[arr.length];\n        mergeSort(arr, temp, 0, arr.length - 1);\n    }\n    \n    private void mergeSort(int[] arr, int[] temp, int left, int right) {\n        if (left \u0026lt; right) {\n            int mid = left + (right - left) / 2;\n            mergeSort(arr, temp, left, mid);\n            mergeSort(arr, temp, mid + 1, right);\n            merge(arr, temp, left, mid, right);\n        }\n    }\n    \n    private void merge(int[] arr, int[] temp, int left, int mid, int right) {\n        // 复制到临时数组\n        for (int i = left; i \u0026lt;= right; i++) {\n            temp[i] = arr[i];\n        }\n        \n        int i = left, j = mid + 1, k = left;\n        \n        // 合并两个有序数组\n        while (i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= right) {\n            if (temp[i] \u0026lt;= temp[j]) {\n                arr[k++] = temp[i++];\n            } else {\n                arr[k++] = temp[j++];\n            }\n        }\n        \n        // 复制剩余元素\n        while (i \u0026lt;= mid) {\n            arr[k++] = temp[i++];\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e2. 搜索算法\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e二分查找\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class BinarySearch {\n    \n    // 递归实现 - O(log n)\n    public int searchRecursive(int[] arr, int target) {\n        return searchRecursive(arr, target, 0, arr.length - 1);\n    }\n    \n    private int searchRecursive(int[] arr, int target, int left, int right) {\n        if (left \u0026gt; right) {\n            return -1;\n        }\n        \n        int mid = left + (right - left) / 2;\n        \n        if (arr[mid] == target) {\n            return mid;\n        } else if (arr[mid] \u0026lt; target) {\n            return searchRecursive(arr, target, mid + 1, right);\n        } else {\n            return searchRecursive(arr, target, left, mid - 1);\n        }\n    }\n    \n    // 迭代实现 - O(log n)\n    public int searchIterative(int[] arr, int target) {\n        int left = 0, right = arr.length - 1;\n        \n        while (left \u0026lt;= right) {\n            int mid = left + (right - left) / 2;\n            \n            if (arr[mid] == target) {\n                return mid;\n            } else if (arr[mid] \u0026lt; target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        \n        return -1;\n    }\n    \n    // 查找第一个等于target的元素\n    public int findFirst(int[] arr, int target) {\n        int left = 0, right = arr.length - 1;\n        int result = -1;\n        \n        while (left \u0026lt;= right) {\n            int mid = left + (right - left) / 2;\n            \n            if (arr[mid] == target) {\n                result = mid;\n                right = mid - 1; // 继续向左查找\n            } else if (arr[mid] \u0026lt; target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        \n        return result;\n    }\n    \n    // 查找最后一个等于target的元素\n    public int findLast(int[] arr, int target) {\n        int left = 0, right = arr.length - 1;\n        int result = -1;\n        \n        while (left \u0026lt;= right) {\n            int mid = left + (right - left) / 2;\n            \n            if (arr[mid] == target) {\n                result = mid;\n                left = mid + 1; // 继续向右查找\n            } else if (arr[mid] \u0026lt; target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        \n        return result;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e3. 动态规划\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e斐波那契数列\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class Fibonacci {\n    \n    // 递归实现 - O(2^n)\n    public int fibonacciRecursive(int n) {\n        if (n \u0026lt;= 1) {\n            return n;\n        }\n        return fibonacciRecursive(n - 1) + fibonacciRecursive(n - 2);\n    }\n    \n    // 记忆化递归 - O(n)\n    public int fibonacciMemoization(int n) {\n        int[] memo = new int[n + 1];\n        return fibonacciMemoization(n, memo);\n    }\n    \n    private int fibonacciMemoization(int n, int[] memo) {\n        if (n \u0026lt;= 1) {\n            return n;\n        }\n        \n        if (memo[n] != 0) {\n            return memo[n];\n        }\n        \n        memo[n] = fibonacciMemoization(n - 1, memo) + \n                 fibonacciMemoization(n - 2, memo);\n        return memo[n];\n    }\n    \n    // 动态规划 - O(n)\n    public int fibonacciDP(int n) {\n        if (n \u0026lt;= 1) {\n            return n;\n        }\n        \n        int[] dp = new int[n + 1];\n        dp[0] = 0;\n        dp[1] = 1;\n        \n        for (int i = 2; i \u0026lt;= n; i++) {\n            dp[i] = dp[i - 1] + dp[i - 2];\n        }\n        \n        return dp[n];\n    }\n    \n    // 空间优化 - O(n)\n    public int fibonacciOptimized(int n) {\n        if (n \u0026lt;= 1) {\n            return n;\n        }\n        \n        int prev = 0, curr = 1;\n        \n        for (int i = 2; i \u0026lt;= n; i++) {\n            int next = prev + curr;\n            prev = curr;\n            curr = next;\n        }\n        \n        return curr;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e最长公共子序列\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class LongestCommonSubsequence {\n    \n    // 动态规划实现 - O(m*n)\n    public int lcs(String text1, String text2) {\n        int m = text1.length();\n        int n = text2.length();\n        \n        int[][] dp = new int[m + 1][n + 1];\n        \n        for (int i = 1; i \u0026lt;= m; i++) {\n            for (int j = 1; j \u0026lt;= n; j++) {\n                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                } else {\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n        \n        return dp[m][n];\n    }\n    \n    // 空间优化 - O(min(m,n))\n    public int lcsOptimized(String text1, String text2) {\n        if (text1.length() \u0026lt; text2.length()) {\n            return lcsOptimized(text2, text1);\n        }\n        \n        int m = text1.length();\n        int n = text2.length();\n        \n        int[] dp = new int[n + 1];\n        \n        for (int i = 1; i \u0026lt;= m; i++) {\n            int prev = 0;\n            for (int j = 1; j \u0026lt;= n; j++) {\n                int temp = dp[j];\n                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {\n                    dp[j] = prev + 1;\n                } else {\n                    dp[j] = Math.max(dp[j], dp[j - 1]);\n                }\n                prev = temp;\n            }\n        }\n        \n        return dp[n];\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e4. 贪心算法\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e活动选择问题\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class ActivitySelection {\n    \n    static class Activity {\n        int start;\n        int end;\n        \n        Activity(int start, int end) {\n            this.start = start;\n            this.end = end;\n        }\n    }\n    \n    // 贪心算法实现 - O(n log n)\n    public List\u0026lt;Integer\u0026gt; activitySelection(Activity[] activities) {\n        // 按结束时间排序\n        Arrays.sort(activities, (a, b) -\u0026gt; a.end - b.end);\n        \n        List\u0026lt;Integer\u0026gt; selected = new ArrayList\u0026lt;\u0026gt;();\n        selected.add(0); // 选择第一个活动\n        \n        int lastEnd = activities[0].end;\n        \n        for (int i = 1; i \u0026lt; activities.length; i++) {\n            if (activities[i].start \u0026gt;= lastEnd) {\n                selected.add(i);\n                lastEnd = activities[i].end;\n            }\n        }\n        \n        return selected;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e霍夫曼编码\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class HuffmanCoding {\n    \n    static class HuffmanNode implements Comparable\u0026lt;HuffmanNode\u0026gt; {\n        char data;\n        int frequency;\n        HuffmanNode left, right;\n        \n        HuffmanNode(char data, int frequency) {\n            this.data = data;\n            this.frequency = frequency;\n        }\n        \n        @Override\n        public int compareTo(HuffmanNode other) {\n            return this.frequency - other.frequency;\n        }\n    }\n    \n    // 构建霍夫曼树 - O(n log n)\n    public HuffmanNode buildHuffmanTree(Map\u0026lt;Character, Integer\u0026gt; frequencyMap) {\n        PriorityQueue\u0026lt;HuffmanNode\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;();\n        \n        // 创建叶子节点\n        for (Map.Entry\u0026lt;Character, Integer\u0026gt; entry : frequencyMap.entrySet()) {\n            pq.add(new HuffmanNode(entry.getKey(), entry.getValue()));\n        }\n        \n        // 构建霍夫曼树\n        while (pq.size() \u0026gt; 1) {\n            HuffmanNode left = pq.poll();\n            HuffmanNode right = pq.poll();\n            \n            HuffmanNode parent = new HuffmanNode(\u0026#39;\\0\u0026#39;, \n                left.frequency + right.frequency);\n            parent.left = left;\n            parent.right = right;\n            \n            pq.add(parent);\n        }\n        \n        return pq.poll();\n    }\n    \n    // 生成霍夫曼编码 - O(n)\n    public Map\u0026lt;Character, String\u0026gt; generateHuffmanCodes(HuffmanNode root) {\n        Map\u0026lt;Character, String\u0026gt; codes = new HashMap\u0026lt;\u0026gt;();\n        generateHuffmanCodes(root, \u0026quot;\u0026quot;, codes);\n        return codes;\n    }\n    \n    private void generateHuffmanCodes(HuffmanNode node, String code, \n                                    Map\u0026lt;Character, String\u0026gt; codes) {\n        if (node == null) {\n            return;\n        }\n        \n        if (node.data != \u0026#39;\\0\u0026#39;) {\n            codes.put(node.data, code);\n            return;\n        }\n        \n        generateHuffmanCodes(node.left, code + \u0026quot;0\u0026quot;, codes);\n        generateHuffmanCodes(node.right, code + \u0026quot;1\u0026quot;, codes);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e总结\u003c/h2\u003e\n\u003cp\u003e掌握算法和数据结构需要：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e理论基础\u003c/strong\u003e：理解各种算法的原理和复杂度\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e实践练习\u003c/strong\u003e：通过编码实现加深理解\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e应用场景\u003c/strong\u003e：了解不同算法的适用场景\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e优化技巧\u003c/strong\u003e：学会优化算法的时间和空间复杂度\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e持续学习\u003c/strong\u003e：关注算法领域的新发展和最佳实践\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e通过系统学习和大量练习，可以逐步提升算法能力，在面试和实际工作中都能游刃有余。\u003c/p\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"children\":[[\"$\",\"$Ld\",null,{\"href\":\"/notes\",\"className\":\"back-button\",\"style\":{\"display\":\"inline-block\",\"background\":\"var(--primary-color)\",\"color\":\"white\",\"border\":\"none\",\"padding\":\"10px 20px\",\"borderRadius\":\"6px\",\"cursor\":\"pointer\",\"marginBottom\":\"20px\",\"textDecoration\":\"none\"},\"children\":[\"← 返回\",\"笔记\",\"列表\"]}],[\"$\",\"article\",null,{\"className\":\"section\",\"children\":[[\"$\",\"header\",null,{\"className\":\"article-header\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"article-title\",\"children\":\"热门算法数据结构详解\"}],[\"$\",\"div\",null,{\"className\":\"article-meta\",\"children\":[[\"$\",\"div\",null,{\"className\":\"article-meta-info\",\"children\":[[\"$\",\"span\",null,{\"className\":\"article-date\",\"children\":\"2024-10-14\"}],[\"$\",\"span\",null,{\"className\":\"article-category\",\"children\":[\"• \",\"笔记\"]}]]}],[\"$\",\"div\",null,{\"className\":\"article-tags\",\"children\":[[\"$\",\"span\",\"算法\",{\"className\":\"tag\",\"children\":\"算法\"}],[\"$\",\"span\",\"数据结构\",{\"className\":\"tag\",\"children\":\"数据结构\"}],[\"$\",\"span\",\"时间复杂度\",{\"className\":\"tag\",\"children\":\"时间复杂度\"}],[\"$\",\"span\",\"空间复杂度\",{\"className\":\"tag\",\"children\":\"空间复杂度\"}],[\"$\",\"span\",\"面试\",{\"className\":\"tag\",\"children\":\"面试\"}]]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"card markdown-content\",\"dangerouslySetInnerHTML\":{\"__html\":\"$e\"}}]]}]]}]\n"])</script><script>self.__next_f.push([1,"9:[\"$\",\"html\",null,{\"lang\":\"zh-CN\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"link\",null,{\"rel\":\"stylesheet\",\"href\":\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css\"}],[\"$\",\"link\",null,{\"rel\":\"stylesheet\",\"href\":\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css\"}]]}],[\"$\",\"body\",null,{\"children\":[\"$\",\"div\",null,{\"className\":\"app\",\"children\":[[\"$\",\"$Lf\",null,{\"siteConfig\":{\"name\":\"Rudy Yang\",\"bio\":\"JAVA | AI | WEB3\",\"social\":[{\"name\":\"github\",\"icon\":\"fab fa-github\",\"url\":\"https://github.com/suogongy\"},{\"name\":\"twitter\",\"icon\":\"fab fa-twitter\",\"url\":\"https://twitter.com/suogongy\"},{\"name\":\"email\",\"icon\":\"fas fa-envelope\",\"url\":\"mailto:haiyuan1832@163.com\"}]}}],[\"$\",\"main\",null,{\"className\":\"main-content\",\"children\":[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"热门算法数据结构详解 - Personal GitHub Page\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"深入解析程序员必须掌握的核心算法和数据结构，包括时间复杂度、空间复杂度分析，以及实际应用场景。\"}]]\n3:null\n"])</script></body></html>