<!DOCTYPE html><html lang="zh-CN"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/55b7a9e84b417e65.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-c81f7fd28659d64f.js"/><script src="/_next/static/chunks/fd9d1056-9f91b5e418130764.js" async=""></script><script src="/_next/static/chunks/117-ee7b0ec54963e50f.js" async=""></script><script src="/_next/static/chunks/main-app-c180f1b9030bf4f6.js" async=""></script><script src="/_next/static/chunks/972-17ea62b17795b286.js" async=""></script><script src="/_next/static/chunks/app/%5Bcategory%5D/%5Bslug%5D/page-234087874853c0eb.js" async=""></script><script src="/_next/static/chunks/app/layout-8486db2c9a537bdb.js" async=""></script><title>Java项目线上问题排查 - Personal GitHub Page</title><meta name="description" content="详细介绍Java项目在线上环境中常见的问题排查方法、诊断工具和解决方案，包括CPU、内存、线程、网络等方面的故障排查。"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css"/><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body><div class="app"><header class="header "><nav class="nav-container"><a class="nav-brand" href="/"><i class="fas fa-terminal"></i>Rudy Yang</a><ul class="nav-menu"><li><a class="nav-link " href="/"><i class="fas fa-home"></i> 首页</a></li><li><a class="nav-link " href="/about/"><i class="fas fa-user"></i> 关于</a></li><li><a class="nav-link " href="/projects/"><i class="fas fa-code"></i> 项目</a></li><li><a class="nav-link " href="/notes/"><i class="fas fa-book"></i> 笔记</a></li><li><a class="nav-link " href="/articles/"><i class="fas fa-pen"></i> 随笔</a></li></ul></nav></header><main class="main-content"><div><a class="back-button" style="display:inline-block;background:var(--primary-color);color:white;border:none;padding:10px 20px;border-radius:6px;cursor:pointer;margin-bottom:20px;text-decoration:none" href="/notes/">← 返回<!-- -->笔记<!-- -->列表</a><article class="section"><header class="article-header"><h1 class="article-title">Java项目线上问题排查</h1><div class="article-meta"><div class="article-meta-info"><span class="article-date">2024-10-14</span><span class="article-category">• <!-- -->笔记</span></div><div class="article-tags"><span class="tag">Java</span><span class="tag">线上排查</span><span class="tag">性能调优</span><span class="tag">故障诊断</span><span class="tag">JVM</span></div></div></header><div class="card markdown-content"><h1>Java项目线上问题排查</h1>
<blockquote>
<p>线上问题排查是Java开发者的必备技能，掌握正确的排查方法和工具是关键</p>
</blockquote>
<h2>问题分类与排查思路</h2>
<h3>1. 常见问题类型</h3>
<pre><code>Java线上问题分类：
├── CPU问题
│   ├── CPU使用率过高
│   ├── CPU负载过高
│   └── 上下文切换频繁
├── 内存问题
│   ├── 内存溢出（OOM）
│   ├── 内存泄漏
│   └── GC频繁
├── 线程问题
│   ├── 死锁
│   ├── 线程阻塞
│   └── 线程数过多
├── 网络问题
│   ├── 连接超时
│   ├── 连接池耗尽
│   └── 网络延迟
└── 应用问题
    ├── 响应缓慢
    ├── 错误率升高
    └── 间歇性故障
</code></pre>
<h3>2. 排查方法论</h3>
<p><strong>问题排查流程</strong></p>
<pre><code>1. 问题现象确认
   ├── 确定问题影响范围
   ├── 收集关键指标
   └── 复现问题现象

2. 初步诊断
   ├── 查看系统资源
   ├── 分析应用日志
   └── 检查监控指标

3. 深入分析
   ├── 使用专业工具
   ├── 分析堆栈信息
   └── 定位根本原因

4. 解决方案
   ├── 制定修复方案
   ├── 实施变更
   └── 验证效果
</code></pre>
<h2>CPU问题排查</h2>
<h3>1. CPU使用率过高</h3>
<p><strong>排查步骤</strong></p>
<pre><code class="language-bash"># 1. 查看CPU使用率
top -p &lt;pid&gt;

# 2. 查看线程CPU使用情况
top -H -p &lt;pid&gt;

# 3. 导出线程栈
jstack &lt;pid&gt; &gt; thread_dump.txt

# 4. 将线程ID转换为16进制
printf &quot;%x\n&quot; &lt;thread_id&gt;

# 5. 在线程栈中查找对应线程
grep -A 20 &lt;hex_thread_id&gt; thread_dump.txt
</code></pre>
<p><strong>自动化排查脚本</strong></p>
<pre><code class="language-bash">#!/bin/bash
# cpu_troubleshoot.sh

PID=$1
if [ -z &quot;$PID&quot; ]; then
    echo &quot;Usage: $0 &lt;pid&gt;&quot;
    exit 1
fi

echo &quot;=== CPU使用情况 ===&quot;
top -p $PID -n 1 | head -20

echo &quot;=== 高CPU线程 ===&quot;
top -H -p $PID -n 1 | head -20

echo &quot;=== 生成线程栈 ===&quot;
jstack $PID &gt; thread_dump_$(date +%Y%m%d_%H%M%S).txt

echo &quot;=== 获取GC信息 ===&quot;
jstat -gc $PID 1s 10

echo &quot;=== 查看堆内存使用 ===&quot;
jmap -histo $PID | head -20
</code></pre>
<h3>2. Java代码中的CPU问题</h3>
<p><strong>死循环检测</strong></p>
<pre><code class="language-java">// 死循环示例
public class DeadLoop {
    public void process() {
        while (true) {
            // 没有退出条件的循环
            try {
                Thread.sleep(1);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
    }
}

// 频繁Full GC
public class FrequentGC {
    public void process() {
        List&lt;byte[]&gt; list = new ArrayList&lt;&gt;();
        while (true) {
            list.add(new byte[1024 * 1024]); // 1MB
        }
    }
}
</code></pre>
<p><strong>CPU密集型操作优化</strong></p>
<pre><code class="language-java">// 优化前
public List&lt;Integer&gt; calculatePrimes(int limit) {
    List&lt;Integer&gt; primes = new ArrayList&lt;&gt;();
    for (int i = 2; i &lt;= limit; i++) {
        if (isPrime(i)) {
            primes.add(i);
        }
    }
    return primes;
}

// 优化后：使用并行流
public List&lt;Integer&gt; calculatePrimes(int limit) {
    return IntStream.rangeClosed(2, limit)
        .parallel()
        .filter(this::isPrime)
        .boxed()
        .collect(Collectors.toList());
}
</code></pre>
<h2>内存问题排查</h2>
<h3>1. 内存溢出（OOM）</h3>
<p><strong>堆内存溢出</strong></p>
<pre><code class="language-bash"># 1. 查看内存使用
jstat -gc &lt;pid&gt; 1s 5

# 2. 生成堆转储文件
jmap -dump:format=b,file=heap.hprof &lt;pid&gt;

# 3. 分析堆转储文件
jhat heap.hprof

# 4. 使用MAT分析
# 启动MAT工具，导入heap.hprof文件
</code></pre>
<p><strong>OOM分析脚本</strong></p>
<pre><code class="language-bash">#!/bin/bash
# oom_analysis.sh

PID=$1
DUMP_FILE=&quot;heap_$(date +%Y%m%d_%H%M%S).hprof&quot;

echo &quot;=== 生成堆转储文件 ===&quot;
jmap -dump:format=b,file=$DUMP_FILE $PID

echo &quot;=== 堆转储文件大小 ===&quot;
ls -lh $DUMP_FILE

echo &quot;=== 使用MAT分析 ===&quot;
echo &quot;请使用MAT工具打开 $DUMP_FILE 进行分析&quot;

# 自动分析脚本
cat &gt; oom_analysis.py &lt;&lt; &#39;EOF&#39;
import sys
import re

def analyze_heap_dump(file_path):
    # 这里可以添加自动分析逻辑
    print(f&quot;分析堆转储文件: {file_path}&quot;)
    
if __name__ == &quot;__main__&quot;:
    if len(sys.argv) != 2:
        print(&quot;Usage: python oom_analysis.py &lt;heap_dump_file&gt;&quot;)
        sys.exit(1)
    
    analyze_heap_dump(sys.argv[1])
EOF

python oom_analysis.py $DUMP_FILE
</code></pre>
<h3>2. 内存泄漏检测</h3>
<p><strong>内存泄漏常见场景</strong></p>
<pre><code class="language-java">// 静态集合持有对象引用
public class MemoryLeak {
    private static final List&lt;Object&gt; cache = new ArrayList&lt;&gt;();
    
    public void addToCache(Object obj) {
        cache.add(obj); // 永远不会被清理
    }
}

// 未关闭的资源
public class ResourceLeak {
    public void processData() {
        try {
            Connection conn = getConnection();
            Statement stmt = conn.createStatement();
            ResultSet rs = stmt.executeQuery(&quot;SELECT * FROM large_table&quot;);
            // 没有关闭连接、Statement和ResultSet
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}

// 监听器未移除
public class ListenerLeak {
    private List&lt;EventListener&gt; listeners = new ArrayList&lt;&gt;();
    
    public void addListener(EventListener listener) {
        listeners.add(listener);
    }
    
    // 缺少removeListener方法
}
</code></pre>
<p><strong>内存泄漏检测工具</strong></p>
<pre><code class="language-java">// 使用WeakReference检测内存泄漏
public class MemoryLeakDetector {
    private static final Map&lt;String, WeakReference&lt;Object&gt;&gt; weakRefs = 
        new ConcurrentHashMap&lt;&gt;();
    
    public static void track(String key, Object obj) {
        weakRefs.put(key, new WeakReference&lt;&gt;(obj));
    }
    
    public static void checkLeaks() {
        for (Map.Entry&lt;String, WeakReference&lt;Object&gt;&gt; entry : weakRefs.entrySet()) {
            WeakReference&lt;Object&gt; ref = entry.getValue();
            if (ref.get() == null) {
                System.out.println(&quot;对象已被回收: &quot; + entry.getKey());
            } else {
                System.out.println(&quot;可能的内存泄漏: &quot; + entry.getKey());
            }
        }
    }
}
</code></pre>
<h2>线程问题排查</h2>
<h3>1. 死锁检测</h3>
<p><strong>死锁检测脚本</strong></p>
<pre><code class="language-bash">#!/bin/bash
# deadlock_detector.sh

PID=$1

echo &quot;=== 检测死锁 ===&quot;
jstack $PID | grep -A 20 &quot;Found one Java-level deadlock&quot;

echo &quot;=== 线程状态统计 ===&quot;
jstack $PID | grep -E &quot;java.lang.Thread.State:&quot; | sort | uniq -c

echo &quot;=== 阻塞线程 ===&quot;
jstack $PID | grep -A 5 &quot;BLOCKED&quot;
</code></pre>
<p><strong>死锁示例和分析</strong></p>
<pre><code class="language-java">// 死锁示例
public class DeadlockExample {
    private static final Object lock1 = new Object();
    private static final Object lock2 = new Object();
    
    public static void main(String[] args) {
        Thread thread1 = new Thread(() -&gt; {
            synchronized (lock1) {
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (lock2) {
                    System.out.println(&quot;Thread 1 acquired both locks&quot;);
                }
            }
        });
        
        Thread thread2 = new Thread(() -&gt; {
            synchronized (lock2) {
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (lock1) {
                    System.out.println(&quot;Thread 2 acquired both locks&quot;);
                }
            }
        });
        
        thread1.start();
        thread2.start();
    }
}
</code></pre>
<h3>2. 线程池问题</h3>
<p><strong>线程池监控</strong></p>
<pre><code class="language-java">@Component
public class ThreadPoolMonitor {
    
    @Autowired
    private ThreadPoolExecutor executor;
    
    @Scheduled(fixedRate = 5000)
    public void monitorThreadPool() {
        System.out.println(&quot;=== 线程池状态 ===&quot;);
        System.out.println(&quot;核心线程数: &quot; + executor.getCorePoolSize());
        System.out.println(&quot;最大线程数: &quot; + executor.getMaximumPoolSize());
        System.out.println(&quot;当前线程数: &quot; + executor.getActiveCount());
        System.out.println(&quot;队列大小: &quot; + executor.getQueue().size());
        System.out.println(&quot;完成任务数: &quot; + executor.getCompletedTaskCount());
        
        // 告警逻辑
        if (executor.getActiveCount() &gt; executor.getMaximumPoolSize() * 0.8) {
            System.out.println(&quot;警告: 线程池使用率过高&quot;);
        }
    }
}
</code></pre>
<h2>网络问题排查</h2>
<h3>1. 连接超时问题</h3>
<p><strong>网络连接监控</strong></p>
<pre><code class="language-java">@Component
public class NetworkMonitor {
    
    private final RestTemplate restTemplate;
    
    public NetworkMonitor() {
        this.restTemplate = new RestTemplate();
        
        // 配置连接超时
        HttpComponentsClientHttpRequestFactory factory = 
            new HttpComponentsClientHttpRequestFactory();
        factory.setConnectTimeout(5000);
        factory.setReadTimeout(10000);
        this.restTemplate.setRequestFactory(factory);
    }
    
    @Scheduled(fixedRate = 30000)
    public void checkConnectivity() {
        try {
            ResponseEntity&lt;String&gt; response = restTemplate.getForEntity(
                &quot;http://example.com/health&quot;, String.class);
            if (response.getStatusCode().is2xxSuccessful()) {
                System.out.println(&quot;网络连接正常&quot;);
            }
        } catch (Exception e) {
            System.err.println(&quot;网络连接异常: &quot; + e.getMessage());
        }
    }
}
</code></pre>
<h3>2. 连接池问题</h3>
<p><strong>数据库连接池监控</strong></p>
<pre><code class="language-java">@Component
public class ConnectionPoolMonitor {
    
    @Autowired
    private DataSource dataSource;
    
    @Scheduled(fixedRate = 10000)
    public void monitorConnectionPool() {
        if (dataSource instanceof HikariDataSource) {
            HikariDataSource hikariDataSource = (HikariDataSource) dataSource;
            HikariPoolMXBean poolProxy = hikariDataSource.getHikariPoolMXBean();
            
            System.out.println(&quot;=== 连接池状态 ===&quot;);
            System.out.println(&quot;活跃连接数: &quot; + poolProxy.getActiveConnections());
            System.out.println(&quot;空闲连接数: &quot; + poolProxy.getIdleConnections());
            System.out.println(&quot;总连接数: &quot; + poolProxy.getTotalConnections());
            System.out.println(&quot;等待线程数: &quot; + poolProxy.getThreadsAwaitingConnection());
            
            // 告警逻辑
            if (poolProxy.getActiveConnections() &gt; poolProxy.getTotalConnections() * 0.8) {
                System.err.println(&quot;警告: 连接池使用率过高&quot;);
            }
        }
    }
}
</code></pre>
<h2>日志分析</h2>
<h3>1. 日志配置优化</h3>
<p><strong>Logback配置</strong></p>
<pre><code class="language-xml">&lt;!-- logback.xml --&gt;
&lt;configuration&gt;
    &lt;appender name=&quot;CONSOLE&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;
        &lt;encoder&gt;
            &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;
    
    &lt;appender name=&quot;FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;
        &lt;file&gt;logs/application.log&lt;/file&gt;
        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;
            &lt;fileNamePattern&gt;logs/application.%d{yyyy-MM-dd}.%i.log&lt;/fileNamePattern&gt;
            &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt;
            &lt;maxHistory&gt;30&lt;/maxHistory&gt;
            &lt;totalSizeCap&gt;3GB&lt;/totalSizeCap&gt;
        &lt;/rollingPolicy&gt;
        &lt;encoder&gt;
            &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;
    
    &lt;!-- 异步日志 --&gt;
    &lt;appender name=&quot;ASYNC_FILE&quot; class=&quot;ch.qos.logback.classic.AsyncAppender&quot;&gt;
        &lt;discardingThreshold&gt;0&lt;/discardingThreshold&gt;
        &lt;queueSize&gt;1024&lt;/queueSize&gt;
        &lt;appender-ref ref=&quot;FILE&quot;/&gt;
    &lt;/appender&gt;
    
    &lt;root level=&quot;INFO&quot;&gt;
        &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;
        &lt;appender-ref ref=&quot;ASYNC_FILE&quot;/&gt;
    &lt;/root&gt;
&lt;/configuration&gt;
</code></pre>
<h3>2. 日志分析脚本</h3>
<p><strong>错误日志分析</strong></p>
<pre><code class="language-bash">#!/bin/bash
# log_analyzer.sh

LOG_FILE=$1
if [ -z &quot;$LOG_FILE&quot; ]; then
    echo &quot;Usage: $0 &lt;log_file&gt;&quot;
    exit 1
fi

echo &quot;=== 错误统计 ===&quot;
grep -E &quot;ERROR|Exception&quot; $LOG_FILE | awk &#39;{print $1, $2}&#39; | sort | uniq -c | sort -nr

echo &quot;=== 最近错误 ===&quot;
tail -100 $LOG_FILE | grep -E &quot;ERROR|Exception&quot; | tail -10

echo &quot;=== HTTP 5xx错误 ===&quot;
grep -E &quot;HTTP/1\.[01]\&quot; [5][0-9][0-9]&quot; $LOG_FILE | awk &#39;{print $7}&#39; | sort | uniq -c | sort -nr

echo &quot;=== 慢查询日志 ===&quot;
grep -E &quot;took.*ms&quot; $LOG_FILE | awk &#39;$NF &gt; 1000 {print $0}&#39;
</code></pre>
<h2>性能监控工具</h2>
<h3>1. JVM监控</h3>
<p><strong>JMX监控</strong></p>
<pre><code class="language-java">@Component
public class JVMMonitor {
    
    private final MemoryMXBean memoryMXBean;
    private final ThreadMXBean threadMXBean;
    private final RuntimeMXBean runtimeMXBean;
    
    public JVMMonitor() {
        MBeanServer mBeanServer = ManagementFactory.getPlatformMBeanServer();
        this.memoryMXBean = ManagementFactory.newPlatformMXBeanProxy(
            mBeanServer, ManagementFactory.MEMORY_MXBEAN_NAME, MemoryMXBean.class);
        this.threadMXBean = ManagementFactory.newPlatformMXBeanProxy(
            mBeanServer, ManagementFactory.THREAD_MXBEAN_NAME, ThreadMXBean.class);
        this.runtimeMXBean = ManagementFactory.newPlatformMXBeanProxy(
            mBeanServer, ManagementFactory.RUNTIME_MXBEAN_NAME, RuntimeMXBean.class);
    }
    
    @Scheduled(fixedRate = 10000)
    public void monitorJVM() {
        // 内存监控
        MemoryUsage heapUsage = memoryMXBean.getHeapMemoryUsage();
        double heapUsagePercent = (double) heapUsage.getUsed() / heapUsage.getMax() * 100;
        
        // 线程监控
        int threadCount = threadMXBean.getThreadCount();
        
        // GC监控
        List&lt;GarbageCollectorMXBean&gt; gcBeans = ManagementFactory.getGarbageCollectorMXBeans();
        
        System.out.println(&quot;=== JVM监控 ===&quot;);
        System.out.println(&quot;堆内存使用率: &quot; + String.format(&quot;%.2f%%&quot;, heapUsagePercent));
        System.out.println(&quot;线程数: &quot; + threadCount);
        
        // 告警逻辑
        if (heapUsagePercent &gt; 80) {
            System.err.println(&quot;警告: 堆内存使用率过高&quot;);
        }
    }
}
</code></pre>
<h3>2. 应用性能监控（APM）</h3>
<p><strong>自定义性能监控</strong></p>
<pre><code class="language-java">@Component
public class PerformanceMonitor {
    
    private final MeterRegistry meterRegistry;
    
    public PerformanceMonitor(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
    }
    
    public void recordApiCall(String apiName, long duration, String status) {
        Timer.Sample sample = Timer.start(meterRegistry);
        sample.stop(Timer.builder(&quot;api.call.time&quot;)
            .tag(&quot;api&quot;, apiName)
            .tag(&quot;status&quot;, status)
            .register(meterRegistry));
        
        Counter.builder(&quot;api.call.count&quot;)
            .tag(&quot;api&quot;, apiName)
            .tag(&quot;status&quot;, status)
            .register(meterRegistry)
            .increment();
    }
    
    @Aspect
    @Component
    public class ApiMonitorAspect {
        
        @Around(&quot;@annotation(Monitored)&quot;)
        public Object monitorApi(ProceedingJoinPoint joinPoint) throws Throwable {
            long startTime = System.currentTimeMillis();
            String apiName = joinPoint.getSignature().getName();
            
            try {
                Object result = joinPoint.proceed();
                long duration = System.currentTimeMillis() - startTime;
                
                performanceMonitor.recordApiCall(apiName, duration, &quot;SUCCESS&quot;);
                return result;
            } catch (Exception e) {
                long duration = System.currentTimeMillis() - startTime;
                
                performanceMonitor.recordApiCall(apiName, duration, &quot;ERROR&quot;);
                throw e;
            }
        }
    }
}
</code></pre>
<h2>应急处理流程</h2>
<h3>1. 故障响应流程</h3>
<pre><code>故障响应流程：
1. 故障发现
   ├── 监控系统告警
   ├── 用户反馈
   └── 主动巡检

2. 故障确认
   ├── 确认影响范围
   ├── 评估严重程度
   └── 启动应急响应

3. 快速止损
   ├── 服务降级
   ├── 流量限制
   └── 紧急回滚

4. 问题定位
   ├── 收集日志
   ├── 分析监控数据
   └── 复现问题

5. 修复验证
   ├── 实施修复
   ├── 验证效果
   └── 恢复服务

6. 复盘总结
   ├── 分析根因
   ├── 制定改进措施
   └── 更新应急预案
</code></pre>
<h3>2. 应急脚本</h3>
<p><strong>服务快速重启脚本</strong></p>
<pre><code class="language-bash">#!/bin/bash
# emergency_restart.sh

SERVICE_NAME=$1
if [ -z &quot;$SERVICE_NAME&quot; ]; then
    echo &quot;Usage: $0 &lt;service_name&gt;&quot;
    exit 1
fi

echo &quot;=== 紧急重启服务: $SERVICE_NAME ===&quot;

# 1. 备份当前状态
echo &quot;备份服务状态...&quot;
systemctl status $SERVICE_NAME &gt; service_status_$(date +%Y%m%d_%H%M%S).txt

# 2. 停止服务
echo &quot;停止服务...&quot;
systemctl stop $SERVICE_NAME

# 3. 等待服务完全停止
sleep 5

# 4. 检查端口是否释放
PORT=$(netstat -tlnp | grep $SERVICE_NAME | awk &#39;{print $4}&#39; | cut -d: -f2)
if [ -n &quot;$PORT&quot; ]; then
    echo &quot;端口 $PORT 仍被占用，强制终止进程...&quot;
    pkill -f $SERVICE_NAME
fi

# 5. 启动服务
echo &quot;启动服务...&quot;
systemctl start $SERVICE_NAME

# 6. 检查服务状态
echo &quot;检查服务状态...&quot;
systemctl status $SERVICE_NAME

# 7. 验证服务可用性
echo &quot;验证服务可用性...&quot;
sleep 10
curl -f http://localhost:8080/health || echo &quot;服务健康检查失败&quot;

echo &quot;=== 重启完成 ===&quot;
</code></pre>
<h2>总结</h2>
<p>Java线上问题排查是一个系统性工程，需要掌握以下关键技能：</p>
<ol>
<li><strong>工具使用</strong>：熟练使用jstat、jstack、jmap、MAT等工具</li>
<li><strong>问题分类</strong>：能够快速识别问题类型和影响范围</li>
<li><strong>分析方法</strong>：掌握科学的分析方法和思路</li>
<li><strong>经验积累</strong>：通过实际案例积累经验</li>
<li><strong>预防措施</strong>：建立完善的监控和预防机制</li>
</ol>
<p>通过系统化的排查方法和工具使用，可以快速定位和解决线上问题，保障系统的稳定运行。</p>
</div></article></div></main></div><script src="/_next/static/chunks/webpack-c81f7fd28659d64f.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/55b7a9e84b417e65.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"2:I[2846,[],\"\"]\n5:I[4707,[],\"\"]\n8:I[6423,[],\"\"]\nb:I[1060,[],\"\"]\n6:[\"category\",\"notes\",\"d\"]\n7:[\"slug\",\"java-production-troubleshooting\",\"d\"]\nc:[]\n0:[\"$\",\"$L2\",null,{\"buildId\":\"build\",\"assetPrefix\":\"\",\"urlParts\":[\"\",\"notes\",\"java-production-troubleshooting\",\"\"],\"initialTree\":[\"\",{\"children\":[[\"category\",\"notes\",\"d\"],{\"children\":[[\"slug\",\"java-production-troubleshooting\",\"d\"],{\"children\":[\"__PAGE__?{\\\"category\\\":\\\"notes\\\",\\\"slug\\\":\\\"java-production-troubleshooting\\\"}\",{}]}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"category\",\"notes\",\"d\"],{\"children\":[[\"slug\",\"java-production-troubleshooting\",\"d\"],{\"children\":[\"__PAGE__\",{},[[\"$L3\",\"$L4\",null],null],null]},[null,[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$6\",\"children\",\"$7\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}]],null]},[null,[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$6\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}]],null]},[[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/55b7a9e84b417e65.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],\"$L9\"],null],null],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$La\"],\"globalErrorComponent\":\"$b\",\"missingSlots\":\"$Wc\"}]\n"])</script><script>self.__next_f.push([1,"d:I[2972,[\"972\",\"static/chunks/972-17ea62b17795b286.js\",\"621\",\"static/chunks/app/%5Bcategory%5D/%5Bslug%5D/page-234087874853c0eb.js\"],\"\"]\nf:I[7140,[\"972\",\"static/chunks/972-17ea62b17795b286.js\",\"185\",\"static/chunks/app/layout-8486db2c9a537bdb.js\"],\"default\"]\ne:T5141,"])</script><script>self.__next_f.push([1,"\u003ch1\u003eJava项目线上问题排查\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e线上问题排查是Java开发者的必备技能，掌握正确的排查方法和工具是关键\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003e问题分类与排查思路\u003c/h2\u003e\n\u003ch3\u003e1. 常见问题类型\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003eJava线上问题分类：\n├── CPU问题\n│   ├── CPU使用率过高\n│   ├── CPU负载过高\n│   └── 上下文切换频繁\n├── 内存问题\n│   ├── 内存溢出（OOM）\n│   ├── 内存泄漏\n│   └── GC频繁\n├── 线程问题\n│   ├── 死锁\n│   ├── 线程阻塞\n│   └── 线程数过多\n├── 网络问题\n│   ├── 连接超时\n│   ├── 连接池耗尽\n│   └── 网络延迟\n└── 应用问题\n    ├── 响应缓慢\n    ├── 错误率升高\n    └── 间歇性故障\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e2. 排查方法论\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e问题排查流程\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e1. 问题现象确认\n   ├── 确定问题影响范围\n   ├── 收集关键指标\n   └── 复现问题现象\n\n2. 初步诊断\n   ├── 查看系统资源\n   ├── 分析应用日志\n   └── 检查监控指标\n\n3. 深入分析\n   ├── 使用专业工具\n   ├── 分析堆栈信息\n   └── 定位根本原因\n\n4. 解决方案\n   ├── 制定修复方案\n   ├── 实施变更\n   └── 验证效果\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eCPU问题排查\u003c/h2\u003e\n\u003ch3\u003e1. CPU使用率过高\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e排查步骤\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 1. 查看CPU使用率\ntop -p \u0026lt;pid\u0026gt;\n\n# 2. 查看线程CPU使用情况\ntop -H -p \u0026lt;pid\u0026gt;\n\n# 3. 导出线程栈\njstack \u0026lt;pid\u0026gt; \u0026gt; thread_dump.txt\n\n# 4. 将线程ID转换为16进制\nprintf \u0026quot;%x\\n\u0026quot; \u0026lt;thread_id\u0026gt;\n\n# 5. 在线程栈中查找对应线程\ngrep -A 20 \u0026lt;hex_thread_id\u0026gt; thread_dump.txt\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e自动化排查脚本\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e#!/bin/bash\n# cpu_troubleshoot.sh\n\nPID=$1\nif [ -z \u0026quot;$PID\u0026quot; ]; then\n    echo \u0026quot;Usage: $0 \u0026lt;pid\u0026gt;\u0026quot;\n    exit 1\nfi\n\necho \u0026quot;=== CPU使用情况 ===\u0026quot;\ntop -p $PID -n 1 | head -20\n\necho \u0026quot;=== 高CPU线程 ===\u0026quot;\ntop -H -p $PID -n 1 | head -20\n\necho \u0026quot;=== 生成线程栈 ===\u0026quot;\njstack $PID \u0026gt; thread_dump_$(date +%Y%m%d_%H%M%S).txt\n\necho \u0026quot;=== 获取GC信息 ===\u0026quot;\njstat -gc $PID 1s 10\n\necho \u0026quot;=== 查看堆内存使用 ===\u0026quot;\njmap -histo $PID | head -20\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e2. Java代码中的CPU问题\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e死循环检测\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// 死循环示例\npublic class DeadLoop {\n    public void process() {\n        while (true) {\n            // 没有退出条件的循环\n            try {\n                Thread.sleep(1);\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n}\n\n// 频繁Full GC\npublic class FrequentGC {\n    public void process() {\n        List\u0026lt;byte[]\u0026gt; list = new ArrayList\u0026lt;\u0026gt;();\n        while (true) {\n            list.add(new byte[1024 * 1024]); // 1MB\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCPU密集型操作优化\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// 优化前\npublic List\u0026lt;Integer\u0026gt; calculatePrimes(int limit) {\n    List\u0026lt;Integer\u0026gt; primes = new ArrayList\u0026lt;\u0026gt;();\n    for (int i = 2; i \u0026lt;= limit; i++) {\n        if (isPrime(i)) {\n            primes.add(i);\n        }\n    }\n    return primes;\n}\n\n// 优化后：使用并行流\npublic List\u0026lt;Integer\u0026gt; calculatePrimes(int limit) {\n    return IntStream.rangeClosed(2, limit)\n        .parallel()\n        .filter(this::isPrime)\n        .boxed()\n        .collect(Collectors.toList());\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e内存问题排查\u003c/h2\u003e\n\u003ch3\u003e1. 内存溢出（OOM）\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e堆内存溢出\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 1. 查看内存使用\njstat -gc \u0026lt;pid\u0026gt; 1s 5\n\n# 2. 生成堆转储文件\njmap -dump:format=b,file=heap.hprof \u0026lt;pid\u0026gt;\n\n# 3. 分析堆转储文件\njhat heap.hprof\n\n# 4. 使用MAT分析\n# 启动MAT工具，导入heap.hprof文件\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eOOM分析脚本\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e#!/bin/bash\n# oom_analysis.sh\n\nPID=$1\nDUMP_FILE=\u0026quot;heap_$(date +%Y%m%d_%H%M%S).hprof\u0026quot;\n\necho \u0026quot;=== 生成堆转储文件 ===\u0026quot;\njmap -dump:format=b,file=$DUMP_FILE $PID\n\necho \u0026quot;=== 堆转储文件大小 ===\u0026quot;\nls -lh $DUMP_FILE\n\necho \u0026quot;=== 使用MAT分析 ===\u0026quot;\necho \u0026quot;请使用MAT工具打开 $DUMP_FILE 进行分析\u0026quot;\n\n# 自动分析脚本\ncat \u0026gt; oom_analysis.py \u0026lt;\u0026lt; \u0026#39;EOF\u0026#39;\nimport sys\nimport re\n\ndef analyze_heap_dump(file_path):\n    # 这里可以添加自动分析逻辑\n    print(f\u0026quot;分析堆转储文件: {file_path}\u0026quot;)\n    \nif __name__ == \u0026quot;__main__\u0026quot;:\n    if len(sys.argv) != 2:\n        print(\u0026quot;Usage: python oom_analysis.py \u0026lt;heap_dump_file\u0026gt;\u0026quot;)\n        sys.exit(1)\n    \n    analyze_heap_dump(sys.argv[1])\nEOF\n\npython oom_analysis.py $DUMP_FILE\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e2. 内存泄漏检测\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e内存泄漏常见场景\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// 静态集合持有对象引用\npublic class MemoryLeak {\n    private static final List\u0026lt;Object\u0026gt; cache = new ArrayList\u0026lt;\u0026gt;();\n    \n    public void addToCache(Object obj) {\n        cache.add(obj); // 永远不会被清理\n    }\n}\n\n// 未关闭的资源\npublic class ResourceLeak {\n    public void processData() {\n        try {\n            Connection conn = getConnection();\n            Statement stmt = conn.createStatement();\n            ResultSet rs = stmt.executeQuery(\u0026quot;SELECT * FROM large_table\u0026quot;);\n            // 没有关闭连接、Statement和ResultSet\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n// 监听器未移除\npublic class ListenerLeak {\n    private List\u0026lt;EventListener\u0026gt; listeners = new ArrayList\u0026lt;\u0026gt;();\n    \n    public void addListener(EventListener listener) {\n        listeners.add(listener);\n    }\n    \n    // 缺少removeListener方法\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e内存泄漏检测工具\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// 使用WeakReference检测内存泄漏\npublic class MemoryLeakDetector {\n    private static final Map\u0026lt;String, WeakReference\u0026lt;Object\u0026gt;\u0026gt; weakRefs = \n        new ConcurrentHashMap\u0026lt;\u0026gt;();\n    \n    public static void track(String key, Object obj) {\n        weakRefs.put(key, new WeakReference\u0026lt;\u0026gt;(obj));\n    }\n    \n    public static void checkLeaks() {\n        for (Map.Entry\u0026lt;String, WeakReference\u0026lt;Object\u0026gt;\u0026gt; entry : weakRefs.entrySet()) {\n            WeakReference\u0026lt;Object\u0026gt; ref = entry.getValue();\n            if (ref.get() == null) {\n                System.out.println(\u0026quot;对象已被回收: \u0026quot; + entry.getKey());\n            } else {\n                System.out.println(\u0026quot;可能的内存泄漏: \u0026quot; + entry.getKey());\n            }\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e线程问题排查\u003c/h2\u003e\n\u003ch3\u003e1. 死锁检测\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e死锁检测脚本\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e#!/bin/bash\n# deadlock_detector.sh\n\nPID=$1\n\necho \u0026quot;=== 检测死锁 ===\u0026quot;\njstack $PID | grep -A 20 \u0026quot;Found one Java-level deadlock\u0026quot;\n\necho \u0026quot;=== 线程状态统计 ===\u0026quot;\njstack $PID | grep -E \u0026quot;java.lang.Thread.State:\u0026quot; | sort | uniq -c\n\necho \u0026quot;=== 阻塞线程 ===\u0026quot;\njstack $PID | grep -A 5 \u0026quot;BLOCKED\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e死锁示例和分析\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e// 死锁示例\npublic class DeadlockExample {\n    private static final Object lock1 = new Object();\n    private static final Object lock2 = new Object();\n    \n    public static void main(String[] args) {\n        Thread thread1 = new Thread(() -\u0026gt; {\n            synchronized (lock1) {\n                try {\n                    Thread.sleep(100);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                synchronized (lock2) {\n                    System.out.println(\u0026quot;Thread 1 acquired both locks\u0026quot;);\n                }\n            }\n        });\n        \n        Thread thread2 = new Thread(() -\u0026gt; {\n            synchronized (lock2) {\n                try {\n                    Thread.sleep(100);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                synchronized (lock1) {\n                    System.out.println(\u0026quot;Thread 2 acquired both locks\u0026quot;);\n                }\n            }\n        });\n        \n        thread1.start();\n        thread2.start();\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e2. 线程池问题\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e线程池监控\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@Component\npublic class ThreadPoolMonitor {\n    \n    @Autowired\n    private ThreadPoolExecutor executor;\n    \n    @Scheduled(fixedRate = 5000)\n    public void monitorThreadPool() {\n        System.out.println(\u0026quot;=== 线程池状态 ===\u0026quot;);\n        System.out.println(\u0026quot;核心线程数: \u0026quot; + executor.getCorePoolSize());\n        System.out.println(\u0026quot;最大线程数: \u0026quot; + executor.getMaximumPoolSize());\n        System.out.println(\u0026quot;当前线程数: \u0026quot; + executor.getActiveCount());\n        System.out.println(\u0026quot;队列大小: \u0026quot; + executor.getQueue().size());\n        System.out.println(\u0026quot;完成任务数: \u0026quot; + executor.getCompletedTaskCount());\n        \n        // 告警逻辑\n        if (executor.getActiveCount() \u0026gt; executor.getMaximumPoolSize() * 0.8) {\n            System.out.println(\u0026quot;警告: 线程池使用率过高\u0026quot;);\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e网络问题排查\u003c/h2\u003e\n\u003ch3\u003e1. 连接超时问题\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e网络连接监控\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@Component\npublic class NetworkMonitor {\n    \n    private final RestTemplate restTemplate;\n    \n    public NetworkMonitor() {\n        this.restTemplate = new RestTemplate();\n        \n        // 配置连接超时\n        HttpComponentsClientHttpRequestFactory factory = \n            new HttpComponentsClientHttpRequestFactory();\n        factory.setConnectTimeout(5000);\n        factory.setReadTimeout(10000);\n        this.restTemplate.setRequestFactory(factory);\n    }\n    \n    @Scheduled(fixedRate = 30000)\n    public void checkConnectivity() {\n        try {\n            ResponseEntity\u0026lt;String\u0026gt; response = restTemplate.getForEntity(\n                \u0026quot;http://example.com/health\u0026quot;, String.class);\n            if (response.getStatusCode().is2xxSuccessful()) {\n                System.out.println(\u0026quot;网络连接正常\u0026quot;);\n            }\n        } catch (Exception e) {\n            System.err.println(\u0026quot;网络连接异常: \u0026quot; + e.getMessage());\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e2. 连接池问题\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e数据库连接池监控\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@Component\npublic class ConnectionPoolMonitor {\n    \n    @Autowired\n    private DataSource dataSource;\n    \n    @Scheduled(fixedRate = 10000)\n    public void monitorConnectionPool() {\n        if (dataSource instanceof HikariDataSource) {\n            HikariDataSource hikariDataSource = (HikariDataSource) dataSource;\n            HikariPoolMXBean poolProxy = hikariDataSource.getHikariPoolMXBean();\n            \n            System.out.println(\u0026quot;=== 连接池状态 ===\u0026quot;);\n            System.out.println(\u0026quot;活跃连接数: \u0026quot; + poolProxy.getActiveConnections());\n            System.out.println(\u0026quot;空闲连接数: \u0026quot; + poolProxy.getIdleConnections());\n            System.out.println(\u0026quot;总连接数: \u0026quot; + poolProxy.getTotalConnections());\n            System.out.println(\u0026quot;等待线程数: \u0026quot; + poolProxy.getThreadsAwaitingConnection());\n            \n            // 告警逻辑\n            if (poolProxy.getActiveConnections() \u0026gt; poolProxy.getTotalConnections() * 0.8) {\n                System.err.println(\u0026quot;警告: 连接池使用率过高\u0026quot;);\n            }\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e日志分析\u003c/h2\u003e\n\u003ch3\u003e1. 日志配置优化\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eLogback配置\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-xml\"\u003e\u0026lt;!-- logback.xml --\u0026gt;\n\u0026lt;configuration\u0026gt;\n    \u0026lt;appender name=\u0026quot;CONSOLE\u0026quot; class=\u0026quot;ch.qos.logback.core.ConsoleAppender\u0026quot;\u0026gt;\n        \u0026lt;encoder\u0026gt;\n            \u0026lt;pattern\u0026gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n\u0026lt;/pattern\u0026gt;\n        \u0026lt;/encoder\u0026gt;\n    \u0026lt;/appender\u0026gt;\n    \n    \u0026lt;appender name=\u0026quot;FILE\u0026quot; class=\u0026quot;ch.qos.logback.core.rolling.RollingFileAppender\u0026quot;\u0026gt;\n        \u0026lt;file\u0026gt;logs/application.log\u0026lt;/file\u0026gt;\n        \u0026lt;rollingPolicy class=\u0026quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy\u0026quot;\u0026gt;\n            \u0026lt;fileNamePattern\u0026gt;logs/application.%d{yyyy-MM-dd}.%i.log\u0026lt;/fileNamePattern\u0026gt;\n            \u0026lt;maxFileSize\u0026gt;100MB\u0026lt;/maxFileSize\u0026gt;\n            \u0026lt;maxHistory\u0026gt;30\u0026lt;/maxHistory\u0026gt;\n            \u0026lt;totalSizeCap\u0026gt;3GB\u0026lt;/totalSizeCap\u0026gt;\n        \u0026lt;/rollingPolicy\u0026gt;\n        \u0026lt;encoder\u0026gt;\n            \u0026lt;pattern\u0026gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n\u0026lt;/pattern\u0026gt;\n        \u0026lt;/encoder\u0026gt;\n    \u0026lt;/appender\u0026gt;\n    \n    \u0026lt;!-- 异步日志 --\u0026gt;\n    \u0026lt;appender name=\u0026quot;ASYNC_FILE\u0026quot; class=\u0026quot;ch.qos.logback.classic.AsyncAppender\u0026quot;\u0026gt;\n        \u0026lt;discardingThreshold\u0026gt;0\u0026lt;/discardingThreshold\u0026gt;\n        \u0026lt;queueSize\u0026gt;1024\u0026lt;/queueSize\u0026gt;\n        \u0026lt;appender-ref ref=\u0026quot;FILE\u0026quot;/\u0026gt;\n    \u0026lt;/appender\u0026gt;\n    \n    \u0026lt;root level=\u0026quot;INFO\u0026quot;\u0026gt;\n        \u0026lt;appender-ref ref=\u0026quot;CONSOLE\u0026quot;/\u0026gt;\n        \u0026lt;appender-ref ref=\u0026quot;ASYNC_FILE\u0026quot;/\u0026gt;\n    \u0026lt;/root\u0026gt;\n\u0026lt;/configuration\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e2. 日志分析脚本\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e错误日志分析\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e#!/bin/bash\n# log_analyzer.sh\n\nLOG_FILE=$1\nif [ -z \u0026quot;$LOG_FILE\u0026quot; ]; then\n    echo \u0026quot;Usage: $0 \u0026lt;log_file\u0026gt;\u0026quot;\n    exit 1\nfi\n\necho \u0026quot;=== 错误统计 ===\u0026quot;\ngrep -E \u0026quot;ERROR|Exception\u0026quot; $LOG_FILE | awk \u0026#39;{print $1, $2}\u0026#39; | sort | uniq -c | sort -nr\n\necho \u0026quot;=== 最近错误 ===\u0026quot;\ntail -100 $LOG_FILE | grep -E \u0026quot;ERROR|Exception\u0026quot; | tail -10\n\necho \u0026quot;=== HTTP 5xx错误 ===\u0026quot;\ngrep -E \u0026quot;HTTP/1\\.[01]\\\u0026quot; [5][0-9][0-9]\u0026quot; $LOG_FILE | awk \u0026#39;{print $7}\u0026#39; | sort | uniq -c | sort -nr\n\necho \u0026quot;=== 慢查询日志 ===\u0026quot;\ngrep -E \u0026quot;took.*ms\u0026quot; $LOG_FILE | awk \u0026#39;$NF \u0026gt; 1000 {print $0}\u0026#39;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e性能监控工具\u003c/h2\u003e\n\u003ch3\u003e1. JVM监控\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eJMX监控\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@Component\npublic class JVMMonitor {\n    \n    private final MemoryMXBean memoryMXBean;\n    private final ThreadMXBean threadMXBean;\n    private final RuntimeMXBean runtimeMXBean;\n    \n    public JVMMonitor() {\n        MBeanServer mBeanServer = ManagementFactory.getPlatformMBeanServer();\n        this.memoryMXBean = ManagementFactory.newPlatformMXBeanProxy(\n            mBeanServer, ManagementFactory.MEMORY_MXBEAN_NAME, MemoryMXBean.class);\n        this.threadMXBean = ManagementFactory.newPlatformMXBeanProxy(\n            mBeanServer, ManagementFactory.THREAD_MXBEAN_NAME, ThreadMXBean.class);\n        this.runtimeMXBean = ManagementFactory.newPlatformMXBeanProxy(\n            mBeanServer, ManagementFactory.RUNTIME_MXBEAN_NAME, RuntimeMXBean.class);\n    }\n    \n    @Scheduled(fixedRate = 10000)\n    public void monitorJVM() {\n        // 内存监控\n        MemoryUsage heapUsage = memoryMXBean.getHeapMemoryUsage();\n        double heapUsagePercent = (double) heapUsage.getUsed() / heapUsage.getMax() * 100;\n        \n        // 线程监控\n        int threadCount = threadMXBean.getThreadCount();\n        \n        // GC监控\n        List\u0026lt;GarbageCollectorMXBean\u0026gt; gcBeans = ManagementFactory.getGarbageCollectorMXBeans();\n        \n        System.out.println(\u0026quot;=== JVM监控 ===\u0026quot;);\n        System.out.println(\u0026quot;堆内存使用率: \u0026quot; + String.format(\u0026quot;%.2f%%\u0026quot;, heapUsagePercent));\n        System.out.println(\u0026quot;线程数: \u0026quot; + threadCount);\n        \n        // 告警逻辑\n        if (heapUsagePercent \u0026gt; 80) {\n            System.err.println(\u0026quot;警告: 堆内存使用率过高\u0026quot;);\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e2. 应用性能监控（APM）\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e自定义性能监控\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@Component\npublic class PerformanceMonitor {\n    \n    private final MeterRegistry meterRegistry;\n    \n    public PerformanceMonitor(MeterRegistry meterRegistry) {\n        this.meterRegistry = meterRegistry;\n    }\n    \n    public void recordApiCall(String apiName, long duration, String status) {\n        Timer.Sample sample = Timer.start(meterRegistry);\n        sample.stop(Timer.builder(\u0026quot;api.call.time\u0026quot;)\n            .tag(\u0026quot;api\u0026quot;, apiName)\n            .tag(\u0026quot;status\u0026quot;, status)\n            .register(meterRegistry));\n        \n        Counter.builder(\u0026quot;api.call.count\u0026quot;)\n            .tag(\u0026quot;api\u0026quot;, apiName)\n            .tag(\u0026quot;status\u0026quot;, status)\n            .register(meterRegistry)\n            .increment();\n    }\n    \n    @Aspect\n    @Component\n    public class ApiMonitorAspect {\n        \n        @Around(\u0026quot;@annotation(Monitored)\u0026quot;)\n        public Object monitorApi(ProceedingJoinPoint joinPoint) throws Throwable {\n            long startTime = System.currentTimeMillis();\n            String apiName = joinPoint.getSignature().getName();\n            \n            try {\n                Object result = joinPoint.proceed();\n                long duration = System.currentTimeMillis() - startTime;\n                \n                performanceMonitor.recordApiCall(apiName, duration, \u0026quot;SUCCESS\u0026quot;);\n                return result;\n            } catch (Exception e) {\n                long duration = System.currentTimeMillis() - startTime;\n                \n                performanceMonitor.recordApiCall(apiName, duration, \u0026quot;ERROR\u0026quot;);\n                throw e;\n            }\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e应急处理流程\u003c/h2\u003e\n\u003ch3\u003e1. 故障响应流程\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003e故障响应流程：\n1. 故障发现\n   ├── 监控系统告警\n   ├── 用户反馈\n   └── 主动巡检\n\n2. 故障确认\n   ├── 确认影响范围\n   ├── 评估严重程度\n   └── 启动应急响应\n\n3. 快速止损\n   ├── 服务降级\n   ├── 流量限制\n   └── 紧急回滚\n\n4. 问题定位\n   ├── 收集日志\n   ├── 分析监控数据\n   └── 复现问题\n\n5. 修复验证\n   ├── 实施修复\n   ├── 验证效果\n   └── 恢复服务\n\n6. 复盘总结\n   ├── 分析根因\n   ├── 制定改进措施\n   └── 更新应急预案\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e2. 应急脚本\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e服务快速重启脚本\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e#!/bin/bash\n# emergency_restart.sh\n\nSERVICE_NAME=$1\nif [ -z \u0026quot;$SERVICE_NAME\u0026quot; ]; then\n    echo \u0026quot;Usage: $0 \u0026lt;service_name\u0026gt;\u0026quot;\n    exit 1\nfi\n\necho \u0026quot;=== 紧急重启服务: $SERVICE_NAME ===\u0026quot;\n\n# 1. 备份当前状态\necho \u0026quot;备份服务状态...\u0026quot;\nsystemctl status $SERVICE_NAME \u0026gt; service_status_$(date +%Y%m%d_%H%M%S).txt\n\n# 2. 停止服务\necho \u0026quot;停止服务...\u0026quot;\nsystemctl stop $SERVICE_NAME\n\n# 3. 等待服务完全停止\nsleep 5\n\n# 4. 检查端口是否释放\nPORT=$(netstat -tlnp | grep $SERVICE_NAME | awk \u0026#39;{print $4}\u0026#39; | cut -d: -f2)\nif [ -n \u0026quot;$PORT\u0026quot; ]; then\n    echo \u0026quot;端口 $PORT 仍被占用，强制终止进程...\u0026quot;\n    pkill -f $SERVICE_NAME\nfi\n\n# 5. 启动服务\necho \u0026quot;启动服务...\u0026quot;\nsystemctl start $SERVICE_NAME\n\n# 6. 检查服务状态\necho \u0026quot;检查服务状态...\u0026quot;\nsystemctl status $SERVICE_NAME\n\n# 7. 验证服务可用性\necho \u0026quot;验证服务可用性...\u0026quot;\nsleep 10\ncurl -f http://localhost:8080/health || echo \u0026quot;服务健康检查失败\u0026quot;\n\necho \u0026quot;=== 重启完成 ===\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e总结\u003c/h2\u003e\n\u003cp\u003eJava线上问题排查是一个系统性工程，需要掌握以下关键技能：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e工具使用\u003c/strong\u003e：熟练使用jstat、jstack、jmap、MAT等工具\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e问题分类\u003c/strong\u003e：能够快速识别问题类型和影响范围\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e分析方法\u003c/strong\u003e：掌握科学的分析方法和思路\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e经验积累\u003c/strong\u003e：通过实际案例积累经验\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e预防措施\u003c/strong\u003e：建立完善的监控和预防机制\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e通过系统化的排查方法和工具使用，可以快速定位和解决线上问题，保障系统的稳定运行。\u003c/p\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"children\":[[\"$\",\"$Ld\",null,{\"href\":\"/notes\",\"className\":\"back-button\",\"style\":{\"display\":\"inline-block\",\"background\":\"var(--primary-color)\",\"color\":\"white\",\"border\":\"none\",\"padding\":\"10px 20px\",\"borderRadius\":\"6px\",\"cursor\":\"pointer\",\"marginBottom\":\"20px\",\"textDecoration\":\"none\"},\"children\":[\"← 返回\",\"笔记\",\"列表\"]}],[\"$\",\"article\",null,{\"className\":\"section\",\"children\":[[\"$\",\"header\",null,{\"className\":\"article-header\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"article-title\",\"children\":\"Java项目线上问题排查\"}],[\"$\",\"div\",null,{\"className\":\"article-meta\",\"children\":[[\"$\",\"div\",null,{\"className\":\"article-meta-info\",\"children\":[[\"$\",\"span\",null,{\"className\":\"article-date\",\"children\":\"2024-10-14\"}],[\"$\",\"span\",null,{\"className\":\"article-category\",\"children\":[\"• \",\"笔记\"]}]]}],[\"$\",\"div\",null,{\"className\":\"article-tags\",\"children\":[[\"$\",\"span\",\"Java\",{\"className\":\"tag\",\"children\":\"Java\"}],[\"$\",\"span\",\"线上排查\",{\"className\":\"tag\",\"children\":\"线上排查\"}],[\"$\",\"span\",\"性能调优\",{\"className\":\"tag\",\"children\":\"性能调优\"}],[\"$\",\"span\",\"故障诊断\",{\"className\":\"tag\",\"children\":\"故障诊断\"}],[\"$\",\"span\",\"JVM\",{\"className\":\"tag\",\"children\":\"JVM\"}]]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"card markdown-content\",\"dangerouslySetInnerHTML\":{\"__html\":\"$e\"}}]]}]]}]\n"])</script><script>self.__next_f.push([1,"9:[\"$\",\"html\",null,{\"lang\":\"zh-CN\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"link\",null,{\"rel\":\"stylesheet\",\"href\":\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css\"}],[\"$\",\"link\",null,{\"rel\":\"stylesheet\",\"href\":\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css\"}]]}],[\"$\",\"body\",null,{\"children\":[\"$\",\"div\",null,{\"className\":\"app\",\"children\":[[\"$\",\"$Lf\",null,{\"siteConfig\":{\"name\":\"Rudy Yang\",\"bio\":\"JAVA | AI | WEB3\",\"social\":[{\"name\":\"github\",\"icon\":\"fab fa-github\",\"url\":\"https://github.com/suogongy\"},{\"name\":\"twitter\",\"icon\":\"fab fa-twitter\",\"url\":\"https://twitter.com/suogongy\"},{\"name\":\"email\",\"icon\":\"fas fa-envelope\",\"url\":\"mailto:haiyuan1832@163.com\"}]}}],[\"$\",\"main\",null,{\"className\":\"main-content\",\"children\":[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"Java项目线上问题排查 - Personal GitHub Page\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"详细介绍Java项目在线上环境中常见的问题排查方法、诊断工具和解决方案，包括CPU、内存、线程、网络等方面的故障排查。\"}]]\n3:null\n"])</script></body></html>