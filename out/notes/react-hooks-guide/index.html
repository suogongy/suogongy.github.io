<!DOCTYPE html><html lang="zh-CN"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/55b7a9e84b417e65.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-c81f7fd28659d64f.js"/><script src="/_next/static/chunks/fd9d1056-9f91b5e418130764.js" async=""></script><script src="/_next/static/chunks/117-ee7b0ec54963e50f.js" async=""></script><script src="/_next/static/chunks/main-app-c180f1b9030bf4f6.js" async=""></script><script src="/_next/static/chunks/972-17ea62b17795b286.js" async=""></script><script src="/_next/static/chunks/app/%5Bcategory%5D/%5Bslug%5D/page-234087874853c0eb.js" async=""></script><script src="/_next/static/chunks/app/layout-8486db2c9a537bdb.js" async=""></script><title>React Hooks 完全指南 - Personal GitHub Page</title><meta name="description" content="全面掌握 React Hooks 的核心概念、使用方法和高级技巧"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css"/><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body><div class="app"><header class="header "><nav class="nav-container"><a class="nav-brand" href="/"><i class="fas fa-terminal"></i>Rudy Yang</a><ul class="nav-menu"><li><a class="nav-link " href="/"><i class="fas fa-home"></i> 首页</a></li><li><a class="nav-link " href="/about/"><i class="fas fa-user"></i> 关于</a></li><li><a class="nav-link " href="/projects/"><i class="fas fa-code"></i> 项目</a></li><li><a class="nav-link " href="/notes/"><i class="fas fa-book"></i> 笔记</a></li><li><a class="nav-link " href="/articles/"><i class="fas fa-pen"></i> 随笔</a></li></ul></nav></header><main class="main-content"><div><a class="back-button" style="display:inline-block;background:var(--primary-color);color:white;border:none;padding:10px 20px;border-radius:6px;cursor:pointer;margin-bottom:20px;text-decoration:none" href="/notes/">← 返回<!-- -->笔记<!-- -->列表</a><article class="section"><header class="article-header"><h1 class="article-title">React Hooks 完全指南</h1><div class="article-meta"><div class="article-meta-info"><span class="article-date">2024-01-15</span><span class="article-category">• <!-- -->笔记</span></div><div class="article-tags"><span class="tag">React</span><span class="tag">JavaScript</span><span class="tag">前端</span></div></div></header><div class="card markdown-content"><h1>React Hooks 完全指南</h1>
<p>React Hooks 是 React 16.8 引入的新特性，它让我们在不编写类组件的情况下使用 state 和其他 React 特性。</p>
<h2>目录</h2>
<ol>
<li><a href="#hooks-%E7%AE%80%E4%BB%8B">Hooks 简介</a></li>
<li><a href="#%E5%9F%BA%E6%9C%AC-hooks">基本 Hooks</a></li>
<li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89-hooks">自定义 Hooks</a></li>
<li><a href="#hooks-%E8%A7%84%E5%88%99">Hooks 规则</a></li>
<li><a href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5">最佳实践</a></li>
</ol>
<h2>Hooks 简介</h2>
<p>Hooks 是一些可以让你在函数组件里&quot;钩入&quot; React state 及生命周期等特性的函数。Hook 不能在类组件中使用 —— 这使得你不使用 class 也能使用 React。</p>
<h3>为什么需要 Hooks？</h3>
<ol>
<li><strong>组件逻辑复用</strong>：解决了高阶组件和 render props 的嵌套地狱问题</li>
<li><strong>复杂组件理解</strong>：将相关逻辑组织在一起，而不是分散在不同的生命周期方法中</li>
<li><strong>类组件的困惑</strong>：告别 <code>this</code> 指向的困扰</li>
</ol>
<h2>基本 Hooks</h2>
<h3>useState</h3>
<p><code>useState</code> 是最常用的 Hook，用于在函数组件中添加状态。</p>
<pre><code class="language-javascript">import React, { useState } from &#39;react&#39;;

function Counter() {
  // 声明一个新的叫做 &quot;count&quot; 的 state 变量
  const [count, setCount] = useState(0);

  return (
    &lt;div&gt;
      &lt;p&gt;You clicked {count} times&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;
        Click me
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<h4>useState 语法</h4>
<pre><code class="language-javascript">const [state, setState] = useState(initialState);
</code></pre>
<ul>
<li><code>state</code>：当前状态值</li>
<li><code>setState</code>：更新状态的函数</li>
<li><code>initialState</code>：初始状态值</li>
</ul>
<h4>函数式更新</h4>
<p>如果新的 state 需要通过使用先前的 state 计算得出，那么可以传递函数给 <code>setState</code>：</p>
<pre><code class="language-javascript">function Counter() {
  const [count, setCount] = useState(0);

  function handleClick() {
    setCount(prevCount =&gt; prevCount + 1);
  }

  return (
    &lt;button onClick={handleClick}&gt;
      Count: {count}
    &lt;/button&gt;
  );
}
</code></pre>
<h3>useEffect</h3>
<p><code>useEffect</code> Hook 可以让你在函数组件中执行副作用操作。</p>
<pre><code class="language-javascript">import React, { useState, useEffect } from &#39;react&#39;;

function Example() {
  const [count, setCount] = useState(0);

  // 相当于 componentDidMount 和 componentDidUpdate
  useEffect(() =&gt; {
    // 更新文档标题
    document.title = `You clicked ${count} times`;
  }, [count]); // 仅在 count 更改时更新

  return (
    &lt;div&gt;
      &lt;p&gt;You clicked {count} times&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;
        Click me
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<h4>清除副作用</h4>
<p>副作用函数还可以返回一个清除函数：</p>
<pre><code class="language-javascript">useEffect(() =&gt; {
  const subscription = props.source.subscribe();
  return () =&gt; {
    // 清除订阅
    subscription.unsubscribe();
  };
}, [props.source]);
</code></pre>
<h4>常见的使用场景</h4>
<ol>
<li><strong>数据获取</strong>：</li>
</ol>
<pre><code class="language-javascript">useEffect(() =&gt; {
  const fetchData = async () =&gt; {
    const result = await axios(&#39;https://api.example.com/data&#39;);
    setData(result.data);
  };
  
  fetchData();
}, []);
</code></pre>
<ol start="2">
<li><strong>订阅</strong>：</li>
</ol>
<pre><code class="language-javascript">useEffect(() =&gt; {
  const handleScroll = () =&gt; {
    console.log(window.scrollY);
  };
  
  window.addEventListener(&#39;scroll&#39;, handleScroll);
  return () =&gt; window.removeEventListener(&#39;scroll&#39;, handleScroll);
}, []);
</code></pre>
<ol start="3">
<li><strong>定时器</strong>：</li>
</ol>
<pre><code class="language-javascript">useEffect(() =&gt; {
  const timer = setInterval(() =&gt; {
    setTime(new Date());
  }, 1000);
  
  return () =&gt; clearInterval(timer);
}, []);
</code></pre>
<h3>useContext</h3>
<p><code>useContext</code> 可以在组件之间共享状态，而不需要显式地通过组件树逐层传递 props。</p>
<pre><code class="language-javascript">import React, { useContext, createContext } from &#39;react&#39;;

// 创建 Context
const ThemeContext = createContext(&#39;light&#39;);

function App() {
  return (
    &lt;ThemeContext.Provider value=&quot;dark&quot;&gt;
      &lt;Toolbar /&gt;
    &lt;/ThemeContext.Provider&gt;
  );
}

function Toolbar() {
  return (
    &lt;div&gt;
      &lt;ThemedButton /&gt;
    &lt;/div&gt;
  );
}

function ThemedButton() {
  const theme = useContext(ThemeContext);
  return &lt;button style={{ background: theme === &#39;dark&#39; ? &#39;#333&#39; : &#39;#FFF&#39; }}&gt;
    I am a {theme} button
  &lt;/button&gt;;
}
</code></pre>
<h2>自定义 Hooks</h2>
<p>自定义 Hook 是一个函数，其名称以 &quot;use&quot; 开头，函数内部可以调用其他的 Hook。</p>
<h3>创建自定义 Hook</h3>
<pre><code class="language-javascript">import { useState, useEffect } from &#39;react&#39;;

function useCounter(initialValue = 0) {
  const [count, setCount] = useState(initialValue);

  const increment = () =&gt; setCount(count + 1);
  const decrement = () =&gt; setCount(count - 1);
  const reset = () =&gt; setCount(initialValue);

  return { count, increment, decrement, reset };
}

// 使用自定义 Hook
function Counter() {
  const { count, increment, decrement, reset } = useCounter(10);

  return (
    &lt;div&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;
      &lt;button onClick={increment}&gt;+&lt;/button&gt;
      &lt;button onClick={decrement}&gt;-&lt;/button&gt;
      &lt;button onClick={reset}&gt;Reset&lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<h3>实用的自定义 Hook 示例</h3>
<h4>useLocalstorage</h4>
<pre><code class="language-javascript">function useLocalStorage(key, initialValue) {
  const [storedValue, setStoredValue] = useState(() =&gt; {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      return initialValue;
    }
  });

  const setValue = (value) =&gt; {
    try {
      setStoredValue(value);
      window.localStorage.setItem(key, JSON.stringify(value));
    } catch (error) {
      console.error(error);
    }
  };

  return [storedValue, setValue];
}
</code></pre>
<h4>useDebounce</h4>
<pre><code class="language-javascript">function useDebounce(value, delay) {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() =&gt; {
    const handler = setTimeout(() =&gt; {
      setDebouncedValue(value);
    }, delay);

    return () =&gt; {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}
</code></pre>
<h2>Hooks 规则</h2>
<p>使用 Hook 时必须遵循两条规则：</p>
<h3>1. 只在最顶层使用 Hook</h3>
<p>不要在循环、条件或嵌套函数中调用 Hook：</p>
<pre><code class="language-javascript">// ❌ 错误
function BadComponent() {
  if (someCondition) {
    const [count, setCount] = useState(0);
  }
}

// ✅ 正确
function GoodComponent() {
  const [count, setCount] = useState(0);
  
  if (someCondition) {
    // 在条件中使用 state
    return &lt;div&gt;{count}&lt;/div&gt;;
  }
}
</code></pre>
<h3>2. 只在 React 函数中调用 Hook</h3>
<p>不要在普通的 JavaScript 函数中调用 Hook：</p>
<pre><code class="language-javascript">// ❌ 错误
function handleSomething() {
  const [count, setCount] = useState(0);
}

// ✅ 正确
function MyComponent() {
  const [count, setCount] = useState(0);
  
  const handleSomething = () =&gt; {
    // 在事件处理函数中使用 state
    setCount(count + 1);
  };
}
</code></pre>
<h2>最佳实践</h2>
<h3>1. 合理组织 Hooks</h3>
<pre><code class="language-javascript">function UserProfile({ userId }) {
  // 将相关的 hooks 组织在一起
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // 数据获取逻辑
  useEffect(() =&gt; {
    fetchUser(userId)
      .then(setUser)
      .catch(setError)
      .finally(() =&gt; setLoading(false));
  }, [userId]);

  // 其他的 hooks...
  const theme = useContext(ThemeContext);
  
  // ...
}
</code></pre>
<h3>2. 使用自定义 Hook 抽象逻辑</h3>
<pre><code class="language-javascript">// 将数据获取逻辑抽象到自定义 Hook
function useUser(userId) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() =&gt; {
    fetchUser(userId)
      .then(setUser)
      .catch(setError)
      .finally(() =&gt; setLoading(false));
  }, [userId]);

  return { user, loading, error };
}

// 组件变得简洁
function UserProfile({ userId }) {
  const { user, loading, error } = useUser(userId);
  const theme = useContext(ThemeContext);
  
  if (loading) return &lt;Spinner /&gt;;
  if (error) return &lt;ErrorMessage error={error} /&gt;;
  
  return &lt;div&gt;{user.name}&lt;/div&gt;;
}
</code></pre>
<h3>3. 性能优化</h3>
<h4>useMemo</h4>
<pre><code class="language-javascript">function ExpensiveComponent({ items }) {
  const expensiveValue = useMemo(() =&gt; {
    return items.reduce((sum, item) =&gt; sum + item.value, 0);
  }, [items]);

  return &lt;div&gt;Total: {expensiveValue}&lt;/div&gt;;
}
</code></pre>
<h4>useCallback</h4>
<pre><code class="language-javascript">function ParentComponent() {
  const [count, setCount] = useState(0);

  const handleClick = useCallback(() =&gt; {
    console.log(&#39;Button clicked&#39;);
  }, []); // 空依赖数组，函数不会重新创建

  return (
    &lt;div&gt;
      &lt;ChildComponent onClick={handleClick} /&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;
        Count: {count}
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<h3>4. 错误边界和 Hooks</h3>
<pre><code class="language-javascript">function useErrorHandler() {
  const [error, setError] = useState(null);

  const resetError = () =&gt; setError(null);

  useEffect(() =&gt; {
    if (error) {
      throw error;
    }
  }, [error]);

  return setError;
}

// 使用示例
function MyComponent() {
  const setError = useErrorHandler();

  const handleAsyncOperation = async () =&gt; {
    try {
      await riskyOperation();
    } catch (err) {
      setError(err);
    }
  };

  return &lt;button onClick={handleAsyncOperation}&gt;Run Operation&lt;/button&gt;;
}
</code></pre>
<h2>总结</h2>
<p>React Hooks 为函数组件提供了强大的能力，让我们能够：</p>
<ol>
<li><strong>更好地组织代码逻辑</strong></li>
<li><strong>复用组件逻辑</strong></li>
<li><strong>简化组件结构</strong></li>
</ol>
<p>掌握 Hooks 需要理解其工作原理和遵循使用规则。通过合理使用内置 Hooks 和创建自定义 Hooks，我们可以构建更加清晰、可维护的 React 应用。</p>
<p>记住这两个关键点：</p>
<ul>
<li><strong>只在顶层调用 Hook</strong></li>
<li><strong>只在 React 函数中调用 Hook</strong></li>
</ul>
<p>这样就能充分发挥 Hooks 的威力！</p>
</div></article></div></main></div><script src="/_next/static/chunks/webpack-c81f7fd28659d64f.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/55b7a9e84b417e65.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"2:I[2846,[],\"\"]\n5:I[4707,[],\"\"]\n8:I[6423,[],\"\"]\nb:I[1060,[],\"\"]\n6:[\"category\",\"notes\",\"d\"]\n7:[\"slug\",\"react-hooks-guide\",\"d\"]\nc:[]\n0:[\"$\",\"$L2\",null,{\"buildId\":\"build\",\"assetPrefix\":\"\",\"urlParts\":[\"\",\"notes\",\"react-hooks-guide\",\"\"],\"initialTree\":[\"\",{\"children\":[[\"category\",\"notes\",\"d\"],{\"children\":[[\"slug\",\"react-hooks-guide\",\"d\"],{\"children\":[\"__PAGE__?{\\\"category\\\":\\\"notes\\\",\\\"slug\\\":\\\"react-hooks-guide\\\"}\",{}]}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"category\",\"notes\",\"d\"],{\"children\":[[\"slug\",\"react-hooks-guide\",\"d\"],{\"children\":[\"__PAGE__\",{},[[\"$L3\",\"$L4\",null],null],null]},[null,[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$6\",\"children\",\"$7\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}]],null]},[null,[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$6\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}]],null]},[[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/55b7a9e84b417e65.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],\"$L9\"],null],null],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$La\"],\"globalErrorComponent\":\"$b\",\"missingSlots\":\"$Wc\"}]\n"])</script><script>self.__next_f.push([1,"d:I[2972,[\"972\",\"static/chunks/972-17ea62b17795b286.js\",\"621\",\"static/chunks/app/%5Bcategory%5D/%5Bslug%5D/page-234087874853c0eb.js\"],\"\"]\nf:I[7140,[\"972\",\"static/chunks/972-17ea62b17795b286.js\",\"185\",\"static/chunks/app/layout-8486db2c9a537bdb.js\"],\"default\"]\ne:T2d48,"])</script><script>self.__next_f.push([1,"\u003ch1\u003eReact Hooks 完全指南\u003c/h1\u003e\n\u003cp\u003eReact Hooks 是 React 16.8 引入的新特性，它让我们在不编写类组件的情况下使用 state 和其他 React 特性。\u003c/p\u003e\n\u003ch2\u003e目录\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"#hooks-%E7%AE%80%E4%BB%8B\"\u003eHooks 简介\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E5%9F%BA%E6%9C%AC-hooks\"\u003e基本 Hooks\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E8%87%AA%E5%AE%9A%E4%B9%89-hooks\"\u003e自定义 Hooks\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#hooks-%E8%A7%84%E5%88%99\"\u003eHooks 规则\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5\"\u003e最佳实践\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2\u003eHooks 简介\u003c/h2\u003e\n\u003cp\u003eHooks 是一些可以让你在函数组件里\u0026quot;钩入\u0026quot; React state 及生命周期等特性的函数。Hook 不能在类组件中使用 —— 这使得你不使用 class 也能使用 React。\u003c/p\u003e\n\u003ch3\u003e为什么需要 Hooks？\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e组件逻辑复用\u003c/strong\u003e：解决了高阶组件和 render props 的嵌套地狱问题\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e复杂组件理解\u003c/strong\u003e：将相关逻辑组织在一起，而不是分散在不同的生命周期方法中\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e类组件的困惑\u003c/strong\u003e：告别 \u003ccode\u003ethis\u003c/code\u003e 指向的困扰\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2\u003e基本 Hooks\u003c/h2\u003e\n\u003ch3\u003euseState\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003euseState\u003c/code\u003e 是最常用的 Hook，用于在函数组件中添加状态。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003eimport React, { useState } from \u0026#39;react\u0026#39;;\n\nfunction Counter() {\n  // 声明一个新的叫做 \u0026quot;count\u0026quot; 的 state 变量\n  const [count, setCount] = useState(0);\n\n  return (\n    \u0026lt;div\u0026gt;\n      \u0026lt;p\u0026gt;You clicked {count} times\u0026lt;/p\u0026gt;\n      \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;\n        Click me\n      \u0026lt;/button\u0026gt;\n    \u0026lt;/div\u0026gt;\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003euseState 语法\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003econst [state, setState] = useState(initialState);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003estate\u003c/code\u003e：当前状态值\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esetState\u003c/code\u003e：更新状态的函数\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003einitialState\u003c/code\u003e：初始状态值\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e函数式更新\u003c/h4\u003e\n\u003cp\u003e如果新的 state 需要通过使用先前的 state 计算得出，那么可以传递函数给 \u003ccode\u003esetState\u003c/code\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003efunction Counter() {\n  const [count, setCount] = useState(0);\n\n  function handleClick() {\n    setCount(prevCount =\u0026gt; prevCount + 1);\n  }\n\n  return (\n    \u0026lt;button onClick={handleClick}\u0026gt;\n      Count: {count}\n    \u0026lt;/button\u0026gt;\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003euseEffect\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003euseEffect\u003c/code\u003e Hook 可以让你在函数组件中执行副作用操作。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003eimport React, { useState, useEffect } from \u0026#39;react\u0026#39;;\n\nfunction Example() {\n  const [count, setCount] = useState(0);\n\n  // 相当于 componentDidMount 和 componentDidUpdate\n  useEffect(() =\u0026gt; {\n    // 更新文档标题\n    document.title = `You clicked ${count} times`;\n  }, [count]); // 仅在 count 更改时更新\n\n  return (\n    \u0026lt;div\u0026gt;\n      \u0026lt;p\u0026gt;You clicked {count} times\u0026lt;/p\u0026gt;\n      \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;\n        Click me\n      \u0026lt;/button\u0026gt;\n    \u0026lt;/div\u0026gt;\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e清除副作用\u003c/h4\u003e\n\u003cp\u003e副作用函数还可以返回一个清除函数：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003euseEffect(() =\u0026gt; {\n  const subscription = props.source.subscribe();\n  return () =\u0026gt; {\n    // 清除订阅\n    subscription.unsubscribe();\n  };\n}, [props.source]);\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e常见的使用场景\u003c/h4\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e数据获取\u003c/strong\u003e：\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003euseEffect(() =\u0026gt; {\n  const fetchData = async () =\u0026gt; {\n    const result = await axios(\u0026#39;https://api.example.com/data\u0026#39;);\n    setData(result.data);\n  };\n  \n  fetchData();\n}, []);\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e\u003cstrong\u003e订阅\u003c/strong\u003e：\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003euseEffect(() =\u0026gt; {\n  const handleScroll = () =\u0026gt; {\n    console.log(window.scrollY);\n  };\n  \n  window.addEventListener(\u0026#39;scroll\u0026#39;, handleScroll);\n  return () =\u0026gt; window.removeEventListener(\u0026#39;scroll\u0026#39;, handleScroll);\n}, []);\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003e\u003cstrong\u003e定时器\u003c/strong\u003e：\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003euseEffect(() =\u0026gt; {\n  const timer = setInterval(() =\u0026gt; {\n    setTime(new Date());\n  }, 1000);\n  \n  return () =\u0026gt; clearInterval(timer);\n}, []);\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003euseContext\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003euseContext\u003c/code\u003e 可以在组件之间共享状态，而不需要显式地通过组件树逐层传递 props。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003eimport React, { useContext, createContext } from \u0026#39;react\u0026#39;;\n\n// 创建 Context\nconst ThemeContext = createContext(\u0026#39;light\u0026#39;);\n\nfunction App() {\n  return (\n    \u0026lt;ThemeContext.Provider value=\u0026quot;dark\u0026quot;\u0026gt;\n      \u0026lt;Toolbar /\u0026gt;\n    \u0026lt;/ThemeContext.Provider\u0026gt;\n  );\n}\n\nfunction Toolbar() {\n  return (\n    \u0026lt;div\u0026gt;\n      \u0026lt;ThemedButton /\u0026gt;\n    \u0026lt;/div\u0026gt;\n  );\n}\n\nfunction ThemedButton() {\n  const theme = useContext(ThemeContext);\n  return \u0026lt;button style={{ background: theme === \u0026#39;dark\u0026#39; ? \u0026#39;#333\u0026#39; : \u0026#39;#FFF\u0026#39; }}\u0026gt;\n    I am a {theme} button\n  \u0026lt;/button\u0026gt;;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e自定义 Hooks\u003c/h2\u003e\n\u003cp\u003e自定义 Hook 是一个函数，其名称以 \u0026quot;use\u0026quot; 开头，函数内部可以调用其他的 Hook。\u003c/p\u003e\n\u003ch3\u003e创建自定义 Hook\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003eimport { useState, useEffect } from \u0026#39;react\u0026#39;;\n\nfunction useCounter(initialValue = 0) {\n  const [count, setCount] = useState(initialValue);\n\n  const increment = () =\u0026gt; setCount(count + 1);\n  const decrement = () =\u0026gt; setCount(count - 1);\n  const reset = () =\u0026gt; setCount(initialValue);\n\n  return { count, increment, decrement, reset };\n}\n\n// 使用自定义 Hook\nfunction Counter() {\n  const { count, increment, decrement, reset } = useCounter(10);\n\n  return (\n    \u0026lt;div\u0026gt;\n      \u0026lt;p\u0026gt;Count: {count}\u0026lt;/p\u0026gt;\n      \u0026lt;button onClick={increment}\u0026gt;+\u0026lt;/button\u0026gt;\n      \u0026lt;button onClick={decrement}\u0026gt;-\u0026lt;/button\u0026gt;\n      \u0026lt;button onClick={reset}\u0026gt;Reset\u0026lt;/button\u0026gt;\n    \u0026lt;/div\u0026gt;\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e实用的自定义 Hook 示例\u003c/h3\u003e\n\u003ch4\u003euseLocalstorage\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003efunction useLocalStorage(key, initialValue) {\n  const [storedValue, setStoredValue] = useState(() =\u0026gt; {\n    try {\n      const item = window.localStorage.getItem(key);\n      return item ? JSON.parse(item) : initialValue;\n    } catch (error) {\n      return initialValue;\n    }\n  });\n\n  const setValue = (value) =\u0026gt; {\n    try {\n      setStoredValue(value);\n      window.localStorage.setItem(key, JSON.stringify(value));\n    } catch (error) {\n      console.error(error);\n    }\n  };\n\n  return [storedValue, setValue];\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003euseDebounce\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003efunction useDebounce(value, delay) {\n  const [debouncedValue, setDebouncedValue] = useState(value);\n\n  useEffect(() =\u0026gt; {\n    const handler = setTimeout(() =\u0026gt; {\n      setDebouncedValue(value);\n    }, delay);\n\n    return () =\u0026gt; {\n      clearTimeout(handler);\n    };\n  }, [value, delay]);\n\n  return debouncedValue;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eHooks 规则\u003c/h2\u003e\n\u003cp\u003e使用 Hook 时必须遵循两条规则：\u003c/p\u003e\n\u003ch3\u003e1. 只在最顶层使用 Hook\u003c/h3\u003e\n\u003cp\u003e不要在循环、条件或嵌套函数中调用 Hook：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e// ❌ 错误\nfunction BadComponent() {\n  if (someCondition) {\n    const [count, setCount] = useState(0);\n  }\n}\n\n// ✅ 正确\nfunction GoodComponent() {\n  const [count, setCount] = useState(0);\n  \n  if (someCondition) {\n    // 在条件中使用 state\n    return \u0026lt;div\u0026gt;{count}\u0026lt;/div\u0026gt;;\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e2. 只在 React 函数中调用 Hook\u003c/h3\u003e\n\u003cp\u003e不要在普通的 JavaScript 函数中调用 Hook：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e// ❌ 错误\nfunction handleSomething() {\n  const [count, setCount] = useState(0);\n}\n\n// ✅ 正确\nfunction MyComponent() {\n  const [count, setCount] = useState(0);\n  \n  const handleSomething = () =\u0026gt; {\n    // 在事件处理函数中使用 state\n    setCount(count + 1);\n  };\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e最佳实践\u003c/h2\u003e\n\u003ch3\u003e1. 合理组织 Hooks\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003efunction UserProfile({ userId }) {\n  // 将相关的 hooks 组织在一起\n  const [user, setUser] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  // 数据获取逻辑\n  useEffect(() =\u0026gt; {\n    fetchUser(userId)\n      .then(setUser)\n      .catch(setError)\n      .finally(() =\u0026gt; setLoading(false));\n  }, [userId]);\n\n  // 其他的 hooks...\n  const theme = useContext(ThemeContext);\n  \n  // ...\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e2. 使用自定义 Hook 抽象逻辑\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e// 将数据获取逻辑抽象到自定义 Hook\nfunction useUser(userId) {\n  const [user, setUser] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() =\u0026gt; {\n    fetchUser(userId)\n      .then(setUser)\n      .catch(setError)\n      .finally(() =\u0026gt; setLoading(false));\n  }, [userId]);\n\n  return { user, loading, error };\n}\n\n// 组件变得简洁\nfunction UserProfile({ userId }) {\n  const { user, loading, error } = useUser(userId);\n  const theme = useContext(ThemeContext);\n  \n  if (loading) return \u0026lt;Spinner /\u0026gt;;\n  if (error) return \u0026lt;ErrorMessage error={error} /\u0026gt;;\n  \n  return \u0026lt;div\u0026gt;{user.name}\u0026lt;/div\u0026gt;;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e3. 性能优化\u003c/h3\u003e\n\u003ch4\u003euseMemo\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003efunction ExpensiveComponent({ items }) {\n  const expensiveValue = useMemo(() =\u0026gt; {\n    return items.reduce((sum, item) =\u0026gt; sum + item.value, 0);\n  }, [items]);\n\n  return \u0026lt;div\u0026gt;Total: {expensiveValue}\u0026lt;/div\u0026gt;;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003euseCallback\u003c/h4\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003efunction ParentComponent() {\n  const [count, setCount] = useState(0);\n\n  const handleClick = useCallback(() =\u0026gt; {\n    console.log(\u0026#39;Button clicked\u0026#39;);\n  }, []); // 空依赖数组，函数不会重新创建\n\n  return (\n    \u0026lt;div\u0026gt;\n      \u0026lt;ChildComponent onClick={handleClick} /\u0026gt;\n      \u0026lt;button onClick={() =\u0026gt; setCount(count + 1)}\u0026gt;\n        Count: {count}\n      \u0026lt;/button\u0026gt;\n    \u0026lt;/div\u0026gt;\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e4. 错误边界和 Hooks\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003efunction useErrorHandler() {\n  const [error, setError] = useState(null);\n\n  const resetError = () =\u0026gt; setError(null);\n\n  useEffect(() =\u0026gt; {\n    if (error) {\n      throw error;\n    }\n  }, [error]);\n\n  return setError;\n}\n\n// 使用示例\nfunction MyComponent() {\n  const setError = useErrorHandler();\n\n  const handleAsyncOperation = async () =\u0026gt; {\n    try {\n      await riskyOperation();\n    } catch (err) {\n      setError(err);\n    }\n  };\n\n  return \u0026lt;button onClick={handleAsyncOperation}\u0026gt;Run Operation\u0026lt;/button\u0026gt;;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e总结\u003c/h2\u003e\n\u003cp\u003eReact Hooks 为函数组件提供了强大的能力，让我们能够：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e更好地组织代码逻辑\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e复用组件逻辑\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e简化组件结构\u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e掌握 Hooks 需要理解其工作原理和遵循使用规则。通过合理使用内置 Hooks 和创建自定义 Hooks，我们可以构建更加清晰、可维护的 React 应用。\u003c/p\u003e\n\u003cp\u003e记住这两个关键点：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e只在顶层调用 Hook\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e只在 React 函数中调用 Hook\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e这样就能充分发挥 Hooks 的威力！\u003c/p\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"children\":[[\"$\",\"$Ld\",null,{\"href\":\"/notes\",\"className\":\"back-button\",\"style\":{\"display\":\"inline-block\",\"background\":\"var(--primary-color)\",\"color\":\"white\",\"border\":\"none\",\"padding\":\"10px 20px\",\"borderRadius\":\"6px\",\"cursor\":\"pointer\",\"marginBottom\":\"20px\",\"textDecoration\":\"none\"},\"children\":[\"← 返回\",\"笔记\",\"列表\"]}],[\"$\",\"article\",null,{\"className\":\"section\",\"children\":[[\"$\",\"header\",null,{\"className\":\"article-header\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"article-title\",\"children\":\"React Hooks 完全指南\"}],[\"$\",\"div\",null,{\"className\":\"article-meta\",\"children\":[[\"$\",\"div\",null,{\"className\":\"article-meta-info\",\"children\":[[\"$\",\"span\",null,{\"className\":\"article-date\",\"children\":\"2024-01-15\"}],[\"$\",\"span\",null,{\"className\":\"article-category\",\"children\":[\"• \",\"笔记\"]}]]}],[\"$\",\"div\",null,{\"className\":\"article-tags\",\"children\":[[\"$\",\"span\",\"React\",{\"className\":\"tag\",\"children\":\"React\"}],[\"$\",\"span\",\"JavaScript\",{\"className\":\"tag\",\"children\":\"JavaScript\"}],[\"$\",\"span\",\"前端\",{\"className\":\"tag\",\"children\":\"前端\"}]]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"card markdown-content\",\"dangerouslySetInnerHTML\":{\"__html\":\"$e\"}}]]}]]}]\n"])</script><script>self.__next_f.push([1,"9:[\"$\",\"html\",null,{\"lang\":\"zh-CN\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"link\",null,{\"rel\":\"stylesheet\",\"href\":\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css\"}],[\"$\",\"link\",null,{\"rel\":\"stylesheet\",\"href\":\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css\"}]]}],[\"$\",\"body\",null,{\"children\":[\"$\",\"div\",null,{\"className\":\"app\",\"children\":[[\"$\",\"$Lf\",null,{\"siteConfig\":{\"name\":\"Rudy Yang\",\"bio\":\"JAVA | AI | WEB3\",\"social\":[{\"name\":\"github\",\"icon\":\"fab fa-github\",\"url\":\"https://github.com/suogongy\"},{\"name\":\"twitter\",\"icon\":\"fab fa-twitter\",\"url\":\"https://twitter.com/suogongy\"},{\"name\":\"email\",\"icon\":\"fas fa-envelope\",\"url\":\"mailto:haiyuan1832@163.com\"}]}}],[\"$\",\"main\",null,{\"className\":\"main-content\",\"children\":[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"React Hooks 完全指南 - Personal GitHub Page\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"全面掌握 React Hooks 的核心概念、使用方法和高级技巧\"}]]\n3:null\n"])</script></body></html>