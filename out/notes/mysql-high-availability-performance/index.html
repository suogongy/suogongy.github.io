<!DOCTYPE html><html lang="zh-CN"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/55b7a9e84b417e65.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-c81f7fd28659d64f.js"/><script src="/_next/static/chunks/fd9d1056-9f91b5e418130764.js" async=""></script><script src="/_next/static/chunks/117-ee7b0ec54963e50f.js" async=""></script><script src="/_next/static/chunks/main-app-c180f1b9030bf4f6.js" async=""></script><script src="/_next/static/chunks/972-17ea62b17795b286.js" async=""></script><script src="/_next/static/chunks/app/%5Bcategory%5D/%5Bslug%5D/page-234087874853c0eb.js" async=""></script><script src="/_next/static/chunks/app/layout-8486db2c9a537bdb.js" async=""></script><title>MySQL高可用高性能实战 - Personal GitHub Page</title><meta name="description" content="本文详细介绍MySQL高可用架构的设计原理、实现方案和性能优化实践，包括主从复制、集群部署、故障转移等核心技术。"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css"/><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body><div class="app"><header class="header "><nav class="nav-container"><a class="nav-brand" href="/"><i class="fas fa-terminal"></i>Rudy Yang</a><ul class="nav-menu"><li><a class="nav-link " href="/"><i class="fas fa-home"></i> 首页</a></li><li><a class="nav-link " href="/about/"><i class="fas fa-user"></i> 关于</a></li><li><a class="nav-link " href="/projects/"><i class="fas fa-code"></i> 项目</a></li><li><a class="nav-link " href="/notes/"><i class="fas fa-book"></i> 笔记</a></li><li><a class="nav-link " href="/articles/"><i class="fas fa-pen"></i> 随笔</a></li></ul></nav></header><main class="main-content"><div><a class="back-button" style="display:inline-block;background:var(--primary-color);color:white;border:none;padding:10px 20px;border-radius:6px;cursor:pointer;margin-bottom:20px;text-decoration:none" href="/notes/">← 返回<!-- -->笔记<!-- -->列表</a><article class="section"><header class="article-header"><h1 class="article-title">MySQL高可用高性能实战</h1><div class="article-meta"><div class="article-meta-info"><span class="article-date">2024-10-14</span><span class="article-category">• <!-- -->笔记</span></div><div class="article-tags"><span class="tag">MySQL</span><span class="tag">高可用</span><span class="tag">性能优化</span><span class="tag">数据库架构</span><span class="tag">主从复制</span></div></div></header><div class="card markdown-content"><h1>MySQL高可用高性能实战</h1>
<blockquote>
<p>构建稳定高效的MySQL架构是现代互联网应用的核心需求</p>
</blockquote>
<h2>引言</h2>
<p>在当今的互联网应用中，数据库的稳定性和性能直接影响整个系统的可用性。MySQL作为最流行的关系型数据库之一，其高可用和性能优化是每个技术团队必须掌握的核心技能。本文将详细介绍MySQL高可用架构设计和性能优化的实战经验。</p>
<h2>MySQL高可用架构概述</h2>
<h3>1. 高可用架构目标</h3>
<p><strong>可用性指标</strong></p>
<ul>
<li>99.99%可用性（年停机时间不超过52分钟）</li>
<li>99.999%可用性（年停机时间不超过5分钟）</li>
<li>快速故障检测和恢复（RTO &lt; 1分钟）</li>
<li>最小数据丢失（RPO接近0）</li>
</ul>
<p><strong>性能指标</strong></p>
<ul>
<li>高并发处理能力（万级QPS）</li>
<li>低延迟响应（P95 &lt; 100ms）</li>
<li>高吞吐量（百万级TPS）</li>
<li>线性扩展能力</li>
</ul>
<h3>2. 高可用架构模式</h3>
<p><strong>主从模式</strong></p>
<ul>
<li>一主多从的经典架构</li>
<li>读写分离，提升读性能</li>
<li>主节点故障时手动切换</li>
<li>适合中小型应用</li>
</ul>
<p><strong>双主模式</strong></p>
<ul>
<li>双主互备架构</li>
<li>支持双向数据同步</li>
<li>应用层需要处理写入冲突</li>
<li>适合跨机房部署</li>
</ul>
<p><strong>集群模式</strong></p>
<ul>
<li>基于Paxos/Raft协议的集群</li>
<li>自动故障检测和转移</li>
<li>强一致性保证</li>
<li>适合核心业务系统</li>
</ul>
<h2>主从复制架构实战</h2>
<h3>1. 传统异步复制</h3>
<p><strong>配置示例</strong>：</p>
<pre><code class="language-sql">-- 主服务器配置
[mysqld]
server-id=1
log-bin=mysql-bin
binlog-format=ROW
expire_logs_days=7
max_binlog_size=1G

-- 从服务器配置
[mysqld]
server-id=2
relay-log=mysql-relay
read-only=1
log-slave-updates=1
</code></pre>
<p><strong>复制用户创建</strong>：</p>
<pre><code class="language-sql">-- 在主服务器创建复制用户
CREATE USER &#39;repl&#39;@&#39;%&#39; IDENTIFIED BY &#39;strong_password&#39;;
GRANT REPLICATION SLAVE ON *.* TO &#39;repl&#39;@&#39;%&#39;;
FLUSH PRIVILEGES;

-- 获取主服务器状态
SHOW MASTER STATUS;
</code></pre>
<p><strong>从服务器配置</strong>：</p>
<pre><code class="language-sql">-- 配置主从复制
CHANGE MASTER TO
    MASTER_HOST=&#39;master-ip&#39;,
    MASTER_USER=&#39;repl&#39;,
    MASTER_PASSWORD=&#39;strong_password&#39;,
    MASTER_LOG_FILE=&#39;mysql-bin.000001&#39;,
    MASTER_LOG_POS=154;

START SLAVE;

-- 检查复制状态
SHOW SLAVE STATUS\G
</code></pre>
<h3>2. 半同步复制</h3>
<p><strong>安装配置</strong>：</p>
<pre><code class="language-sql">-- 安装半同步复制插件
INSTALL PLUGIN rpl_semi_sync_master SONAME &#39;semisync_master.so&#39;;
INSTALL PLUGIN rpl_semi_sync_slave SONAME &#39;semisync_slave.so&#39;;

-- 启用半同步复制
SET GLOBAL rpl_semi_sync_master_enabled = 1;
SET GLOBAL rpl_semi_sync_slave_enabled = 1;
</code></pre>
<p><strong>性能监控</strong>：</p>
<pre><code class="language-sql">-- 查看半同步状态
SHOW STATUS LIKE &#39;Rpl_semi_sync%&#39;;

-- 关键指标
-- Rpl_semi_sync_master_clients: 半同步从库数量
-- Rpl_semi_sync_master_status: 主库半同步状态
-- Rpl_semi_sync_master_avg_tx_wait_time: 平均等待时间
</code></pre>
<h3>3. GTID复制</h3>
<p><strong>GTID配置</strong>：</p>
<pre><code class="language-sql">[mysqld]
server-id=1
log-bin=mysql-bin
binlog-format=ROW
gtid-mode=ON
enforce-gtid-consistency=ON
log-slave-updates=1
</code></pre>
<p><strong>GTID复制配置</strong>：</p>
<pre><code class="language-sql">-- 基于GTID的主从复制
CHANGE MASTER TO
    MASTER_HOST=&#39;master-ip&#39;,
    MASTER_USER=&#39;repl&#39;,
    MASTER_PASSWORD=&#39;strong_password&#39;,
    MASTER_AUTO_POSITION=1;

START SLAVE;
</code></pre>
<p><strong>GTID操作</strong>：</p>
<pre><code class="language-sql">-- 查看GTID状态
SHOW GLOBAL VARIABLES LIKE &#39;gtid%&#39;;

-- 跳过错误事务
SET GTID_NEXT=&#39;UUID:NUMBER&#39;;
BEGIN; COMMIT;
SET GTID_NEXT=&#39;AUTOMATIC&#39;;
</code></pre>
<h2>MySQL集群架构</h2>
<h3>1. MySQL Group Replication</h3>
<p><strong>集群配置</strong>：</p>
<pre><code class="language-sql">-- 所有节点配置
[mysqld]
server-id=1
gtid-mode=ON
enforce-gtid-consistency=ON
master_info_repository=TABLE
relay_log_info_repository=TABLE
binlog_checksum=NONE
log_slave_updates=ON
log_bin=binlog
binlog_format=ROW

-- Group Replication配置
transaction_write_set_extraction=XXHASH64
loose-group_replication_group_name=&quot;aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa&quot;
loose-group_replication_start_on_boot=off
loose-group_replication_local_address=&quot;node1:33061&quot;
loose-group_replication_group_seeds=&quot;node1:33061,node2:33061,node3:33061&quot;
loose-group_replication_bootstrap_group=off
</code></pre>
<p><strong>启动集群</strong>：</p>
<pre><code class="language-sql">-- 在第一个节点启动集群
SET GLOBAL group_replication_bootstrap_group=ON;
START GROUP_REPLICATION;
SET GLOBAL group_replication_bootstrap_group=OFF;

-- 在其他节点加入集群
START GROUP_REPLICATION;

-- 查看集群状态
SELECT * FROM performance_schema.replication_group_members;
</code></pre>
<h3>2. InnoDB Cluster</h3>
<p><strong>部署脚本</strong>：</p>
<pre><code class="language-bash"># 安装MySQL Shell
sudo apt-get install mysql-shell

# 创建集群
mysqlsh root@localhost:3306

# 在MySQL Shell中执行
JS&gt; var cluster = dba.createCluster(&#39;myCluster&#39;);

# 添加实例
JS&gt; cluster.addInstance(&#39;root@node2:3306&#39;);
JS&gt; cluster.addInstance(&#39;root@node3:3306&#39;);

# 检查集群状态
JS&gt; cluster.status();

# 配置自动故障转移
JS&gt; cluster.setupAdminAccount(&#39;admin&#39;);
</code></pre>
<p><strong>集群监控</strong>：</p>
<pre><code class="language-sql">-- 查看集群状态
SELECT 
    MEMBER_ID,
    MEMBER_HOST,
    MEMBER_PORT,
    MEMBER_STATE,
    MEMBER_ROLE,
    MEMBER_VERSION
FROM performance_schema.replication_group_members;

-- 查看集群事务状态
SELECT 
    COUNT_TRANSACTIONS_IN_QUEUE,
    COUNT_TRANSACTIONS_CHECKED,
    COUNT_CONFLICTS_DETECTED,
    COUNT_TRANSACTIONS_ROWS_VALIDATING
FROM performance_schema.replication_group_member_stats;
</code></pre>
<h2>高可用中间件</h2>
<h3>1. MySQL Router</h3>
<p><strong>配置示例</strong>：</p>
<pre><code class="language-ini"># mysqlrouter.conf
[DEFAULT]
logging_folder=/var/log/mysqlrouter
runtime_folder=/var/run/mysqlrouter
config_folder=/etc/mysqlrouter

[logger]
level=INFO

[routing:primary]
bind_address=0.0.0.0
bind_port=6446
destinations=primary-server:3306
routing_strategy=first-available

[routing:secondary]
bind_address=0.0.0.0
bind_port=6447
destinations=secondary-server1:3306,secondary-server2:3306
routing_strategy=round-robin
</code></pre>
<p><strong>启动和监控</strong>：</p>
<pre><code class="language-bash"># 启动MySQL Router
mysqlrouter -c /etc/mysqlrouter/mysqlrouter.conf

# 检查路由状态
mysqlrouter --show-routing-status
</code></pre>
<h3>2. ProxySQL</h3>
<p><strong>配置示例</strong>：</p>
<pre><code class="language-sql">-- 插入MySQL服务器
INSERT INTO mysql_servers(hostgroup_id,hostname,port) 
VALUES (1,&#39;master-db&#39;,3306);
INSERT INTO mysql_servers(hostgroup_id,hostname,port) 
VALUES (2,&#39;slave-db1&#39;,3306);
INSERT INTO mysql_servers(hostgroup_id,hostname,port) 
VALUES (2,&#39;slave-db2&#39;,3306);

-- 配置读写分离规则
INSERT INTO mysql_query_rules(
    rule_id,active,match_pattern,destination_hostgroup,apply
) VALUES (
    1,1,&#39;^SELECT.*FOR UPDATE$&#39;,1,1
);

INSERT INTO mysql_query_rules(
    rule_id,active,match_pattern,destination_hostgroup,apply
) VALUES (
    2,1,&#39;^SELECT&#39;,2,1
);

-- 加载配置到运行时
LOAD MYSQL SERVERS TO RUNTIME;
SAVE MYSQL SERVERS TO DISK;
LOAD MYSQL QUERY RULES TO RUNTIME;
SAVE MYSQL QUERY RULES TO DISK;
</code></pre>
<h3>3. HAProxy配置</h3>
<p><strong>配置示例</strong>：</p>
<pre><code>global
    daemon
    maxconn 4096

defaults
    mode tcp
    timeout connect 5000ms
    timeout client 50000ms
    timeout server 50000ms

listen mysql-master
    bind 0.0.0.0:3306
    mode tcp
    option tcplog
    balance roundrobin
    server master1 master-db:3306 check
    server master2 backup-db:3306 check backup

listen mysql-slave
    bind 0.0.0.0:3307
    mode tcp
    option tcplog
    balance roundrobin
    server slave1 slave-db1:3306 check
    server slave2 slave-db2:3306 check
</code></pre>
<h2>故障检测和自动转移</h2>
<h3>1. MHA（Master High Availability）</h3>
<p><strong>配置文件</strong>：</p>
<pre><code class="language-perl"># /etc/masterha_default.cnf
[server default]
user=mha
password=mha_password
ssh_user=root
repl_user=repl
repl_password=repl_password
ping_interval=1

# /etc/app1.cnf
[server1]
hostname=master-db
master_binlog_dir=/var/lib/mysql
candidate_master=1

[server2]
hostname=slave-db1
master_binlog_dir=/var/lib/mysql
candidate_master=1

[server3]
hostname=slave-db2
master_binlog_dir=/var/lib/mysql
</code></pre>
<p><strong>故障转移脚本</strong>：</p>
<pre><code class="language-bash">#!/bin/bash
# masterha_manager --conf=/etc/app1.cnf

# 手动故障转移
masterha_master_switch --master_state=dead \
    --conf=/etc/app1.cnf \
    --dead_master_host=master-db \
    --new_master_host=slave-db1 \
    --ignore_last_failover

# 在线切换
masterha_master_switch --master_state=alive \
    --conf=/etc/app1.cnf \
    --orig_master_host=master-db \
    --new_master_host=slave-db1
</code></pre>
<h3>2. Orchestrator</h3>
<p><strong>配置示例</strong>：</p>
<pre><code class="language-json">{
    &quot;Debug&quot;: false,
    &quot;ListenAddress&quot;: &quot;:3000&quot;,
    &quot;MySQLTopologyUser&quot;: &quot;orchestrator&quot;,
    &quot;MySQLTopologyPassword&quot;: &quot;orch_password&quot;,
    &quot;MySQLReadUser&quot;: &quot;orchestrator&quot;,
    &quot;MySQLReadPassword&quot;: &quot;orch_password&quot;,
    &quot;MySQLInstanceUser&quot;: &quot;orchestrator&quot;,
    &quot;MySQLInstancePassword&quot;: &quot;orch_password&quot;,
    &quot;BackendDB&quot;: &quot;sqlite&quot;,
    &quot;SQLite3DataFile&quot;: &quot;/var/lib/orchestrator/orchestrator.sqlite3&quot;
}
</code></pre>
<p><strong>集群管理</strong>：</p>
<pre><code class="language-bash"># 发现集群
orchestrator -c discover -i master-db:3306

# 故障转移
orchestrator -c graceful-master-takeover -i master-db:3306

# 查看集群拓扑
orchestrator -c topology -i master-db:3306
</code></pre>
<h2>性能优化实战</h2>
<h3>1. 硬件优化</h3>
<p><strong>CPU配置</strong>：</p>
<pre><code class="language-bash"># CPU亲和性设置
taskset -c 0-3 mysqld

# CPU频率调节
cpufreq-set -g performance

# 中断亲和性
echo 0-3 &gt; /proc/irq/24/smp_affinity
</code></pre>
<p><strong>内存优化</strong>：</p>
<pre><code class="language-sql">-- InnoDB缓冲池配置
SET GLOBAL innodb_buffer_pool_size = &#39;8G&#39;;
SET GLOBAL innodb_buffer_pool_instances = 8;
SET GLOBAL innodb_old_blocks_time = 1000;

-- MyISAM键缓冲区
SET GLOBAL key_buffer_size = &#39;256M&#39;;
</code></pre>
<p><strong>存储优化</strong>：</p>
<pre><code class="language-bash"># SSD优化
echo deadline &gt; /sys/block/sda/queue/scheduler
echo 0 &gt; /sys/block/sda/queue/rotational

# 文件系统优化
mount -t ext4 -o noatime,nodiratime /dev/sda1 /mysql
</code></pre>
<h3>2. 数据库参数优化</h3>
<p><strong>InnoDB优化</strong>：</p>
<pre><code class="language-sql">-- InnoDB配置参数
SET GLOBAL innodb_flush_log_at_trx_commit = 2;
SET GLOBAL innodb_flush_method = &#39;O_DIRECT&#39;;
SET GLOBAL innodb_io_capacity = 2000;
SET GLOBAL innodb_io_capacity_max = 4000;
SET GLOBAL innodb_read_io_threads = 8;
SET GLOBAL innodb_write_io_threads = 8;
SET GLOBAL innodb_log_file_size = &#39;256M&#39;;
SET GLOBAL innodb_log_buffer_size = &#39;64M&#39;;
</code></pre>
<p><strong>连接优化</strong>：</p>
<pre><code class="language-sql">-- 连接相关参数
SET GLOBAL max_connections = 2000;
SET GLOBAL max_connect_errors = 10000;
SET GLOBAL connect_timeout = 10;
SET GLOBAL wait_timeout = 28800;
SET GLOBAL interactive_timeout = 28800;
</code></pre>
<p><strong>查询优化</strong>：</p>
<pre><code class="language-sql">-- 查询缓存（MySQL 5.7及以下）
SET GLOBAL query_cache_size = &#39;256M&#39;;
SET GLOBAL query_cache_type = ON;

-- 查询优化器
SET GLOBAL optimizer_switch = &#39;index_merge=on,index_merge_union=on,index_merge_sort_union=on&#39;;
</code></pre>
<h3>3. SQL优化</h3>
<p><strong>索引优化</strong>：</p>
<pre><code class="language-sql">-- 创建复合索引
CREATE INDEX idx_user_status ON users(status, created_at);

-- 分析索引使用情况
EXPLAIN SELECT * FROM users WHERE status = 1 ORDER BY created_at;

-- 删除无用索引
DROP INDEX idx_unused ON table_name;
</code></pre>
<p><strong>查询优化</strong>：</p>
<pre><code class="language-sql">-- 避免全表扫描
SELECT id, name FROM users WHERE status = 1 LIMIT 100;

-- 使用覆盖索引
SELECT id, status FROM users WHERE status = 1;

-- 批量插入优化
INSERT INTO orders (user_id, amount, created_at) VALUES 
    (1, 100, NOW()),
    (2, 200, NOW()),
    (3, 300, NOW());
</code></pre>
<p><strong>分页优化</strong>：</p>
<pre><code class="language-sql">-- 传统分页（性能较差）
SELECT * FROM orders ORDER BY id LIMIT 10000, 20;

-- 优化分页（使用书签）
SELECT * FROM orders WHERE id &gt; 10000 ORDER BY id LIMIT 20;

-- 复杂分页优化
SELECT o.* FROM orders o
INNER JOIN (SELECT id FROM orders ORDER BY id LIMIT 10000, 20) t ON o.id = t.id;
</code></pre>
<h2>监控和告警</h2>
<h3>1. 性能监控</h3>
<p><strong>关键指标监控</strong>：</p>
<pre><code class="language-sql">-- QPS和TPS
SHOW GLOBAL STATUS LIKE &#39;Com_%&#39;;
SHOW GLOBAL STATUS LIKE &#39;Questions&#39;;
SHOW GLOBAL STATUS LIKE &#39;Uptime&#39;;

-- 连接数
SHOW GLOBAL STATUS LIKE &#39;Threads%&#39;;
SHOW GLOBAL STATUS LIKE &#39;Max_used_connections&#39;;

-- 慢查询
SHOW GLOBAL STATUS LIKE &#39;Slow_queries&#39;;
SELECT * FROM mysql.slow_log ORDER BY start_time DESC LIMIT 10;
</code></pre>
<p><strong>InnoDB监控</strong>：</p>
<pre><code class="language-sql">-- InnoDB状态
SHOW ENGINE INNODB STATUS;

-- InnoDB指标
SHOW GLOBAL STATUS LIKE &#39;Innodb%&#39;;

-- 锁等待
SELECT * FROM sys.innodb_lock_waits;
</code></pre>
<h3>2. Prometheus监控</h3>
<p><strong>MySQL Exporter配置</strong>：</p>
<pre><code class="language-yaml"># prometheus.yml
global:
  scrape_interval: 15s

scrape_configs:
  - job_name: &#39;mysql&#39;
    static_configs:
      - targets: [&#39;mysql-exporter:9104&#39;]
</code></pre>
<p><strong>关键告警规则</strong>：</p>
<pre><code class="language-yaml"># mysql_alerts.yml
groups:
  - name: mysql
    rules:
      - alert: MySQLDown
        expr: mysql_up == 0
        for: 1m
        labels:
          severity: critical
        annotations:
          summary: &quot;MySQL instance is down&quot;
          
      - alert: MySQLTooManyConnections
        expr: mysql_global_status_threads_connected / mysql_global_variables_max_connections &gt; 0.8
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: &quot;MySQL has too many connections&quot;
</code></pre>
<h3>3. 日志分析</h3>
<p><strong>慢查询日志分析</strong>：</p>
<pre><code class="language-bash"># 启用慢查询日志
SET GLOBAL slow_query_log = &#39;ON&#39;;
SET GLOBAL long_query_time = 1;
SET GLOBAL slow_query_log_file = &#39;/var/log/mysql/slow.log&#39;;

# 使用pt-query-digest分析
pt-query-digest /var/log/mysql/slow.log

# 输出报告示例
# # Profile
# # Rank Query ID           Response time   Calls   R/Call   V/M   Item
# # ==== ================== ============== ======= ========= ===== ===============
# #    1 0xF9A57DD5A41847CA  2.5119  38%    1000   0.002512  0.10 SELECT users
</code></pre>
<h2>备份和恢复</h2>
<h3>1. 逻辑备份</h3>
<p><strong>mysqldump备份</strong>：</p>
<pre><code class="language-bash"># 全量备份
mysqldump -u root -p --single-transaction --routines --triggers --all-databases &gt; full_backup.sql

# 增量备份（基于binlog）
mysqlbinlog --start-datetime=&quot;2024-01-01 00:00:00&quot; --stop-datetime=&quot;2024-01-02 00:00:00&quot; mysql-bin.000001 &gt; incremental_backup.sql

# 恢复数据
mysql -u root -p &lt; full_backup.sql
mysql -u root -p &lt; incremental_backup.sql
</code></pre>
<h3>2. 物理备份</h3>
<p><strong>XtraBackup备份</strong>：</p>
<pre><code class="language-bash"># 全量备份
xtrabackup --backup --target-dir=/backup/full --user=backup --password=backup_password

# 增量备份
xtrabackup --backup --target-dir=/backup/inc1 --incremental-basedir=/backup/full --user=backup --password=backup_password

# 准备备份
xtrabackup --prepare --target-dir=/backup/full
xtrabackup --prepare --target-dir=/backup/full --incremental-dir=/backup/inc1

# 恢复备份
xtrabackup --copy-back --target-dir=/backup/full
</code></pre>
<h3>3. 自动化备份脚本</h3>
<p><strong>备份脚本示例</strong>：</p>
<pre><code class="language-bash">#!/bin/bash
# backup_mysql.sh

BACKUP_DIR=&quot;/backup/mysql&quot;
DATE=$(date +%Y%m%d_%H%M%S)
DB_USER=&quot;backup&quot;
DB_PASS=&quot;backup_password&quot;
RETENTION_DAYS=7

# 创建备份目录
mkdir -p $BACKUP_DIR/$DATE

# 全量备份
xtrabackup --backup --target-dir=$BACKUP_DIR/$DATE/full --user=$DB_USER --password=$DB_PASS

# 删除过期备份
find $BACKUP_DIR -type d -mtime +$RETENTION_DAYS -exec rm -rf {} \;

# 上传到云存储
aws s3 sync $BACKUP_DIR/$DATE s3://mysql-backup-bucket/$DATE
</code></pre>
<h2>总结</h2>
<p>构建MySQL高可用高性能架构需要综合考虑多个方面：</p>
<ol>
<li><strong>架构选择</strong>：根据业务需求选择合适的高可用架构</li>
<li><strong>性能优化</strong>：从硬件、参数、SQL等多个层面进行优化</li>
<li><strong>监控告警</strong>：建立完善的监控体系和告警机制</li>
<li><strong>备份恢复</strong>：制定可靠的备份策略和恢复方案</li>
<li><strong>运维管理</strong>：建立标准化的运维流程和工具链</li>
</ol>
<p>通过合理的架构设计和持续的优化改进，可以构建出稳定、高效、可扩展的MySQL数据库系统，为业务发展提供坚实的数据支撑。</p>
</div></article></div></main></div><script src="/_next/static/chunks/webpack-c81f7fd28659d64f.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/55b7a9e84b417e65.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"2:I[2846,[],\"\"]\n5:I[4707,[],\"\"]\n8:I[6423,[],\"\"]\nb:I[1060,[],\"\"]\n6:[\"category\",\"notes\",\"d\"]\n7:[\"slug\",\"mysql-high-availability-performance\",\"d\"]\nc:[]\n0:[\"$\",\"$L2\",null,{\"buildId\":\"build\",\"assetPrefix\":\"\",\"urlParts\":[\"\",\"notes\",\"mysql-high-availability-performance\",\"\"],\"initialTree\":[\"\",{\"children\":[[\"category\",\"notes\",\"d\"],{\"children\":[[\"slug\",\"mysql-high-availability-performance\",\"d\"],{\"children\":[\"__PAGE__?{\\\"category\\\":\\\"notes\\\",\\\"slug\\\":\\\"mysql-high-availability-performance\\\"}\",{}]}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"category\",\"notes\",\"d\"],{\"children\":[[\"slug\",\"mysql-high-availability-performance\",\"d\"],{\"children\":[\"__PAGE__\",{},[[\"$L3\",\"$L4\",null],null],null]},[null,[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$6\",\"children\",\"$7\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}]],null]},[null,[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$6\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}]],null]},[[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/55b7a9e84b417e65.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],\"$L9\"],null],null],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$La\"],\"globalErrorComponent\":\"$b\",\"missingSlots\":\"$Wc\"}]\n"])</script><script>self.__next_f.push([1,"d:I[2972,[\"972\",\"static/chunks/972-17ea62b17795b286.js\",\"621\",\"static/chunks/app/%5Bcategory%5D/%5Bslug%5D/page-234087874853c0eb.js\"],\"\"]\nf:I[7140,[\"972\",\"static/chunks/972-17ea62b17795b286.js\",\"185\",\"static/chunks/app/layout-8486db2c9a537bdb.js\"],\"default\"]\ne:T488d,"])</script><script>self.__next_f.push([1,"\u003ch1\u003eMySQL高可用高性能实战\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e构建稳定高效的MySQL架构是现代互联网应用的核心需求\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003e引言\u003c/h2\u003e\n\u003cp\u003e在当今的互联网应用中，数据库的稳定性和性能直接影响整个系统的可用性。MySQL作为最流行的关系型数据库之一，其高可用和性能优化是每个技术团队必须掌握的核心技能。本文将详细介绍MySQL高可用架构设计和性能优化的实战经验。\u003c/p\u003e\n\u003ch2\u003eMySQL高可用架构概述\u003c/h2\u003e\n\u003ch3\u003e1. 高可用架构目标\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e可用性指标\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e99.99%可用性（年停机时间不超过52分钟）\u003c/li\u003e\n\u003cli\u003e99.999%可用性（年停机时间不超过5分钟）\u003c/li\u003e\n\u003cli\u003e快速故障检测和恢复（RTO \u0026lt; 1分钟）\u003c/li\u003e\n\u003cli\u003e最小数据丢失（RPO接近0）\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e性能指标\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e高并发处理能力（万级QPS）\u003c/li\u003e\n\u003cli\u003e低延迟响应（P95 \u0026lt; 100ms）\u003c/li\u003e\n\u003cli\u003e高吞吐量（百万级TPS）\u003c/li\u003e\n\u003cli\u003e线性扩展能力\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e2. 高可用架构模式\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e主从模式\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e一主多从的经典架构\u003c/li\u003e\n\u003cli\u003e读写分离，提升读性能\u003c/li\u003e\n\u003cli\u003e主节点故障时手动切换\u003c/li\u003e\n\u003cli\u003e适合中小型应用\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e双主模式\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e双主互备架构\u003c/li\u003e\n\u003cli\u003e支持双向数据同步\u003c/li\u003e\n\u003cli\u003e应用层需要处理写入冲突\u003c/li\u003e\n\u003cli\u003e适合跨机房部署\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e集群模式\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e基于Paxos/Raft协议的集群\u003c/li\u003e\n\u003cli\u003e自动故障检测和转移\u003c/li\u003e\n\u003cli\u003e强一致性保证\u003c/li\u003e\n\u003cli\u003e适合核心业务系统\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e主从复制架构实战\u003c/h2\u003e\n\u003ch3\u003e1. 传统异步复制\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e配置示例\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003e-- 主服务器配置\n[mysqld]\nserver-id=1\nlog-bin=mysql-bin\nbinlog-format=ROW\nexpire_logs_days=7\nmax_binlog_size=1G\n\n-- 从服务器配置\n[mysqld]\nserver-id=2\nrelay-log=mysql-relay\nread-only=1\nlog-slave-updates=1\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e复制用户创建\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003e-- 在主服务器创建复制用户\nCREATE USER \u0026#39;repl\u0026#39;@\u0026#39;%\u0026#39; IDENTIFIED BY \u0026#39;strong_password\u0026#39;;\nGRANT REPLICATION SLAVE ON *.* TO \u0026#39;repl\u0026#39;@\u0026#39;%\u0026#39;;\nFLUSH PRIVILEGES;\n\n-- 获取主服务器状态\nSHOW MASTER STATUS;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e从服务器配置\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003e-- 配置主从复制\nCHANGE MASTER TO\n    MASTER_HOST=\u0026#39;master-ip\u0026#39;,\n    MASTER_USER=\u0026#39;repl\u0026#39;,\n    MASTER_PASSWORD=\u0026#39;strong_password\u0026#39;,\n    MASTER_LOG_FILE=\u0026#39;mysql-bin.000001\u0026#39;,\n    MASTER_LOG_POS=154;\n\nSTART SLAVE;\n\n-- 检查复制状态\nSHOW SLAVE STATUS\\G\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e2. 半同步复制\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e安装配置\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003e-- 安装半同步复制插件\nINSTALL PLUGIN rpl_semi_sync_master SONAME \u0026#39;semisync_master.so\u0026#39;;\nINSTALL PLUGIN rpl_semi_sync_slave SONAME \u0026#39;semisync_slave.so\u0026#39;;\n\n-- 启用半同步复制\nSET GLOBAL rpl_semi_sync_master_enabled = 1;\nSET GLOBAL rpl_semi_sync_slave_enabled = 1;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e性能监控\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003e-- 查看半同步状态\nSHOW STATUS LIKE \u0026#39;Rpl_semi_sync%\u0026#39;;\n\n-- 关键指标\n-- Rpl_semi_sync_master_clients: 半同步从库数量\n-- Rpl_semi_sync_master_status: 主库半同步状态\n-- Rpl_semi_sync_master_avg_tx_wait_time: 平均等待时间\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e3. GTID复制\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eGTID配置\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003e[mysqld]\nserver-id=1\nlog-bin=mysql-bin\nbinlog-format=ROW\ngtid-mode=ON\nenforce-gtid-consistency=ON\nlog-slave-updates=1\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eGTID复制配置\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003e-- 基于GTID的主从复制\nCHANGE MASTER TO\n    MASTER_HOST=\u0026#39;master-ip\u0026#39;,\n    MASTER_USER=\u0026#39;repl\u0026#39;,\n    MASTER_PASSWORD=\u0026#39;strong_password\u0026#39;,\n    MASTER_AUTO_POSITION=1;\n\nSTART SLAVE;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eGTID操作\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003e-- 查看GTID状态\nSHOW GLOBAL VARIABLES LIKE \u0026#39;gtid%\u0026#39;;\n\n-- 跳过错误事务\nSET GTID_NEXT=\u0026#39;UUID:NUMBER\u0026#39;;\nBEGIN; COMMIT;\nSET GTID_NEXT=\u0026#39;AUTOMATIC\u0026#39;;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eMySQL集群架构\u003c/h2\u003e\n\u003ch3\u003e1. MySQL Group Replication\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e集群配置\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003e-- 所有节点配置\n[mysqld]\nserver-id=1\ngtid-mode=ON\nenforce-gtid-consistency=ON\nmaster_info_repository=TABLE\nrelay_log_info_repository=TABLE\nbinlog_checksum=NONE\nlog_slave_updates=ON\nlog_bin=binlog\nbinlog_format=ROW\n\n-- Group Replication配置\ntransaction_write_set_extraction=XXHASH64\nloose-group_replication_group_name=\u0026quot;aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa\u0026quot;\nloose-group_replication_start_on_boot=off\nloose-group_replication_local_address=\u0026quot;node1:33061\u0026quot;\nloose-group_replication_group_seeds=\u0026quot;node1:33061,node2:33061,node3:33061\u0026quot;\nloose-group_replication_bootstrap_group=off\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e启动集群\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003e-- 在第一个节点启动集群\nSET GLOBAL group_replication_bootstrap_group=ON;\nSTART GROUP_REPLICATION;\nSET GLOBAL group_replication_bootstrap_group=OFF;\n\n-- 在其他节点加入集群\nSTART GROUP_REPLICATION;\n\n-- 查看集群状态\nSELECT * FROM performance_schema.replication_group_members;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e2. InnoDB Cluster\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e部署脚本\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 安装MySQL Shell\nsudo apt-get install mysql-shell\n\n# 创建集群\nmysqlsh root@localhost:3306\n\n# 在MySQL Shell中执行\nJS\u0026gt; var cluster = dba.createCluster(\u0026#39;myCluster\u0026#39;);\n\n# 添加实例\nJS\u0026gt; cluster.addInstance(\u0026#39;root@node2:3306\u0026#39;);\nJS\u0026gt; cluster.addInstance(\u0026#39;root@node3:3306\u0026#39;);\n\n# 检查集群状态\nJS\u0026gt; cluster.status();\n\n# 配置自动故障转移\nJS\u0026gt; cluster.setupAdminAccount(\u0026#39;admin\u0026#39;);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e集群监控\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003e-- 查看集群状态\nSELECT \n    MEMBER_ID,\n    MEMBER_HOST,\n    MEMBER_PORT,\n    MEMBER_STATE,\n    MEMBER_ROLE,\n    MEMBER_VERSION\nFROM performance_schema.replication_group_members;\n\n-- 查看集群事务状态\nSELECT \n    COUNT_TRANSACTIONS_IN_QUEUE,\n    COUNT_TRANSACTIONS_CHECKED,\n    COUNT_CONFLICTS_DETECTED,\n    COUNT_TRANSACTIONS_ROWS_VALIDATING\nFROM performance_schema.replication_group_member_stats;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e高可用中间件\u003c/h2\u003e\n\u003ch3\u003e1. MySQL Router\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e配置示例\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-ini\"\u003e# mysqlrouter.conf\n[DEFAULT]\nlogging_folder=/var/log/mysqlrouter\nruntime_folder=/var/run/mysqlrouter\nconfig_folder=/etc/mysqlrouter\n\n[logger]\nlevel=INFO\n\n[routing:primary]\nbind_address=0.0.0.0\nbind_port=6446\ndestinations=primary-server:3306\nrouting_strategy=first-available\n\n[routing:secondary]\nbind_address=0.0.0.0\nbind_port=6447\ndestinations=secondary-server1:3306,secondary-server2:3306\nrouting_strategy=round-robin\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e启动和监控\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 启动MySQL Router\nmysqlrouter -c /etc/mysqlrouter/mysqlrouter.conf\n\n# 检查路由状态\nmysqlrouter --show-routing-status\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e2. ProxySQL\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e配置示例\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003e-- 插入MySQL服务器\nINSERT INTO mysql_servers(hostgroup_id,hostname,port) \nVALUES (1,\u0026#39;master-db\u0026#39;,3306);\nINSERT INTO mysql_servers(hostgroup_id,hostname,port) \nVALUES (2,\u0026#39;slave-db1\u0026#39;,3306);\nINSERT INTO mysql_servers(hostgroup_id,hostname,port) \nVALUES (2,\u0026#39;slave-db2\u0026#39;,3306);\n\n-- 配置读写分离规则\nINSERT INTO mysql_query_rules(\n    rule_id,active,match_pattern,destination_hostgroup,apply\n) VALUES (\n    1,1,\u0026#39;^SELECT.*FOR UPDATE$\u0026#39;,1,1\n);\n\nINSERT INTO mysql_query_rules(\n    rule_id,active,match_pattern,destination_hostgroup,apply\n) VALUES (\n    2,1,\u0026#39;^SELECT\u0026#39;,2,1\n);\n\n-- 加载配置到运行时\nLOAD MYSQL SERVERS TO RUNTIME;\nSAVE MYSQL SERVERS TO DISK;\nLOAD MYSQL QUERY RULES TO RUNTIME;\nSAVE MYSQL QUERY RULES TO DISK;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e3. HAProxy配置\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e配置示例\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eglobal\n    daemon\n    maxconn 4096\n\ndefaults\n    mode tcp\n    timeout connect 5000ms\n    timeout client 50000ms\n    timeout server 50000ms\n\nlisten mysql-master\n    bind 0.0.0.0:3306\n    mode tcp\n    option tcplog\n    balance roundrobin\n    server master1 master-db:3306 check\n    server master2 backup-db:3306 check backup\n\nlisten mysql-slave\n    bind 0.0.0.0:3307\n    mode tcp\n    option tcplog\n    balance roundrobin\n    server slave1 slave-db1:3306 check\n    server slave2 slave-db2:3306 check\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e故障检测和自动转移\u003c/h2\u003e\n\u003ch3\u003e1. MHA（Master High Availability）\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e配置文件\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-perl\"\u003e# /etc/masterha_default.cnf\n[server default]\nuser=mha\npassword=mha_password\nssh_user=root\nrepl_user=repl\nrepl_password=repl_password\nping_interval=1\n\n# /etc/app1.cnf\n[server1]\nhostname=master-db\nmaster_binlog_dir=/var/lib/mysql\ncandidate_master=1\n\n[server2]\nhostname=slave-db1\nmaster_binlog_dir=/var/lib/mysql\ncandidate_master=1\n\n[server3]\nhostname=slave-db2\nmaster_binlog_dir=/var/lib/mysql\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e故障转移脚本\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e#!/bin/bash\n# masterha_manager --conf=/etc/app1.cnf\n\n# 手动故障转移\nmasterha_master_switch --master_state=dead \\\n    --conf=/etc/app1.cnf \\\n    --dead_master_host=master-db \\\n    --new_master_host=slave-db1 \\\n    --ignore_last_failover\n\n# 在线切换\nmasterha_master_switch --master_state=alive \\\n    --conf=/etc/app1.cnf \\\n    --orig_master_host=master-db \\\n    --new_master_host=slave-db1\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e2. Orchestrator\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e配置示例\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-json\"\u003e{\n    \u0026quot;Debug\u0026quot;: false,\n    \u0026quot;ListenAddress\u0026quot;: \u0026quot;:3000\u0026quot;,\n    \u0026quot;MySQLTopologyUser\u0026quot;: \u0026quot;orchestrator\u0026quot;,\n    \u0026quot;MySQLTopologyPassword\u0026quot;: \u0026quot;orch_password\u0026quot;,\n    \u0026quot;MySQLReadUser\u0026quot;: \u0026quot;orchestrator\u0026quot;,\n    \u0026quot;MySQLReadPassword\u0026quot;: \u0026quot;orch_password\u0026quot;,\n    \u0026quot;MySQLInstanceUser\u0026quot;: \u0026quot;orchestrator\u0026quot;,\n    \u0026quot;MySQLInstancePassword\u0026quot;: \u0026quot;orch_password\u0026quot;,\n    \u0026quot;BackendDB\u0026quot;: \u0026quot;sqlite\u0026quot;,\n    \u0026quot;SQLite3DataFile\u0026quot;: \u0026quot;/var/lib/orchestrator/orchestrator.sqlite3\u0026quot;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e集群管理\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 发现集群\norchestrator -c discover -i master-db:3306\n\n# 故障转移\norchestrator -c graceful-master-takeover -i master-db:3306\n\n# 查看集群拓扑\norchestrator -c topology -i master-db:3306\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e性能优化实战\u003c/h2\u003e\n\u003ch3\u003e1. 硬件优化\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eCPU配置\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# CPU亲和性设置\ntaskset -c 0-3 mysqld\n\n# CPU频率调节\ncpufreq-set -g performance\n\n# 中断亲和性\necho 0-3 \u0026gt; /proc/irq/24/smp_affinity\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e内存优化\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003e-- InnoDB缓冲池配置\nSET GLOBAL innodb_buffer_pool_size = \u0026#39;8G\u0026#39;;\nSET GLOBAL innodb_buffer_pool_instances = 8;\nSET GLOBAL innodb_old_blocks_time = 1000;\n\n-- MyISAM键缓冲区\nSET GLOBAL key_buffer_size = \u0026#39;256M\u0026#39;;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e存储优化\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# SSD优化\necho deadline \u0026gt; /sys/block/sda/queue/scheduler\necho 0 \u0026gt; /sys/block/sda/queue/rotational\n\n# 文件系统优化\nmount -t ext4 -o noatime,nodiratime /dev/sda1 /mysql\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e2. 数据库参数优化\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eInnoDB优化\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003e-- InnoDB配置参数\nSET GLOBAL innodb_flush_log_at_trx_commit = 2;\nSET GLOBAL innodb_flush_method = \u0026#39;O_DIRECT\u0026#39;;\nSET GLOBAL innodb_io_capacity = 2000;\nSET GLOBAL innodb_io_capacity_max = 4000;\nSET GLOBAL innodb_read_io_threads = 8;\nSET GLOBAL innodb_write_io_threads = 8;\nSET GLOBAL innodb_log_file_size = \u0026#39;256M\u0026#39;;\nSET GLOBAL innodb_log_buffer_size = \u0026#39;64M\u0026#39;;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e连接优化\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003e-- 连接相关参数\nSET GLOBAL max_connections = 2000;\nSET GLOBAL max_connect_errors = 10000;\nSET GLOBAL connect_timeout = 10;\nSET GLOBAL wait_timeout = 28800;\nSET GLOBAL interactive_timeout = 28800;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e查询优化\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003e-- 查询缓存（MySQL 5.7及以下）\nSET GLOBAL query_cache_size = \u0026#39;256M\u0026#39;;\nSET GLOBAL query_cache_type = ON;\n\n-- 查询优化器\nSET GLOBAL optimizer_switch = \u0026#39;index_merge=on,index_merge_union=on,index_merge_sort_union=on\u0026#39;;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e3. SQL优化\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e索引优化\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003e-- 创建复合索引\nCREATE INDEX idx_user_status ON users(status, created_at);\n\n-- 分析索引使用情况\nEXPLAIN SELECT * FROM users WHERE status = 1 ORDER BY created_at;\n\n-- 删除无用索引\nDROP INDEX idx_unused ON table_name;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e查询优化\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003e-- 避免全表扫描\nSELECT id, name FROM users WHERE status = 1 LIMIT 100;\n\n-- 使用覆盖索引\nSELECT id, status FROM users WHERE status = 1;\n\n-- 批量插入优化\nINSERT INTO orders (user_id, amount, created_at) VALUES \n    (1, 100, NOW()),\n    (2, 200, NOW()),\n    (3, 300, NOW());\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e分页优化\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003e-- 传统分页（性能较差）\nSELECT * FROM orders ORDER BY id LIMIT 10000, 20;\n\n-- 优化分页（使用书签）\nSELECT * FROM orders WHERE id \u0026gt; 10000 ORDER BY id LIMIT 20;\n\n-- 复杂分页优化\nSELECT o.* FROM orders o\nINNER JOIN (SELECT id FROM orders ORDER BY id LIMIT 10000, 20) t ON o.id = t.id;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e监控和告警\u003c/h2\u003e\n\u003ch3\u003e1. 性能监控\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e关键指标监控\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003e-- QPS和TPS\nSHOW GLOBAL STATUS LIKE \u0026#39;Com_%\u0026#39;;\nSHOW GLOBAL STATUS LIKE \u0026#39;Questions\u0026#39;;\nSHOW GLOBAL STATUS LIKE \u0026#39;Uptime\u0026#39;;\n\n-- 连接数\nSHOW GLOBAL STATUS LIKE \u0026#39;Threads%\u0026#39;;\nSHOW GLOBAL STATUS LIKE \u0026#39;Max_used_connections\u0026#39;;\n\n-- 慢查询\nSHOW GLOBAL STATUS LIKE \u0026#39;Slow_queries\u0026#39;;\nSELECT * FROM mysql.slow_log ORDER BY start_time DESC LIMIT 10;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eInnoDB监控\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sql\"\u003e-- InnoDB状态\nSHOW ENGINE INNODB STATUS;\n\n-- InnoDB指标\nSHOW GLOBAL STATUS LIKE \u0026#39;Innodb%\u0026#39;;\n\n-- 锁等待\nSELECT * FROM sys.innodb_lock_waits;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e2. Prometheus监控\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eMySQL Exporter配置\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-yaml\"\u003e# prometheus.yml\nglobal:\n  scrape_interval: 15s\n\nscrape_configs:\n  - job_name: \u0026#39;mysql\u0026#39;\n    static_configs:\n      - targets: [\u0026#39;mysql-exporter:9104\u0026#39;]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e关键告警规则\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-yaml\"\u003e# mysql_alerts.yml\ngroups:\n  - name: mysql\n    rules:\n      - alert: MySQLDown\n        expr: mysql_up == 0\n        for: 1m\n        labels:\n          severity: critical\n        annotations:\n          summary: \u0026quot;MySQL instance is down\u0026quot;\n          \n      - alert: MySQLTooManyConnections\n        expr: mysql_global_status_threads_connected / mysql_global_variables_max_connections \u0026gt; 0.8\n        for: 5m\n        labels:\n          severity: warning\n        annotations:\n          summary: \u0026quot;MySQL has too many connections\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e3. 日志分析\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e慢查询日志分析\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 启用慢查询日志\nSET GLOBAL slow_query_log = \u0026#39;ON\u0026#39;;\nSET GLOBAL long_query_time = 1;\nSET GLOBAL slow_query_log_file = \u0026#39;/var/log/mysql/slow.log\u0026#39;;\n\n# 使用pt-query-digest分析\npt-query-digest /var/log/mysql/slow.log\n\n# 输出报告示例\n# # Profile\n# # Rank Query ID           Response time   Calls   R/Call   V/M   Item\n# # ==== ================== ============== ======= ========= ===== ===============\n# #    1 0xF9A57DD5A41847CA  2.5119  38%    1000   0.002512  0.10 SELECT users\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e备份和恢复\u003c/h2\u003e\n\u003ch3\u003e1. 逻辑备份\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003emysqldump备份\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 全量备份\nmysqldump -u root -p --single-transaction --routines --triggers --all-databases \u0026gt; full_backup.sql\n\n# 增量备份（基于binlog）\nmysqlbinlog --start-datetime=\u0026quot;2024-01-01 00:00:00\u0026quot; --stop-datetime=\u0026quot;2024-01-02 00:00:00\u0026quot; mysql-bin.000001 \u0026gt; incremental_backup.sql\n\n# 恢复数据\nmysql -u root -p \u0026lt; full_backup.sql\nmysql -u root -p \u0026lt; incremental_backup.sql\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e2. 物理备份\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eXtraBackup备份\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 全量备份\nxtrabackup --backup --target-dir=/backup/full --user=backup --password=backup_password\n\n# 增量备份\nxtrabackup --backup --target-dir=/backup/inc1 --incremental-basedir=/backup/full --user=backup --password=backup_password\n\n# 准备备份\nxtrabackup --prepare --target-dir=/backup/full\nxtrabackup --prepare --target-dir=/backup/full --incremental-dir=/backup/inc1\n\n# 恢复备份\nxtrabackup --copy-back --target-dir=/backup/full\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e3. 自动化备份脚本\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e备份脚本示例\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e#!/bin/bash\n# backup_mysql.sh\n\nBACKUP_DIR=\u0026quot;/backup/mysql\u0026quot;\nDATE=$(date +%Y%m%d_%H%M%S)\nDB_USER=\u0026quot;backup\u0026quot;\nDB_PASS=\u0026quot;backup_password\u0026quot;\nRETENTION_DAYS=7\n\n# 创建备份目录\nmkdir -p $BACKUP_DIR/$DATE\n\n# 全量备份\nxtrabackup --backup --target-dir=$BACKUP_DIR/$DATE/full --user=$DB_USER --password=$DB_PASS\n\n# 删除过期备份\nfind $BACKUP_DIR -type d -mtime +$RETENTION_DAYS -exec rm -rf {} \\;\n\n# 上传到云存储\naws s3 sync $BACKUP_DIR/$DATE s3://mysql-backup-bucket/$DATE\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e总结\u003c/h2\u003e\n\u003cp\u003e构建MySQL高可用高性能架构需要综合考虑多个方面：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e架构选择\u003c/strong\u003e：根据业务需求选择合适的高可用架构\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e性能优化\u003c/strong\u003e：从硬件、参数、SQL等多个层面进行优化\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e监控告警\u003c/strong\u003e：建立完善的监控体系和告警机制\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e备份恢复\u003c/strong\u003e：制定可靠的备份策略和恢复方案\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e运维管理\u003c/strong\u003e：建立标准化的运维流程和工具链\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e通过合理的架构设计和持续的优化改进，可以构建出稳定、高效、可扩展的MySQL数据库系统，为业务发展提供坚实的数据支撑。\u003c/p\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"children\":[[\"$\",\"$Ld\",null,{\"href\":\"/notes\",\"className\":\"back-button\",\"style\":{\"display\":\"inline-block\",\"background\":\"var(--primary-color)\",\"color\":\"white\",\"border\":\"none\",\"padding\":\"10px 20px\",\"borderRadius\":\"6px\",\"cursor\":\"pointer\",\"marginBottom\":\"20px\",\"textDecoration\":\"none\"},\"children\":[\"← 返回\",\"笔记\",\"列表\"]}],[\"$\",\"article\",null,{\"className\":\"section\",\"children\":[[\"$\",\"header\",null,{\"className\":\"article-header\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"article-title\",\"children\":\"MySQL高可用高性能实战\"}],[\"$\",\"div\",null,{\"className\":\"article-meta\",\"children\":[[\"$\",\"div\",null,{\"className\":\"article-meta-info\",\"children\":[[\"$\",\"span\",null,{\"className\":\"article-date\",\"children\":\"2024-10-14\"}],[\"$\",\"span\",null,{\"className\":\"article-category\",\"children\":[\"• \",\"笔记\"]}]]}],[\"$\",\"div\",null,{\"className\":\"article-tags\",\"children\":[[\"$\",\"span\",\"MySQL\",{\"className\":\"tag\",\"children\":\"MySQL\"}],[\"$\",\"span\",\"高可用\",{\"className\":\"tag\",\"children\":\"高可用\"}],[\"$\",\"span\",\"性能优化\",{\"className\":\"tag\",\"children\":\"性能优化\"}],[\"$\",\"span\",\"数据库架构\",{\"className\":\"tag\",\"children\":\"数据库架构\"}],[\"$\",\"span\",\"主从复制\",{\"className\":\"tag\",\"children\":\"主从复制\"}]]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"card markdown-content\",\"dangerouslySetInnerHTML\":{\"__html\":\"$e\"}}]]}]]}]\n"])</script><script>self.__next_f.push([1,"9:[\"$\",\"html\",null,{\"lang\":\"zh-CN\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"link\",null,{\"rel\":\"stylesheet\",\"href\":\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css\"}],[\"$\",\"link\",null,{\"rel\":\"stylesheet\",\"href\":\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css\"}]]}],[\"$\",\"body\",null,{\"children\":[\"$\",\"div\",null,{\"className\":\"app\",\"children\":[[\"$\",\"$Lf\",null,{\"siteConfig\":{\"name\":\"Rudy Yang\",\"bio\":\"JAVA | AI | WEB3\",\"social\":[{\"name\":\"github\",\"icon\":\"fab fa-github\",\"url\":\"https://github.com/suogongy\"},{\"name\":\"twitter\",\"icon\":\"fab fa-twitter\",\"url\":\"https://twitter.com/suogongy\"},{\"name\":\"email\",\"icon\":\"fas fa-envelope\",\"url\":\"mailto:haiyuan1832@163.com\"}]}}],[\"$\",\"main\",null,{\"className\":\"main-content\",\"children\":[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"MySQL高可用高性能实战 - Personal GitHub Page\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"本文详细介绍MySQL高可用架构的设计原理、实现方案和性能优化实践，包括主从复制、集群部署、故障转移等核心技术。\"}]]\n3:null\n"])</script></body></html>