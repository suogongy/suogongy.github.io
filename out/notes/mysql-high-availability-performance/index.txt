3:I[4707,[],""]
6:I[6423,[],""]
4:["category","notes","d"]
5:["slug","mysql-high-availability-performance","d"]
0:["build",[[["",{"children":[["category","notes","d"],{"children":[["slug","mysql-high-availability-performance","d"],{"children":["__PAGE__?{\"category\":\"notes\",\"slug\":\"mysql-high-availability-performance\"}",{}]}]}]},"$undefined","$undefined",true],["",{"children":[["category","notes","d"],{"children":[["slug","mysql-high-availability-performance","d"],{"children":["__PAGE__",{},[["$L1","$L2",null],null],null]},[null,["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","$4","children","$5","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L6",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined"}]],null]},[null,["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","$4","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L6",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined"}]],null]},[[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/55b7a9e84b417e65.css","precedence":"next","crossOrigin":"$undefined"}]],"$L7"],null],null],["$L8",null]]]]
9:I[2972,["972","static/chunks/972-17ea62b17795b286.js","621","static/chunks/app/%5Bcategory%5D/%5Bslug%5D/page-234087874853c0eb.js"],""]
b:I[7140,["972","static/chunks/972-17ea62b17795b286.js","185","static/chunks/app/layout-8486db2c9a537bdb.js"],"default"]
a:T488d,<h1>MySQL高可用高性能实战</h1>
<blockquote>
<p>构建稳定高效的MySQL架构是现代互联网应用的核心需求</p>
</blockquote>
<h2>引言</h2>
<p>在当今的互联网应用中，数据库的稳定性和性能直接影响整个系统的可用性。MySQL作为最流行的关系型数据库之一，其高可用和性能优化是每个技术团队必须掌握的核心技能。本文将详细介绍MySQL高可用架构设计和性能优化的实战经验。</p>
<h2>MySQL高可用架构概述</h2>
<h3>1. 高可用架构目标</h3>
<p><strong>可用性指标</strong></p>
<ul>
<li>99.99%可用性（年停机时间不超过52分钟）</li>
<li>99.999%可用性（年停机时间不超过5分钟）</li>
<li>快速故障检测和恢复（RTO &lt; 1分钟）</li>
<li>最小数据丢失（RPO接近0）</li>
</ul>
<p><strong>性能指标</strong></p>
<ul>
<li>高并发处理能力（万级QPS）</li>
<li>低延迟响应（P95 &lt; 100ms）</li>
<li>高吞吐量（百万级TPS）</li>
<li>线性扩展能力</li>
</ul>
<h3>2. 高可用架构模式</h3>
<p><strong>主从模式</strong></p>
<ul>
<li>一主多从的经典架构</li>
<li>读写分离，提升读性能</li>
<li>主节点故障时手动切换</li>
<li>适合中小型应用</li>
</ul>
<p><strong>双主模式</strong></p>
<ul>
<li>双主互备架构</li>
<li>支持双向数据同步</li>
<li>应用层需要处理写入冲突</li>
<li>适合跨机房部署</li>
</ul>
<p><strong>集群模式</strong></p>
<ul>
<li>基于Paxos/Raft协议的集群</li>
<li>自动故障检测和转移</li>
<li>强一致性保证</li>
<li>适合核心业务系统</li>
</ul>
<h2>主从复制架构实战</h2>
<h3>1. 传统异步复制</h3>
<p><strong>配置示例</strong>：</p>
<pre><code class="language-sql">-- 主服务器配置
[mysqld]
server-id=1
log-bin=mysql-bin
binlog-format=ROW
expire_logs_days=7
max_binlog_size=1G

-- 从服务器配置
[mysqld]
server-id=2
relay-log=mysql-relay
read-only=1
log-slave-updates=1
</code></pre>
<p><strong>复制用户创建</strong>：</p>
<pre><code class="language-sql">-- 在主服务器创建复制用户
CREATE USER &#39;repl&#39;@&#39;%&#39; IDENTIFIED BY &#39;strong_password&#39;;
GRANT REPLICATION SLAVE ON *.* TO &#39;repl&#39;@&#39;%&#39;;
FLUSH PRIVILEGES;

-- 获取主服务器状态
SHOW MASTER STATUS;
</code></pre>
<p><strong>从服务器配置</strong>：</p>
<pre><code class="language-sql">-- 配置主从复制
CHANGE MASTER TO
    MASTER_HOST=&#39;master-ip&#39;,
    MASTER_USER=&#39;repl&#39;,
    MASTER_PASSWORD=&#39;strong_password&#39;,
    MASTER_LOG_FILE=&#39;mysql-bin.000001&#39;,
    MASTER_LOG_POS=154;

START SLAVE;

-- 检查复制状态
SHOW SLAVE STATUS\G
</code></pre>
<h3>2. 半同步复制</h3>
<p><strong>安装配置</strong>：</p>
<pre><code class="language-sql">-- 安装半同步复制插件
INSTALL PLUGIN rpl_semi_sync_master SONAME &#39;semisync_master.so&#39;;
INSTALL PLUGIN rpl_semi_sync_slave SONAME &#39;semisync_slave.so&#39;;

-- 启用半同步复制
SET GLOBAL rpl_semi_sync_master_enabled = 1;
SET GLOBAL rpl_semi_sync_slave_enabled = 1;
</code></pre>
<p><strong>性能监控</strong>：</p>
<pre><code class="language-sql">-- 查看半同步状态
SHOW STATUS LIKE &#39;Rpl_semi_sync%&#39;;

-- 关键指标
-- Rpl_semi_sync_master_clients: 半同步从库数量
-- Rpl_semi_sync_master_status: 主库半同步状态
-- Rpl_semi_sync_master_avg_tx_wait_time: 平均等待时间
</code></pre>
<h3>3. GTID复制</h3>
<p><strong>GTID配置</strong>：</p>
<pre><code class="language-sql">[mysqld]
server-id=1
log-bin=mysql-bin
binlog-format=ROW
gtid-mode=ON
enforce-gtid-consistency=ON
log-slave-updates=1
</code></pre>
<p><strong>GTID复制配置</strong>：</p>
<pre><code class="language-sql">-- 基于GTID的主从复制
CHANGE MASTER TO
    MASTER_HOST=&#39;master-ip&#39;,
    MASTER_USER=&#39;repl&#39;,
    MASTER_PASSWORD=&#39;strong_password&#39;,
    MASTER_AUTO_POSITION=1;

START SLAVE;
</code></pre>
<p><strong>GTID操作</strong>：</p>
<pre><code class="language-sql">-- 查看GTID状态
SHOW GLOBAL VARIABLES LIKE &#39;gtid%&#39;;

-- 跳过错误事务
SET GTID_NEXT=&#39;UUID:NUMBER&#39;;
BEGIN; COMMIT;
SET GTID_NEXT=&#39;AUTOMATIC&#39;;
</code></pre>
<h2>MySQL集群架构</h2>
<h3>1. MySQL Group Replication</h3>
<p><strong>集群配置</strong>：</p>
<pre><code class="language-sql">-- 所有节点配置
[mysqld]
server-id=1
gtid-mode=ON
enforce-gtid-consistency=ON
master_info_repository=TABLE
relay_log_info_repository=TABLE
binlog_checksum=NONE
log_slave_updates=ON
log_bin=binlog
binlog_format=ROW

-- Group Replication配置
transaction_write_set_extraction=XXHASH64
loose-group_replication_group_name=&quot;aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa&quot;
loose-group_replication_start_on_boot=off
loose-group_replication_local_address=&quot;node1:33061&quot;
loose-group_replication_group_seeds=&quot;node1:33061,node2:33061,node3:33061&quot;
loose-group_replication_bootstrap_group=off
</code></pre>
<p><strong>启动集群</strong>：</p>
<pre><code class="language-sql">-- 在第一个节点启动集群
SET GLOBAL group_replication_bootstrap_group=ON;
START GROUP_REPLICATION;
SET GLOBAL group_replication_bootstrap_group=OFF;

-- 在其他节点加入集群
START GROUP_REPLICATION;

-- 查看集群状态
SELECT * FROM performance_schema.replication_group_members;
</code></pre>
<h3>2. InnoDB Cluster</h3>
<p><strong>部署脚本</strong>：</p>
<pre><code class="language-bash"># 安装MySQL Shell
sudo apt-get install mysql-shell

# 创建集群
mysqlsh root@localhost:3306

# 在MySQL Shell中执行
JS&gt; var cluster = dba.createCluster(&#39;myCluster&#39;);

# 添加实例
JS&gt; cluster.addInstance(&#39;root@node2:3306&#39;);
JS&gt; cluster.addInstance(&#39;root@node3:3306&#39;);

# 检查集群状态
JS&gt; cluster.status();

# 配置自动故障转移
JS&gt; cluster.setupAdminAccount(&#39;admin&#39;);
</code></pre>
<p><strong>集群监控</strong>：</p>
<pre><code class="language-sql">-- 查看集群状态
SELECT 
    MEMBER_ID,
    MEMBER_HOST,
    MEMBER_PORT,
    MEMBER_STATE,
    MEMBER_ROLE,
    MEMBER_VERSION
FROM performance_schema.replication_group_members;

-- 查看集群事务状态
SELECT 
    COUNT_TRANSACTIONS_IN_QUEUE,
    COUNT_TRANSACTIONS_CHECKED,
    COUNT_CONFLICTS_DETECTED,
    COUNT_TRANSACTIONS_ROWS_VALIDATING
FROM performance_schema.replication_group_member_stats;
</code></pre>
<h2>高可用中间件</h2>
<h3>1. MySQL Router</h3>
<p><strong>配置示例</strong>：</p>
<pre><code class="language-ini"># mysqlrouter.conf
[DEFAULT]
logging_folder=/var/log/mysqlrouter
runtime_folder=/var/run/mysqlrouter
config_folder=/etc/mysqlrouter

[logger]
level=INFO

[routing:primary]
bind_address=0.0.0.0
bind_port=6446
destinations=primary-server:3306
routing_strategy=first-available

[routing:secondary]
bind_address=0.0.0.0
bind_port=6447
destinations=secondary-server1:3306,secondary-server2:3306
routing_strategy=round-robin
</code></pre>
<p><strong>启动和监控</strong>：</p>
<pre><code class="language-bash"># 启动MySQL Router
mysqlrouter -c /etc/mysqlrouter/mysqlrouter.conf

# 检查路由状态
mysqlrouter --show-routing-status
</code></pre>
<h3>2. ProxySQL</h3>
<p><strong>配置示例</strong>：</p>
<pre><code class="language-sql">-- 插入MySQL服务器
INSERT INTO mysql_servers(hostgroup_id,hostname,port) 
VALUES (1,&#39;master-db&#39;,3306);
INSERT INTO mysql_servers(hostgroup_id,hostname,port) 
VALUES (2,&#39;slave-db1&#39;,3306);
INSERT INTO mysql_servers(hostgroup_id,hostname,port) 
VALUES (2,&#39;slave-db2&#39;,3306);

-- 配置读写分离规则
INSERT INTO mysql_query_rules(
    rule_id,active,match_pattern,destination_hostgroup,apply
) VALUES (
    1,1,&#39;^SELECT.*FOR UPDATE$&#39;,1,1
);

INSERT INTO mysql_query_rules(
    rule_id,active,match_pattern,destination_hostgroup,apply
) VALUES (
    2,1,&#39;^SELECT&#39;,2,1
);

-- 加载配置到运行时
LOAD MYSQL SERVERS TO RUNTIME;
SAVE MYSQL SERVERS TO DISK;
LOAD MYSQL QUERY RULES TO RUNTIME;
SAVE MYSQL QUERY RULES TO DISK;
</code></pre>
<h3>3. HAProxy配置</h3>
<p><strong>配置示例</strong>：</p>
<pre><code>global
    daemon
    maxconn 4096

defaults
    mode tcp
    timeout connect 5000ms
    timeout client 50000ms
    timeout server 50000ms

listen mysql-master
    bind 0.0.0.0:3306
    mode tcp
    option tcplog
    balance roundrobin
    server master1 master-db:3306 check
    server master2 backup-db:3306 check backup

listen mysql-slave
    bind 0.0.0.0:3307
    mode tcp
    option tcplog
    balance roundrobin
    server slave1 slave-db1:3306 check
    server slave2 slave-db2:3306 check
</code></pre>
<h2>故障检测和自动转移</h2>
<h3>1. MHA（Master High Availability）</h3>
<p><strong>配置文件</strong>：</p>
<pre><code class="language-perl"># /etc/masterha_default.cnf
[server default]
user=mha
password=mha_password
ssh_user=root
repl_user=repl
repl_password=repl_password
ping_interval=1

# /etc/app1.cnf
[server1]
hostname=master-db
master_binlog_dir=/var/lib/mysql
candidate_master=1

[server2]
hostname=slave-db1
master_binlog_dir=/var/lib/mysql
candidate_master=1

[server3]
hostname=slave-db2
master_binlog_dir=/var/lib/mysql
</code></pre>
<p><strong>故障转移脚本</strong>：</p>
<pre><code class="language-bash">#!/bin/bash
# masterha_manager --conf=/etc/app1.cnf

# 手动故障转移
masterha_master_switch --master_state=dead \
    --conf=/etc/app1.cnf \
    --dead_master_host=master-db \
    --new_master_host=slave-db1 \
    --ignore_last_failover

# 在线切换
masterha_master_switch --master_state=alive \
    --conf=/etc/app1.cnf \
    --orig_master_host=master-db \
    --new_master_host=slave-db1
</code></pre>
<h3>2. Orchestrator</h3>
<p><strong>配置示例</strong>：</p>
<pre><code class="language-json">{
    &quot;Debug&quot;: false,
    &quot;ListenAddress&quot;: &quot;:3000&quot;,
    &quot;MySQLTopologyUser&quot;: &quot;orchestrator&quot;,
    &quot;MySQLTopologyPassword&quot;: &quot;orch_password&quot;,
    &quot;MySQLReadUser&quot;: &quot;orchestrator&quot;,
    &quot;MySQLReadPassword&quot;: &quot;orch_password&quot;,
    &quot;MySQLInstanceUser&quot;: &quot;orchestrator&quot;,
    &quot;MySQLInstancePassword&quot;: &quot;orch_password&quot;,
    &quot;BackendDB&quot;: &quot;sqlite&quot;,
    &quot;SQLite3DataFile&quot;: &quot;/var/lib/orchestrator/orchestrator.sqlite3&quot;
}
</code></pre>
<p><strong>集群管理</strong>：</p>
<pre><code class="language-bash"># 发现集群
orchestrator -c discover -i master-db:3306

# 故障转移
orchestrator -c graceful-master-takeover -i master-db:3306

# 查看集群拓扑
orchestrator -c topology -i master-db:3306
</code></pre>
<h2>性能优化实战</h2>
<h3>1. 硬件优化</h3>
<p><strong>CPU配置</strong>：</p>
<pre><code class="language-bash"># CPU亲和性设置
taskset -c 0-3 mysqld

# CPU频率调节
cpufreq-set -g performance

# 中断亲和性
echo 0-3 &gt; /proc/irq/24/smp_affinity
</code></pre>
<p><strong>内存优化</strong>：</p>
<pre><code class="language-sql">-- InnoDB缓冲池配置
SET GLOBAL innodb_buffer_pool_size = &#39;8G&#39;;
SET GLOBAL innodb_buffer_pool_instances = 8;
SET GLOBAL innodb_old_blocks_time = 1000;

-- MyISAM键缓冲区
SET GLOBAL key_buffer_size = &#39;256M&#39;;
</code></pre>
<p><strong>存储优化</strong>：</p>
<pre><code class="language-bash"># SSD优化
echo deadline &gt; /sys/block/sda/queue/scheduler
echo 0 &gt; /sys/block/sda/queue/rotational

# 文件系统优化
mount -t ext4 -o noatime,nodiratime /dev/sda1 /mysql
</code></pre>
<h3>2. 数据库参数优化</h3>
<p><strong>InnoDB优化</strong>：</p>
<pre><code class="language-sql">-- InnoDB配置参数
SET GLOBAL innodb_flush_log_at_trx_commit = 2;
SET GLOBAL innodb_flush_method = &#39;O_DIRECT&#39;;
SET GLOBAL innodb_io_capacity = 2000;
SET GLOBAL innodb_io_capacity_max = 4000;
SET GLOBAL innodb_read_io_threads = 8;
SET GLOBAL innodb_write_io_threads = 8;
SET GLOBAL innodb_log_file_size = &#39;256M&#39;;
SET GLOBAL innodb_log_buffer_size = &#39;64M&#39;;
</code></pre>
<p><strong>连接优化</strong>：</p>
<pre><code class="language-sql">-- 连接相关参数
SET GLOBAL max_connections = 2000;
SET GLOBAL max_connect_errors = 10000;
SET GLOBAL connect_timeout = 10;
SET GLOBAL wait_timeout = 28800;
SET GLOBAL interactive_timeout = 28800;
</code></pre>
<p><strong>查询优化</strong>：</p>
<pre><code class="language-sql">-- 查询缓存（MySQL 5.7及以下）
SET GLOBAL query_cache_size = &#39;256M&#39;;
SET GLOBAL query_cache_type = ON;

-- 查询优化器
SET GLOBAL optimizer_switch = &#39;index_merge=on,index_merge_union=on,index_merge_sort_union=on&#39;;
</code></pre>
<h3>3. SQL优化</h3>
<p><strong>索引优化</strong>：</p>
<pre><code class="language-sql">-- 创建复合索引
CREATE INDEX idx_user_status ON users(status, created_at);

-- 分析索引使用情况
EXPLAIN SELECT * FROM users WHERE status = 1 ORDER BY created_at;

-- 删除无用索引
DROP INDEX idx_unused ON table_name;
</code></pre>
<p><strong>查询优化</strong>：</p>
<pre><code class="language-sql">-- 避免全表扫描
SELECT id, name FROM users WHERE status = 1 LIMIT 100;

-- 使用覆盖索引
SELECT id, status FROM users WHERE status = 1;

-- 批量插入优化
INSERT INTO orders (user_id, amount, created_at) VALUES 
    (1, 100, NOW()),
    (2, 200, NOW()),
    (3, 300, NOW());
</code></pre>
<p><strong>分页优化</strong>：</p>
<pre><code class="language-sql">-- 传统分页（性能较差）
SELECT * FROM orders ORDER BY id LIMIT 10000, 20;

-- 优化分页（使用书签）
SELECT * FROM orders WHERE id &gt; 10000 ORDER BY id LIMIT 20;

-- 复杂分页优化
SELECT o.* FROM orders o
INNER JOIN (SELECT id FROM orders ORDER BY id LIMIT 10000, 20) t ON o.id = t.id;
</code></pre>
<h2>监控和告警</h2>
<h3>1. 性能监控</h3>
<p><strong>关键指标监控</strong>：</p>
<pre><code class="language-sql">-- QPS和TPS
SHOW GLOBAL STATUS LIKE &#39;Com_%&#39;;
SHOW GLOBAL STATUS LIKE &#39;Questions&#39;;
SHOW GLOBAL STATUS LIKE &#39;Uptime&#39;;

-- 连接数
SHOW GLOBAL STATUS LIKE &#39;Threads%&#39;;
SHOW GLOBAL STATUS LIKE &#39;Max_used_connections&#39;;

-- 慢查询
SHOW GLOBAL STATUS LIKE &#39;Slow_queries&#39;;
SELECT * FROM mysql.slow_log ORDER BY start_time DESC LIMIT 10;
</code></pre>
<p><strong>InnoDB监控</strong>：</p>
<pre><code class="language-sql">-- InnoDB状态
SHOW ENGINE INNODB STATUS;

-- InnoDB指标
SHOW GLOBAL STATUS LIKE &#39;Innodb%&#39;;

-- 锁等待
SELECT * FROM sys.innodb_lock_waits;
</code></pre>
<h3>2. Prometheus监控</h3>
<p><strong>MySQL Exporter配置</strong>：</p>
<pre><code class="language-yaml"># prometheus.yml
global:
  scrape_interval: 15s

scrape_configs:
  - job_name: &#39;mysql&#39;
    static_configs:
      - targets: [&#39;mysql-exporter:9104&#39;]
</code></pre>
<p><strong>关键告警规则</strong>：</p>
<pre><code class="language-yaml"># mysql_alerts.yml
groups:
  - name: mysql
    rules:
      - alert: MySQLDown
        expr: mysql_up == 0
        for: 1m
        labels:
          severity: critical
        annotations:
          summary: &quot;MySQL instance is down&quot;
          
      - alert: MySQLTooManyConnections
        expr: mysql_global_status_threads_connected / mysql_global_variables_max_connections &gt; 0.8
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: &quot;MySQL has too many connections&quot;
</code></pre>
<h3>3. 日志分析</h3>
<p><strong>慢查询日志分析</strong>：</p>
<pre><code class="language-bash"># 启用慢查询日志
SET GLOBAL slow_query_log = &#39;ON&#39;;
SET GLOBAL long_query_time = 1;
SET GLOBAL slow_query_log_file = &#39;/var/log/mysql/slow.log&#39;;

# 使用pt-query-digest分析
pt-query-digest /var/log/mysql/slow.log

# 输出报告示例
# # Profile
# # Rank Query ID           Response time   Calls   R/Call   V/M   Item
# # ==== ================== ============== ======= ========= ===== ===============
# #    1 0xF9A57DD5A41847CA  2.5119  38%    1000   0.002512  0.10 SELECT users
</code></pre>
<h2>备份和恢复</h2>
<h3>1. 逻辑备份</h3>
<p><strong>mysqldump备份</strong>：</p>
<pre><code class="language-bash"># 全量备份
mysqldump -u root -p --single-transaction --routines --triggers --all-databases &gt; full_backup.sql

# 增量备份（基于binlog）
mysqlbinlog --start-datetime=&quot;2024-01-01 00:00:00&quot; --stop-datetime=&quot;2024-01-02 00:00:00&quot; mysql-bin.000001 &gt; incremental_backup.sql

# 恢复数据
mysql -u root -p &lt; full_backup.sql
mysql -u root -p &lt; incremental_backup.sql
</code></pre>
<h3>2. 物理备份</h3>
<p><strong>XtraBackup备份</strong>：</p>
<pre><code class="language-bash"># 全量备份
xtrabackup --backup --target-dir=/backup/full --user=backup --password=backup_password

# 增量备份
xtrabackup --backup --target-dir=/backup/inc1 --incremental-basedir=/backup/full --user=backup --password=backup_password

# 准备备份
xtrabackup --prepare --target-dir=/backup/full
xtrabackup --prepare --target-dir=/backup/full --incremental-dir=/backup/inc1

# 恢复备份
xtrabackup --copy-back --target-dir=/backup/full
</code></pre>
<h3>3. 自动化备份脚本</h3>
<p><strong>备份脚本示例</strong>：</p>
<pre><code class="language-bash">#!/bin/bash
# backup_mysql.sh

BACKUP_DIR=&quot;/backup/mysql&quot;
DATE=$(date +%Y%m%d_%H%M%S)
DB_USER=&quot;backup&quot;
DB_PASS=&quot;backup_password&quot;
RETENTION_DAYS=7

# 创建备份目录
mkdir -p $BACKUP_DIR/$DATE

# 全量备份
xtrabackup --backup --target-dir=$BACKUP_DIR/$DATE/full --user=$DB_USER --password=$DB_PASS

# 删除过期备份
find $BACKUP_DIR -type d -mtime +$RETENTION_DAYS -exec rm -rf {} \;

# 上传到云存储
aws s3 sync $BACKUP_DIR/$DATE s3://mysql-backup-bucket/$DATE
</code></pre>
<h2>总结</h2>
<p>构建MySQL高可用高性能架构需要综合考虑多个方面：</p>
<ol>
<li><strong>架构选择</strong>：根据业务需求选择合适的高可用架构</li>
<li><strong>性能优化</strong>：从硬件、参数、SQL等多个层面进行优化</li>
<li><strong>监控告警</strong>：建立完善的监控体系和告警机制</li>
<li><strong>备份恢复</strong>：制定可靠的备份策略和恢复方案</li>
<li><strong>运维管理</strong>：建立标准化的运维流程和工具链</li>
</ol>
<p>通过合理的架构设计和持续的优化改进，可以构建出稳定、高效、可扩展的MySQL数据库系统，为业务发展提供坚实的数据支撑。</p>
2:["$","div",null,{"children":[["$","$L9",null,{"href":"/notes","className":"back-button","style":{"display":"inline-block","background":"var(--primary-color)","color":"white","border":"none","padding":"10px 20px","borderRadius":"6px","cursor":"pointer","marginBottom":"20px","textDecoration":"none"},"children":["← 返回","笔记","列表"]}],["$","article",null,{"className":"section","children":[["$","header",null,{"className":"article-header","children":[["$","h1",null,{"className":"article-title","children":"MySQL高可用高性能实战"}],["$","div",null,{"className":"article-meta","children":[["$","div",null,{"className":"article-meta-info","children":[["$","span",null,{"className":"article-date","children":"2024-10-14"}],["$","span",null,{"className":"article-category","children":["• ","笔记"]}]]}],["$","div",null,{"className":"article-tags","children":[["$","span","MySQL",{"className":"tag","children":"MySQL"}],["$","span","高可用",{"className":"tag","children":"高可用"}],["$","span","性能优化",{"className":"tag","children":"性能优化"}],["$","span","数据库架构",{"className":"tag","children":"数据库架构"}],["$","span","主从复制",{"className":"tag","children":"主从复制"}]]}]]}]]}],["$","div",null,{"className":"card markdown-content","dangerouslySetInnerHTML":{"__html":"$a"}}]]}]]}]
7:["$","html",null,{"lang":"zh-CN","children":[["$","head",null,{"children":[["$","link",null,{"rel":"stylesheet","href":"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"}],["$","link",null,{"rel":"stylesheet","href":"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css"}]]}],["$","body",null,{"children":["$","div",null,{"className":"app","children":[["$","$Lb",null,{"siteConfig":{"name":"Rudy Yang","bio":"JAVA | AI | WEB3","social":[{"name":"github","icon":"fab fa-github","url":"https://github.com/suogongy"},{"name":"twitter","icon":"fab fa-twitter","url":"https://twitter.com/suogongy"},{"name":"email","icon":"fas fa-envelope","url":"mailto:haiyuan1832@163.com"}]}}],["$","main",null,{"className":"main-content","children":["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L6",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":"404"}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],"notFoundStyles":[]}]}]]}]}]]}]
8:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"MySQL高可用高性能实战 - Personal GitHub Page"}],["$","meta","3",{"name":"description","content":"本文详细介绍MySQL高可用架构的设计原理、实现方案和性能优化实践，包括主从复制、集群部署、故障转移等核心技术。"}]]
1:null
