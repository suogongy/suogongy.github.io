<!DOCTYPE html><html lang="zh-CN"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/55b7a9e84b417e65.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-c81f7fd28659d64f.js"/><script src="/_next/static/chunks/fd9d1056-9f91b5e418130764.js" async=""></script><script src="/_next/static/chunks/117-ee7b0ec54963e50f.js" async=""></script><script src="/_next/static/chunks/main-app-c180f1b9030bf4f6.js" async=""></script><script src="/_next/static/chunks/972-17ea62b17795b286.js" async=""></script><script src="/_next/static/chunks/app/%5Bcategory%5D/%5Bslug%5D/page-234087874853c0eb.js" async=""></script><script src="/_next/static/chunks/app/layout-8486db2c9a537bdb.js" async=""></script><title>热门系统设计题及解题思路 - Personal GitHub Page</title><meta name="description" content="深入分析常见的系统设计面试题，包括设计思路、架构方案和技术选型，帮助开发者掌握系统设计的核心方法。"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css"/><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body><div class="app"><header class="header "><nav class="nav-container"><a class="nav-brand" href="/"><i class="fas fa-terminal"></i>Rudy Yang</a><ul class="nav-menu"><li><a class="nav-link " href="/"><i class="fas fa-home"></i> 首页</a></li><li><a class="nav-link " href="/about/"><i class="fas fa-user"></i> 关于</a></li><li><a class="nav-link " href="/projects/"><i class="fas fa-code"></i> 项目</a></li><li><a class="nav-link " href="/notes/"><i class="fas fa-book"></i> 笔记</a></li><li><a class="nav-link " href="/articles/"><i class="fas fa-pen"></i> 随笔</a></li></ul></nav></header><main class="main-content"><div><a class="back-button" style="display:inline-block;background:var(--primary-color);color:white;border:none;padding:10px 20px;border-radius:6px;cursor:pointer;margin-bottom:20px;text-decoration:none" href="/notes/">← 返回<!-- -->笔记<!-- -->列表</a><article class="section"><header class="article-header"><h1 class="article-title">热门系统设计题及解题思路</h1><div class="article-meta"><div class="article-meta-info"><span class="article-date">2024-10-14</span><span class="article-category">• <!-- -->笔记</span></div><div class="article-tags"><span class="tag">系统设计</span><span class="tag">面试</span><span class="tag">架构设计</span><span class="tag">分布式系统</span><span class="tag">技术方案</span></div></div></header><div class="card markdown-content"><h1>热门系统设计题及解题思路</h1>
<blockquote>
<p>系统设计面试是技术面试的重要环节，掌握解题方法是关键</p>
</blockquote>
<h2>系统设计方法论</h2>
<h3>1. 设计流程</h3>
<pre><code>系统设计流程：
├── 需求分析
│   ├── 功能需求
│   ├── 非功能需求
│   └── 约束条件
├── 估算
│   ├── QPS估算
│   ├── 存储估算
│   └── 带宽估算
├── 架构设计
│   ├── 分层架构
│   ├── 服务拆分
│   └── 数据流设计
├── 技术选型
│   ├── 数据库选型
│   ├── 缓存选型
│   └── 消息队列选型
├── 优化
│   ├── 性能优化
│   ├── 可用性优化
│   └── 扩展性优化
└── 总结
    ├── 设计回顾
    ├── 权衡取舍
    └── 后续优化
</code></pre>
<h3>2. 通用设计原则</h3>
<pre><code>设计原则：
├── 简单性
│   ├── KISS原则
│   ├── 避免过度设计
│   └── 逐步迭代
├── 可扩展性
│   ├── 水平扩展
│   ├── 垂直扩展
│   └── 数据分片
├── 可用性
│   ├── 冗余设计
│   ├── 故障隔离
│   └── 自动恢复
├── 性能
│   ├── 缓存策略
│   ├── 异步处理
│   └── 负载均衡
└── 一致性
    ├── 强一致性
    ├── 最终一致性
    └── 一致性级别选择
</code></pre>
<h2>经典题目分析</h2>
<h3>1. 设计短链接系统</h3>
<h4>1.1 需求分析</h4>
<pre><code>功能需求：
- 用户输入长URL，生成短链接
- 用户访问短链接，重定向到长URL
- 支持自定义短链接
- 支持链接过期时间
- 支持访问统计

非功能需求：
- 高可用性：99.9%
- 低延迟：生成&lt;100ms，访问&lt;50ms
- 高并发：支持1000 QPS
- 可扩展：支持水平扩展

约束条件：
- 短链接长度：6-8位
- 字符集：a-zA-Z0-9
- 短链接有效期：1年
</code></pre>
<h4>1.2 系统架构</h4>
<pre><code>系统架构图：
┌─────────────────────────────────────────────────────────────┐
│                    CDN                                     │
└─────────────────────────────────────────────────────────────┘
                          │
                    ┌─────────────┐
                    │  Load        │
                    │  Balancer    │
                    └─────────────┘
                          │
          ┌───────────────┼───────────────┐
          │               │               │
    ┌─────────────┐ ┌─────────────┐ ┌─────────────┐
    │  Web        │ │  Web        │ │  Web        │
    │  Server     │ │  Server     │ │  Server     │
    └─────────────┘ └─────────────┘ └─────────────┘
          │               │               │
          └───────────────┼───────────────┘
                          │
          ┌───────────────┼───────────────┐
          │               │               │
    ┌─────────────┐ ┌─────────────┐ ┌─────────────┐
    │  Redis      │ │  MySQL      │ │  Analytics  │
    │  Cluster    │ │  Master     │ │  Service    │
    └─────────────┘ └─────────────┘ └─────────────┘
</code></pre>
<h4>1.3 核心算法</h4>
<p><strong>Base62编码算法</strong></p>
<pre><code class="language-java">public class Base62Encoder {
    private static final String BASE62_CHARS = 
        &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;;
    
    public static String encode(long num) {
        if (num == 0) {
            return &quot;a&quot;;
        }
        
        StringBuilder sb = new StringBuilder();
        while (num &gt; 0) {
            sb.append(BASE62_CHARS.charAt((int)(num % 62)));
            num /= 62;
        }
        
        return sb.reverse().toString();
    }
    
    public static long decode(String str) {
        long num = 0;
        for (int i = 0; i &lt; str.length(); i++) {
            num = num * 62 + BASE62_CHARS.indexOf(str.charAt(i));
        }
        return num;
    }
}

// 短链接生成服务
@Service
public class ShortLinkService {
    
    @Autowired
    private RedisTemplate&lt;String, String&gt; redisTemplate;
    
    @Autowired
    private ShortLinkMapper shortLinkMapper;
    
    private final AtomicLong idGenerator = new AtomicLong(1000000);
    
    public String generateShortLink(String longUrl) {
        // 1. 检查是否已存在
        String shortLink = getExistingShortLink(longUrl);
        if (shortLink != null) {
            return shortLink;
        }
        
        // 2. 生成新的短链接
        long id = idGenerator.getAndIncrement();
        String code = Base62Encoder.encode(id);
        
        // 3. 存储映射关系
        storeMapping(code, longUrl);
        
        return &quot;https://short.ly/&quot; + code;
    }
    
    private String getExistingShortLink(String longUrl) {
        String key = &quot;url:hash:&quot; + DigestUtils.md5Hex(longUrl);
        return redisTemplate.opsForValue().get(key);
    }
    
    private void storeMapping(String code, String longUrl) {
        // 存储到Redis
        redisTemplate.opsForValue().set(&quot;code:&quot; + code, longUrl, 365, TimeUnit.DAYS);
        redisTemplate.opsForValue().set(&quot;url:hash:&quot; + 
            DigestUtils.md5Hex(longUrl), code, 365, TimeUnit.DAYS);
        
        // 异步存储到MySQL
        asyncStoreToMySQL(code, longUrl);
    }
}
</code></pre>
<p><strong>重定向服务</strong></p>
<pre><code class="language-java">@RestController
public class RedirectController {
    
    @Autowired
    private ShortLinkService shortLinkService;
    
    @GetMapping(&quot;/{code}&quot;)
    public RedirectView redirect(@PathVariable String code, 
                               HttpServletRequest request) {
        String longUrl = shortLinkService.getLongUrl(code);
        if (longUrl == null) {
            throw new NotFoundException(&quot;Short link not found&quot;);
        }
        
        // 记录访问日志
        shortLinkService.recordAccess(code, request);
        
        RedirectView redirectView = new RedirectView();
        redirectView.setUrl(longUrl);
        return redirectView;
    }
}

@Service
public class ShortLinkService {
    
    public String getLongUrl(String code) {
        // 先从Redis获取
        String longUrl = redisTemplate.opsForValue().get(&quot;code:&quot; + code);
        if (longUrl != null) {
            return longUrl;
        }
        
        // 从数据库获取
        ShortLinkEntity entity = shortLinkMapper.selectByCode(code);
        if (entity != null) {
            // 回写Redis
            redisTemplate.opsForValue().set(&quot;code:&quot; + code, 
                entity.getLongUrl(), 365, TimeUnit.DAYS);
            return entity.getLongUrl();
        }
        
        return null;
    }
    
    public void recordAccess(String code, HttpServletRequest request) {
        AccessLog log = new AccessLog();
        log.setCode(code);
        log.setIp(getClientIp(request));
        log.setUserAgent(request.getHeader(&quot;User-Agent&quot;));
        log.setAccessTime(new Date());
        
        // 异步记录访问日志
        asyncRecordAccess(log);
    }
}
</code></pre>
<h3>2. 设计Feed流系统</h3>
<h4>2.1 需求分析</h4>
<pre><code>功能需求：
- 用户发布动态
- 查看关注人的动态
- 点赞、评论、转发
- 推荐热门内容

非功能需求：
- 支持千万级用户
- 实时性：延迟&lt;1秒
- 高并发：写1000 QPS，读10000 QPS
- 数据一致性：最终一致性

约束条件：
- 每个用户关注人数：1000
- 每条动态存活时间：30天
- 缓存命中率：&gt;90%
</code></pre>
<h4>2.2 架构设计</h4>
<pre><code>Feed流架构：
┌─────────────────────────────────────────────────────────────┐
│                    API Gateway                              │
└─────────────────────────────────────────────────────────────┘
                          │
                    ┌─────────────┐
                    │  Load        │
                    │  Balancer    │
                    └─────────────┘
                          │
          ┌───────────────┼───────────────┐
          │               │               │
    ┌─────────────┐ ┌─────────────┐ ┌─────────────┐
    │  Feed       │ │  Feed       │ │  Feed       │
    │  Service    │ │  Service    │ │  Service    │
    └─────────────┘ └─────────────┘ └─────────────┘
          │               │               │
          └───────────────┼───────────────┘
                          │
          ┌───────────────┼───────────────┐
          │               │               │
    ┌─────────────┐ ┌─────────────┐ ┌─────────────┐
    │  Redis      │ │  Kafka      │ │  MySQL      │
    │  Cluster    │ │  Cluster    │ │  Cluster    │
    └─────────────┘ └─────────────┘ └─────────────┘
</code></pre>
<h4>2.3 核心实现</h4>
<p><strong>推拉结合模式</strong></p>
<pre><code class="language-java">@Service
public class FeedService {
    
    @Autowired
    private RedisTemplate&lt;String, String&gt; redisTemplate;
    
    @Autowired
    private KafkaTemplate&lt;String, String&gt; kafkaTemplate;
    
    // 发布动态（推模式）
    public void publishFeed(Long userId, String content) {
        // 1. 保存动态到数据库
        FeedEntity feed = new FeedEntity();
        feed.setUserId(userId);
        feed.setContent(content);
        feed.setCreateTime(new Date());
        feedRepository.save(feed);
        
        // 2. 获取关注者列表
        List&lt;Long&gt; followers = getFollowers(userId);
        
        // 3. 推送到关注者的收件箱（推模式）
        for (Long followerId : followers) {
            String inboxKey = &quot;feed:inbox:&quot; + followerId;
            redisTemplate.opsForZSet().add(inboxKey, 
                String.valueOf(feed.getId()), feed.getCreateTime().getTime());
            
            // 限制收件箱大小
            long size = redisTemplate.opsForZSet().size(inboxKey);
            if (size &gt; 1000) {
                redisTemplate.opsForZSet().removeRange(inboxKey, 0, size - 1000);
            }
        }
        
        // 4. 发送消息到MQ进行异步处理
        FeedMessage message = new FeedMessage();
        message.setUserId(userId);
        message.setFeedId(feed.getId());
        message.setAction(&quot;PUBLISH&quot;);
        
        kafkaTemplate.send(&quot;feed-topic&quot;, JSON.toJSONString(message));
    }
    
    // 获取Feed流（拉模式 + 推模式）
    public List&lt;FeedEntity&gt; getFeed(Long userId, int page, int size) {
        // 1. 从Redis收件箱获取动态ID列表（推模式）
        String inboxKey = &quot;feed:inbox:&quot; + userId;
        Set&lt;String&gt; feedIds = redisTemplate.opsForZSet()
            .reverseRange(inboxKey, page * size, (page + 1) * size - 1);
        
        List&lt;FeedEntity&gt; feeds = new ArrayList&lt;&gt;();
        
        if (feedIds != null &amp;&amp; !feedIds.isEmpty()) {
            // 2. 批量获取动态内容
            feeds = batchGetFeeds(feedIds);
        }
        
        // 3. 如果收件箱内容不足，补充拉模式（获取关注者的最新动态）
        if (feeds.size() &lt; size) {
            List&lt;Long&gt; followees = getFollowees(userId);
            List&lt;FeedEntity&gt; additionalFeeds = pullFolloweesFeeds(followees, 
                feeds.size(), size - feeds.size());
            feeds.addAll(additionalFeeds);
        }
        
        return feeds;
    }
    
    // 批量获取动态
    private List&lt;FeedEntity&gt; batchGetFeeds(Set&lt;String&gt; feedIds) {
        List&lt;Long&gt; ids = feedIds.stream()
            .map(Long::parseLong)
            .collect(Collectors.toList());
        
        return feedRepository.findAllById(ids);
    }
    
    // 拉取关注者的动态
    private List&lt;FeedEntity&gt; pullFolloweesFeeds(List&lt;Long&gt; followees, 
                                               int offset, int limit) {
        return feedRepository.findTopFeedsByUsers(followees, offset, limit);
    }
}
</code></pre>
<p><strong>推荐算法</strong></p>
<pre><code class="language-java">@Service
public class FeedRecommendService {
    
    @Autowired
    private RedisTemplate&lt;String, String&gt; redisTemplate;
    
    // 基于协同过滤的推荐
    public List&lt;FeedEntity&gt; recommendFeeds(Long userId, int count) {
        // 1. 获取用户兴趣标签
        Set&lt;String&gt; userTags = getUserTags(userId);
        
        // 2. 获取热门动态
        List&lt;FeedEntity&gt; hotFeeds = getHotFeeds(count * 2);
        
        // 3. 根据兴趣标签过滤和排序
        List&lt;FeedEntity&gt; recommendedFeeds = hotFeeds.stream()
            .filter(feed -&gt; calculateRelevance(feed, userTags) &gt; 0.5)
            .sorted((f1, f2) -&gt; Double.compare(
                calculateRelevance(f2, userTags), 
                calculateRelevance(f1, userTags)))
            .limit(count)
            .collect(Collectors.toList());
        
        return recommendedFeeds;
    }
    
    // 计算动态相关性
    private double calculateRelevance(FeedEntity feed, Set&lt;String&gt; userTags) {
        Set&lt;String&gt; feedTags = extractTags(feed.getContent());
        
        // 计算Jaccard相似度
        Set&lt;String&gt; intersection = new HashSet&lt;&gt;(userTags);
        intersection.retainAll(feedTags);
        
        Set&lt;String&gt; union = new HashSet&lt;&gt;(userTags);
        union.addAll(feedTags);
        
        return union.isEmpty() ? 0.0 : (double) intersection.size() / union.size();
    }
    
    // 获取热门动态
    private List&lt;FeedEntity&gt; getHotFeeds(int count) {
        // 基于Redis的热度排行榜
        String hotKey = &quot;feed:hot&quot;;
        Set&lt;String&gt; feedIds = redisTemplate.opsForZSet()
            .reverseRange(hotKey, 0, count - 1);
        
        if (feedIds != null) {
            return batchGetFeeds(feedIds);
        }
        
        return Collections.emptyList();
    }
}
</code></pre>
<h3>3. 设计秒杀系统</h3>
<h4>3.1 需求分析</h4>
<pre><code>功能需求：
- 商品展示
- 秒杀下单
- 库存管理
- 订单管理

非功能需求：
- 高并发：支持10万QPS
- 低延迟：下单&lt;50ms
- 高可用：99.9%
- 数据一致性：不超卖

约束条件：
- 秒杀时长：5分钟
- 每个用户限购1件
- 库存：1000件
</code></pre>
<h4>3.2 架构设计</h4>
<pre><code>秒杀系统架构：
┌─────────────────────────────────────────────────────────────┐
│                    CDN                                     │
└─────────────────────────────────────────────────────────────┘
                          │
                    ┌─────────────┐
                    │  Load        │
                    │  Balancer    │
                    └─────────────┘
                          │
          ┌───────────────┼───────────────┐
          │               │               │
    ┌─────────────┐ ┌─────────────┐ ┌─────────────┐
    │  Web        │ │  Web        │ │  Web        │
    │  Server     │ │  Server     │ │  Server     │
    └─────────────┘ └─────────────┘ └─────────────┘
          │               │               │
          └───────────────┼───────────────┘
                          │
          ┌───────────────┼───────────────┐
          │               │               │
    ┌─────────────┐ ┌─────────────┐ ┌─────────────┐
    │  Redis      │ │  MQ         │ │  MySQL      │
    │  Cluster    │ │  Cluster    │ │  Master     │
    └─────────────┘ └─────────────┘ └─────────────┘
</code></pre>
<h4>3.3 核心实现</h4>
<p><strong>库存管理</strong></p>
<pre><code class="language-java">@Service
public class SeckillService {
    
    @Autowired
    private RedisTemplate&lt;String, String&gt; redisTemplate;
    
    @Autowired
    private RabbitTemplate rabbitTemplate;
    
    // 预热库存
    public void warmUpStock(Long productId, int stock) {
        String stockKey = &quot;seckill:stock:&quot; + productId;
        redisTemplate.opsForValue().set(stockKey, String.valueOf(stock));
        
        // 预热用户购买记录
        String userKey = &quot;seckill:user:&quot; + productId;
        // 预分配空间
        redisTemplate.opsForHash().put(userKey, &quot;init&quot;, &quot;0&quot;);
    }
    
    // 秒杀下单
    @Transactional
    public SeckillResult seckill(Long productId, Long userId) {
        // 1. 检查用户是否已购买
        if (hasPurchased(productId, userId)) {
            return SeckillResult.error(&quot;已购买&quot;);
        }
        
        // 2. 原子性扣减库存
        String stockKey = &quot;seckill:stock:&quot; + productId;
        Long result = redisTemplate.execute(
            new DefaultRedisScript&lt;&gt;(SECKILL_SCRIPT, Long.class),
            Collections.singletonList(stockKey),
            String.valueOf(userId)
        );
        
        if (result == null || result == 0) {
            return SeckillResult.error(&quot;库存不足&quot;);
        }
        
        // 3. 发送MQ消息
        SeckillMessage message = new SeckillMessage();
        message.setProductId(productId);
        message.setUserId(userId);
        message.setCreateTime(new Date());
        
        rabbitTemplate.convertAndSend(&quot;seckill.queue&quot;, message);
        
        return SeckillResult.success(&quot;抢购成功&quot;);
    }
    
    // Lua脚本：原子性操作
    private static final String SECKILL_SCRIPT = 
        &quot;local stock = redis.call(&#39;GET&#39;, KEYS[1]) &quot; +
        &quot;if tonumber(stock) &lt;= 0 then &quot; +
        &quot;  return 0 &quot; +
        &quot;end &quot; +
        &quot;local userKey = &#39;seckill:user:&#39; .. KEYS[1] &quot; +
        &quot;if redis.call(&#39;HEXISTS&#39;, userKey, ARGV[1]) == 1 then &quot; +
        &quot;  return -1 &quot; +
        &quot;end &quot; +
        &quot;redis.call(&#39;DECR&#39;, KEYS[1]) &quot; +
        &quot;redis.call(&#39;HSET&#39;, userKey, ARGV[1], &#39;1&#39;) &quot; +
        &quot;return 1&quot;;
    
    private boolean hasPurchased(Long productId, Long userId) {
        String userKey = &quot;seckill:user:&quot; + productId;
        return redisTemplate.opsForHash().hasKey(userKey, String.valueOf(userId));
    }
}
</code></pre>
<p><strong>限流保护</strong></p>
<pre><code class="language-java">@Component
public class RateLimiter {
    
    private final Map&lt;String, Bucket&gt; buckets = new ConcurrentHashMap&lt;&gt;();
    
    // 令牌桶限流
    public boolean tryAcquire(String key, int permits, double rate) {
        Bucket bucket = buckets.computeIfAbsent(key, k -&gt; {
            Refill refill = Refill.intervally(permits, Duration.ofSeconds((int) (permits / rate)));
            return Bucket.builder()
                .addLimit(Bandwidth.classic(permits, refill))
                .build();
        });
        
        return bucket.tryConsume(permits);
    }
    
    // 滑动窗口限流
    public boolean tryAcquireWithSlidingWindow(String key, int permits, int windowSize) {
        String windowKey = &quot;rate:limit:&quot; + key;
        long currentTime = System.currentTimeMillis();
        
        // 清理过期记录
        redisTemplate.execute(
            new DefaultRedisScript&lt;&gt;(CLEANUP_SCRIPT, Long.class),
            Collections.singletonList(windowKey),
            String.valueOf(currentTime - windowSize * 1000)
        );
        
        // 检查当前窗口内的请求数
        Long currentCount = redisTemplate.opsForZSet().count(windowKey, 
            currentTime - windowSize * 1000, currentTime);
        
        if (currentCount &lt; permits) {
            // 添加当前请求
            redisTemplate.opsForZSet().add(windowKey, 
                String.valueOf(currentTime), currentTime);
            return true;
        }
        
        return false;
    }
    
    private static final String CLEANUP_SCRIPT = 
        &quot;redis.call(&#39;ZREMRANGEBYSCORE&#39;, KEYS[1], 0, ARGV[1]) &quot; +
        &quot;return redis.call(&#39;ZCARD&#39;, KEYS[1])&quot;;
}

@RestController
public class SeckillController {
    
    @Autowired
    private SeckillService seckillService;
    
    @Autowired
    private RateLimiter rateLimiter;
    
    @PostMapping(&quot;/seckill/{productId}&quot;)
    public Result seckill(@PathVariable Long productId) {
        Long userId = getCurrentUserId();
        
        // 接口级别限流
        if (!rateLimiter.tryAcquire(&quot;seckill:api&quot;, 1000, 1000)) {
            return Result.error(&quot;系统繁忙&quot;);
        }
        
        // 用户级别限流
        if (!rateLimiter.tryAcquire(&quot;seckill:user:&quot; + userId, 1, 10)) {
            return Result.error(&quot;操作过于频繁&quot;);
        }
        
        return seckillService.seckill(productId, userId);
    }
}
</code></pre>
<h2>系统设计技巧</h2>
<h3>1. 性能优化</h3>
<pre><code>性能优化策略：
├── 缓存
│   ├── 多级缓存
│   ├── 缓存预热
│   ├── 缓存更新
│   └── 缓存穿透/雪崩
├── 异步
│   ├── 消息队列
│   ├── 异步处理
│   ├── 批量操作
│   └── 异步回调
├── 数据库
│   ├── 索引优化
│   ├── 读写分离
│   ├── 分库分表
│   └── 连接池优化
└── 网络
    ├── CDN加速
    ├── HTTP/2
    ├── 压缩传输
    └── 连接复用
</code></pre>
<h3>2. 可扩展性设计</h3>
<pre><code>可扩展性原则：
├── 无状态服务
│   ├── 会话外部化
│   ├── 文件存储
│   └── 负载均衡
├── 数据分片
│   ├── 水平分片
│   ├── 垂直分片
│   └── 分片算法
├── 微服务架构
│   ├── 服务拆分
│   ├── 服务治理
│   └── 服务编排
└── 弹性伸缩
    ├── 自动扩容
    ├── 负载监控
    └── 资源调度
</code></pre>
<h3>3. 面试技巧</h3>
<pre><code>面试答题技巧：
├── 沟通确认
│   ├── 明确需求
│   ├── 确认约束
│   └── 边界条件
├── 结构化回答
│   ├── 总体架构
│   ├── 核心模块
│   ├── 技术细节
│   └── 优化改进
├── 权衡取舍
│   ├── 性能vs成本
│   ├── 一致性vs可用性
│   ├── 复杂度vs可维护性
│   └── 安全vs便利性
└── 总结回顾
    ├── 设计亮点
    ├── 潜在问题
    ├── 优化方向
    └── 扩展思路
</code></pre>
<h2>总结</h2>
<p>系统设计是一个综合性技能，需要掌握：</p>
<ol>
<li><strong>设计方法论</strong>：系统的设计流程和思考方式</li>
<li><strong>技术广度</strong>：了解各种技术的特点和应用场景</li>
<li><strong>实战经验</strong>：通过实际项目积累经验</li>
<li><strong>持续学习</strong>：关注新技术和最佳实践</li>
<li><strong>沟通表达</strong>：能够清晰地表达设计思路</li>
</ol>
<p>通过不断练习和总结，可以逐步提升系统设计能力，在面试和实际工作中都能设计出优秀的系统架构。</p>
</div></article></div></main></div><script src="/_next/static/chunks/webpack-c81f7fd28659d64f.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/55b7a9e84b417e65.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"2:I[2846,[],\"\"]\n5:I[4707,[],\"\"]\n8:I[6423,[],\"\"]\nb:I[1060,[],\"\"]\n6:[\"category\",\"notes\",\"d\"]\n7:[\"slug\",\"system-design-interview-questions\",\"d\"]\nc:[]\n0:[\"$\",\"$L2\",null,{\"buildId\":\"build\",\"assetPrefix\":\"\",\"urlParts\":[\"\",\"notes\",\"system-design-interview-questions\",\"\"],\"initialTree\":[\"\",{\"children\":[[\"category\",\"notes\",\"d\"],{\"children\":[[\"slug\",\"system-design-interview-questions\",\"d\"],{\"children\":[\"__PAGE__?{\\\"category\\\":\\\"notes\\\",\\\"slug\\\":\\\"system-design-interview-questions\\\"}\",{}]}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"category\",\"notes\",\"d\"],{\"children\":[[\"slug\",\"system-design-interview-questions\",\"d\"],{\"children\":[\"__PAGE__\",{},[[\"$L3\",\"$L4\",null],null],null]},[null,[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$6\",\"children\",\"$7\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}]],null]},[null,[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$6\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}]],null]},[[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/55b7a9e84b417e65.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],\"$L9\"],null],null],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$La\"],\"globalErrorComponent\":\"$b\",\"missingSlots\":\"$Wc\"}]\n"])</script><script>self.__next_f.push([1,"d:I[2972,[\"972\",\"static/chunks/972-17ea62b17795b286.js\",\"621\",\"static/chunks/app/%5Bcategory%5D/%5Bslug%5D/page-234087874853c0eb.js\"],\"\"]\nf:I[7140,[\"972\",\"static/chunks/972-17ea62b17795b286.js\",\"185\",\"static/chunks/app/layout-8486db2c9a537bdb.js\"],\"default\"]\ne:T66f0,"])</script><script>self.__next_f.push([1,"\u003ch1\u003e热门系统设计题及解题思路\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e系统设计面试是技术面试的重要环节，掌握解题方法是关键\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003e系统设计方法论\u003c/h2\u003e\n\u003ch3\u003e1. 设计流程\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003e系统设计流程：\n├── 需求分析\n│   ├── 功能需求\n│   ├── 非功能需求\n│   └── 约束条件\n├── 估算\n│   ├── QPS估算\n│   ├── 存储估算\n│   └── 带宽估算\n├── 架构设计\n│   ├── 分层架构\n│   ├── 服务拆分\n│   └── 数据流设计\n├── 技术选型\n│   ├── 数据库选型\n│   ├── 缓存选型\n│   └── 消息队列选型\n├── 优化\n│   ├── 性能优化\n│   ├── 可用性优化\n│   └── 扩展性优化\n└── 总结\n    ├── 设计回顾\n    ├── 权衡取舍\n    └── 后续优化\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e2. 通用设计原则\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003e设计原则：\n├── 简单性\n│   ├── KISS原则\n│   ├── 避免过度设计\n│   └── 逐步迭代\n├── 可扩展性\n│   ├── 水平扩展\n│   ├── 垂直扩展\n│   └── 数据分片\n├── 可用性\n│   ├── 冗余设计\n│   ├── 故障隔离\n│   └── 自动恢复\n├── 性能\n│   ├── 缓存策略\n│   ├── 异步处理\n│   └── 负载均衡\n└── 一致性\n    ├── 强一致性\n    ├── 最终一致性\n    └── 一致性级别选择\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e经典题目分析\u003c/h2\u003e\n\u003ch3\u003e1. 设计短链接系统\u003c/h3\u003e\n\u003ch4\u003e1.1 需求分析\u003c/h4\u003e\n\u003cpre\u003e\u003ccode\u003e功能需求：\n- 用户输入长URL，生成短链接\n- 用户访问短链接，重定向到长URL\n- 支持自定义短链接\n- 支持链接过期时间\n- 支持访问统计\n\n非功能需求：\n- 高可用性：99.9%\n- 低延迟：生成\u0026lt;100ms，访问\u0026lt;50ms\n- 高并发：支持1000 QPS\n- 可扩展：支持水平扩展\n\n约束条件：\n- 短链接长度：6-8位\n- 字符集：a-zA-Z0-9\n- 短链接有效期：1年\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e1.2 系统架构\u003c/h4\u003e\n\u003cpre\u003e\u003ccode\u003e系统架构图：\n┌─────────────────────────────────────────────────────────────┐\n│                    CDN                                     │\n└─────────────────────────────────────────────────────────────┘\n                          │\n                    ┌─────────────┐\n                    │  Load        │\n                    │  Balancer    │\n                    └─────────────┘\n                          │\n          ┌───────────────┼───────────────┐\n          │               │               │\n    ┌─────────────┐ ┌─────────────┐ ┌─────────────┐\n    │  Web        │ │  Web        │ │  Web        │\n    │  Server     │ │  Server     │ │  Server     │\n    └─────────────┘ └─────────────┘ └─────────────┘\n          │               │               │\n          └───────────────┼───────────────┘\n                          │\n          ┌───────────────┼───────────────┐\n          │               │               │\n    ┌─────────────┐ ┌─────────────┐ ┌─────────────┐\n    │  Redis      │ │  MySQL      │ │  Analytics  │\n    │  Cluster    │ │  Master     │ │  Service    │\n    └─────────────┘ └─────────────┘ └─────────────┘\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e1.3 核心算法\u003c/h4\u003e\n\u003cp\u003e\u003cstrong\u003eBase62编码算法\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class Base62Encoder {\n    private static final String BASE62_CHARS = \n        \u0026quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\u0026quot;;\n    \n    public static String encode(long num) {\n        if (num == 0) {\n            return \u0026quot;a\u0026quot;;\n        }\n        \n        StringBuilder sb = new StringBuilder();\n        while (num \u0026gt; 0) {\n            sb.append(BASE62_CHARS.charAt((int)(num % 62)));\n            num /= 62;\n        }\n        \n        return sb.reverse().toString();\n    }\n    \n    public static long decode(String str) {\n        long num = 0;\n        for (int i = 0; i \u0026lt; str.length(); i++) {\n            num = num * 62 + BASE62_CHARS.indexOf(str.charAt(i));\n        }\n        return num;\n    }\n}\n\n// 短链接生成服务\n@Service\npublic class ShortLinkService {\n    \n    @Autowired\n    private RedisTemplate\u0026lt;String, String\u0026gt; redisTemplate;\n    \n    @Autowired\n    private ShortLinkMapper shortLinkMapper;\n    \n    private final AtomicLong idGenerator = new AtomicLong(1000000);\n    \n    public String generateShortLink(String longUrl) {\n        // 1. 检查是否已存在\n        String shortLink = getExistingShortLink(longUrl);\n        if (shortLink != null) {\n            return shortLink;\n        }\n        \n        // 2. 生成新的短链接\n        long id = idGenerator.getAndIncrement();\n        String code = Base62Encoder.encode(id);\n        \n        // 3. 存储映射关系\n        storeMapping(code, longUrl);\n        \n        return \u0026quot;https://short.ly/\u0026quot; + code;\n    }\n    \n    private String getExistingShortLink(String longUrl) {\n        String key = \u0026quot;url:hash:\u0026quot; + DigestUtils.md5Hex(longUrl);\n        return redisTemplate.opsForValue().get(key);\n    }\n    \n    private void storeMapping(String code, String longUrl) {\n        // 存储到Redis\n        redisTemplate.opsForValue().set(\u0026quot;code:\u0026quot; + code, longUrl, 365, TimeUnit.DAYS);\n        redisTemplate.opsForValue().set(\u0026quot;url:hash:\u0026quot; + \n            DigestUtils.md5Hex(longUrl), code, 365, TimeUnit.DAYS);\n        \n        // 异步存储到MySQL\n        asyncStoreToMySQL(code, longUrl);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e重定向服务\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@RestController\npublic class RedirectController {\n    \n    @Autowired\n    private ShortLinkService shortLinkService;\n    \n    @GetMapping(\u0026quot;/{code}\u0026quot;)\n    public RedirectView redirect(@PathVariable String code, \n                               HttpServletRequest request) {\n        String longUrl = shortLinkService.getLongUrl(code);\n        if (longUrl == null) {\n            throw new NotFoundException(\u0026quot;Short link not found\u0026quot;);\n        }\n        \n        // 记录访问日志\n        shortLinkService.recordAccess(code, request);\n        \n        RedirectView redirectView = new RedirectView();\n        redirectView.setUrl(longUrl);\n        return redirectView;\n    }\n}\n\n@Service\npublic class ShortLinkService {\n    \n    public String getLongUrl(String code) {\n        // 先从Redis获取\n        String longUrl = redisTemplate.opsForValue().get(\u0026quot;code:\u0026quot; + code);\n        if (longUrl != null) {\n            return longUrl;\n        }\n        \n        // 从数据库获取\n        ShortLinkEntity entity = shortLinkMapper.selectByCode(code);\n        if (entity != null) {\n            // 回写Redis\n            redisTemplate.opsForValue().set(\u0026quot;code:\u0026quot; + code, \n                entity.getLongUrl(), 365, TimeUnit.DAYS);\n            return entity.getLongUrl();\n        }\n        \n        return null;\n    }\n    \n    public void recordAccess(String code, HttpServletRequest request) {\n        AccessLog log = new AccessLog();\n        log.setCode(code);\n        log.setIp(getClientIp(request));\n        log.setUserAgent(request.getHeader(\u0026quot;User-Agent\u0026quot;));\n        log.setAccessTime(new Date());\n        \n        // 异步记录访问日志\n        asyncRecordAccess(log);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e2. 设计Feed流系统\u003c/h3\u003e\n\u003ch4\u003e2.1 需求分析\u003c/h4\u003e\n\u003cpre\u003e\u003ccode\u003e功能需求：\n- 用户发布动态\n- 查看关注人的动态\n- 点赞、评论、转发\n- 推荐热门内容\n\n非功能需求：\n- 支持千万级用户\n- 实时性：延迟\u0026lt;1秒\n- 高并发：写1000 QPS，读10000 QPS\n- 数据一致性：最终一致性\n\n约束条件：\n- 每个用户关注人数：1000\n- 每条动态存活时间：30天\n- 缓存命中率：\u0026gt;90%\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e2.2 架构设计\u003c/h4\u003e\n\u003cpre\u003e\u003ccode\u003eFeed流架构：\n┌─────────────────────────────────────────────────────────────┐\n│                    API Gateway                              │\n└─────────────────────────────────────────────────────────────┘\n                          │\n                    ┌─────────────┐\n                    │  Load        │\n                    │  Balancer    │\n                    └─────────────┘\n                          │\n          ┌───────────────┼───────────────┐\n          │               │               │\n    ┌─────────────┐ ┌─────────────┐ ┌─────────────┐\n    │  Feed       │ │  Feed       │ │  Feed       │\n    │  Service    │ │  Service    │ │  Service    │\n    └─────────────┘ └─────────────┘ └─────────────┘\n          │               │               │\n          └───────────────┼───────────────┘\n                          │\n          ┌───────────────┼───────────────┐\n          │               │               │\n    ┌─────────────┐ ┌─────────────┐ ┌─────────────┐\n    │  Redis      │ │  Kafka      │ │  MySQL      │\n    │  Cluster    │ │  Cluster    │ │  Cluster    │\n    └─────────────┘ └─────────────┘ └─────────────┘\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e2.3 核心实现\u003c/h4\u003e\n\u003cp\u003e\u003cstrong\u003e推拉结合模式\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@Service\npublic class FeedService {\n    \n    @Autowired\n    private RedisTemplate\u0026lt;String, String\u0026gt; redisTemplate;\n    \n    @Autowired\n    private KafkaTemplate\u0026lt;String, String\u0026gt; kafkaTemplate;\n    \n    // 发布动态（推模式）\n    public void publishFeed(Long userId, String content) {\n        // 1. 保存动态到数据库\n        FeedEntity feed = new FeedEntity();\n        feed.setUserId(userId);\n        feed.setContent(content);\n        feed.setCreateTime(new Date());\n        feedRepository.save(feed);\n        \n        // 2. 获取关注者列表\n        List\u0026lt;Long\u0026gt; followers = getFollowers(userId);\n        \n        // 3. 推送到关注者的收件箱（推模式）\n        for (Long followerId : followers) {\n            String inboxKey = \u0026quot;feed:inbox:\u0026quot; + followerId;\n            redisTemplate.opsForZSet().add(inboxKey, \n                String.valueOf(feed.getId()), feed.getCreateTime().getTime());\n            \n            // 限制收件箱大小\n            long size = redisTemplate.opsForZSet().size(inboxKey);\n            if (size \u0026gt; 1000) {\n                redisTemplate.opsForZSet().removeRange(inboxKey, 0, size - 1000);\n            }\n        }\n        \n        // 4. 发送消息到MQ进行异步处理\n        FeedMessage message = new FeedMessage();\n        message.setUserId(userId);\n        message.setFeedId(feed.getId());\n        message.setAction(\u0026quot;PUBLISH\u0026quot;);\n        \n        kafkaTemplate.send(\u0026quot;feed-topic\u0026quot;, JSON.toJSONString(message));\n    }\n    \n    // 获取Feed流（拉模式 + 推模式）\n    public List\u0026lt;FeedEntity\u0026gt; getFeed(Long userId, int page, int size) {\n        // 1. 从Redis收件箱获取动态ID列表（推模式）\n        String inboxKey = \u0026quot;feed:inbox:\u0026quot; + userId;\n        Set\u0026lt;String\u0026gt; feedIds = redisTemplate.opsForZSet()\n            .reverseRange(inboxKey, page * size, (page + 1) * size - 1);\n        \n        List\u0026lt;FeedEntity\u0026gt; feeds = new ArrayList\u0026lt;\u0026gt;();\n        \n        if (feedIds != null \u0026amp;\u0026amp; !feedIds.isEmpty()) {\n            // 2. 批量获取动态内容\n            feeds = batchGetFeeds(feedIds);\n        }\n        \n        // 3. 如果收件箱内容不足，补充拉模式（获取关注者的最新动态）\n        if (feeds.size() \u0026lt; size) {\n            List\u0026lt;Long\u0026gt; followees = getFollowees(userId);\n            List\u0026lt;FeedEntity\u0026gt; additionalFeeds = pullFolloweesFeeds(followees, \n                feeds.size(), size - feeds.size());\n            feeds.addAll(additionalFeeds);\n        }\n        \n        return feeds;\n    }\n    \n    // 批量获取动态\n    private List\u0026lt;FeedEntity\u0026gt; batchGetFeeds(Set\u0026lt;String\u0026gt; feedIds) {\n        List\u0026lt;Long\u0026gt; ids = feedIds.stream()\n            .map(Long::parseLong)\n            .collect(Collectors.toList());\n        \n        return feedRepository.findAllById(ids);\n    }\n    \n    // 拉取关注者的动态\n    private List\u0026lt;FeedEntity\u0026gt; pullFolloweesFeeds(List\u0026lt;Long\u0026gt; followees, \n                                               int offset, int limit) {\n        return feedRepository.findTopFeedsByUsers(followees, offset, limit);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e推荐算法\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@Service\npublic class FeedRecommendService {\n    \n    @Autowired\n    private RedisTemplate\u0026lt;String, String\u0026gt; redisTemplate;\n    \n    // 基于协同过滤的推荐\n    public List\u0026lt;FeedEntity\u0026gt; recommendFeeds(Long userId, int count) {\n        // 1. 获取用户兴趣标签\n        Set\u0026lt;String\u0026gt; userTags = getUserTags(userId);\n        \n        // 2. 获取热门动态\n        List\u0026lt;FeedEntity\u0026gt; hotFeeds = getHotFeeds(count * 2);\n        \n        // 3. 根据兴趣标签过滤和排序\n        List\u0026lt;FeedEntity\u0026gt; recommendedFeeds = hotFeeds.stream()\n            .filter(feed -\u0026gt; calculateRelevance(feed, userTags) \u0026gt; 0.5)\n            .sorted((f1, f2) -\u0026gt; Double.compare(\n                calculateRelevance(f2, userTags), \n                calculateRelevance(f1, userTags)))\n            .limit(count)\n            .collect(Collectors.toList());\n        \n        return recommendedFeeds;\n    }\n    \n    // 计算动态相关性\n    private double calculateRelevance(FeedEntity feed, Set\u0026lt;String\u0026gt; userTags) {\n        Set\u0026lt;String\u0026gt; feedTags = extractTags(feed.getContent());\n        \n        // 计算Jaccard相似度\n        Set\u0026lt;String\u0026gt; intersection = new HashSet\u0026lt;\u0026gt;(userTags);\n        intersection.retainAll(feedTags);\n        \n        Set\u0026lt;String\u0026gt; union = new HashSet\u0026lt;\u0026gt;(userTags);\n        union.addAll(feedTags);\n        \n        return union.isEmpty() ? 0.0 : (double) intersection.size() / union.size();\n    }\n    \n    // 获取热门动态\n    private List\u0026lt;FeedEntity\u0026gt; getHotFeeds(int count) {\n        // 基于Redis的热度排行榜\n        String hotKey = \u0026quot;feed:hot\u0026quot;;\n        Set\u0026lt;String\u0026gt; feedIds = redisTemplate.opsForZSet()\n            .reverseRange(hotKey, 0, count - 1);\n        \n        if (feedIds != null) {\n            return batchGetFeeds(feedIds);\n        }\n        \n        return Collections.emptyList();\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e3. 设计秒杀系统\u003c/h3\u003e\n\u003ch4\u003e3.1 需求分析\u003c/h4\u003e\n\u003cpre\u003e\u003ccode\u003e功能需求：\n- 商品展示\n- 秒杀下单\n- 库存管理\n- 订单管理\n\n非功能需求：\n- 高并发：支持10万QPS\n- 低延迟：下单\u0026lt;50ms\n- 高可用：99.9%\n- 数据一致性：不超卖\n\n约束条件：\n- 秒杀时长：5分钟\n- 每个用户限购1件\n- 库存：1000件\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e3.2 架构设计\u003c/h4\u003e\n\u003cpre\u003e\u003ccode\u003e秒杀系统架构：\n┌─────────────────────────────────────────────────────────────┐\n│                    CDN                                     │\n└─────────────────────────────────────────────────────────────┘\n                          │\n                    ┌─────────────┐\n                    │  Load        │\n                    │  Balancer    │\n                    └─────────────┘\n                          │\n          ┌───────────────┼───────────────┐\n          │               │               │\n    ┌─────────────┐ ┌─────────────┐ ┌─────────────┐\n    │  Web        │ │  Web        │ │  Web        │\n    │  Server     │ │  Server     │ │  Server     │\n    └─────────────┘ └─────────────┘ └─────────────┘\n          │               │               │\n          └───────────────┼───────────────┘\n                          │\n          ┌───────────────┼───────────────┐\n          │               │               │\n    ┌─────────────┐ ┌─────────────┐ ┌─────────────┐\n    │  Redis      │ │  MQ         │ │  MySQL      │\n    │  Cluster    │ │  Cluster    │ │  Master     │\n    └─────────────┘ └─────────────┘ └─────────────┘\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e3.3 核心实现\u003c/h4\u003e\n\u003cp\u003e\u003cstrong\u003e库存管理\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@Service\npublic class SeckillService {\n    \n    @Autowired\n    private RedisTemplate\u0026lt;String, String\u0026gt; redisTemplate;\n    \n    @Autowired\n    private RabbitTemplate rabbitTemplate;\n    \n    // 预热库存\n    public void warmUpStock(Long productId, int stock) {\n        String stockKey = \u0026quot;seckill:stock:\u0026quot; + productId;\n        redisTemplate.opsForValue().set(stockKey, String.valueOf(stock));\n        \n        // 预热用户购买记录\n        String userKey = \u0026quot;seckill:user:\u0026quot; + productId;\n        // 预分配空间\n        redisTemplate.opsForHash().put(userKey, \u0026quot;init\u0026quot;, \u0026quot;0\u0026quot;);\n    }\n    \n    // 秒杀下单\n    @Transactional\n    public SeckillResult seckill(Long productId, Long userId) {\n        // 1. 检查用户是否已购买\n        if (hasPurchased(productId, userId)) {\n            return SeckillResult.error(\u0026quot;已购买\u0026quot;);\n        }\n        \n        // 2. 原子性扣减库存\n        String stockKey = \u0026quot;seckill:stock:\u0026quot; + productId;\n        Long result = redisTemplate.execute(\n            new DefaultRedisScript\u0026lt;\u0026gt;(SECKILL_SCRIPT, Long.class),\n            Collections.singletonList(stockKey),\n            String.valueOf(userId)\n        );\n        \n        if (result == null || result == 0) {\n            return SeckillResult.error(\u0026quot;库存不足\u0026quot;);\n        }\n        \n        // 3. 发送MQ消息\n        SeckillMessage message = new SeckillMessage();\n        message.setProductId(productId);\n        message.setUserId(userId);\n        message.setCreateTime(new Date());\n        \n        rabbitTemplate.convertAndSend(\u0026quot;seckill.queue\u0026quot;, message);\n        \n        return SeckillResult.success(\u0026quot;抢购成功\u0026quot;);\n    }\n    \n    // Lua脚本：原子性操作\n    private static final String SECKILL_SCRIPT = \n        \u0026quot;local stock = redis.call(\u0026#39;GET\u0026#39;, KEYS[1]) \u0026quot; +\n        \u0026quot;if tonumber(stock) \u0026lt;= 0 then \u0026quot; +\n        \u0026quot;  return 0 \u0026quot; +\n        \u0026quot;end \u0026quot; +\n        \u0026quot;local userKey = \u0026#39;seckill:user:\u0026#39; .. KEYS[1] \u0026quot; +\n        \u0026quot;if redis.call(\u0026#39;HEXISTS\u0026#39;, userKey, ARGV[1]) == 1 then \u0026quot; +\n        \u0026quot;  return -1 \u0026quot; +\n        \u0026quot;end \u0026quot; +\n        \u0026quot;redis.call(\u0026#39;DECR\u0026#39;, KEYS[1]) \u0026quot; +\n        \u0026quot;redis.call(\u0026#39;HSET\u0026#39;, userKey, ARGV[1], \u0026#39;1\u0026#39;) \u0026quot; +\n        \u0026quot;return 1\u0026quot;;\n    \n    private boolean hasPurchased(Long productId, Long userId) {\n        String userKey = \u0026quot;seckill:user:\u0026quot; + productId;\n        return redisTemplate.opsForHash().hasKey(userKey, String.valueOf(userId));\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e限流保护\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@Component\npublic class RateLimiter {\n    \n    private final Map\u0026lt;String, Bucket\u0026gt; buckets = new ConcurrentHashMap\u0026lt;\u0026gt;();\n    \n    // 令牌桶限流\n    public boolean tryAcquire(String key, int permits, double rate) {\n        Bucket bucket = buckets.computeIfAbsent(key, k -\u0026gt; {\n            Refill refill = Refill.intervally(permits, Duration.ofSeconds((int) (permits / rate)));\n            return Bucket.builder()\n                .addLimit(Bandwidth.classic(permits, refill))\n                .build();\n        });\n        \n        return bucket.tryConsume(permits);\n    }\n    \n    // 滑动窗口限流\n    public boolean tryAcquireWithSlidingWindow(String key, int permits, int windowSize) {\n        String windowKey = \u0026quot;rate:limit:\u0026quot; + key;\n        long currentTime = System.currentTimeMillis();\n        \n        // 清理过期记录\n        redisTemplate.execute(\n            new DefaultRedisScript\u0026lt;\u0026gt;(CLEANUP_SCRIPT, Long.class),\n            Collections.singletonList(windowKey),\n            String.valueOf(currentTime - windowSize * 1000)\n        );\n        \n        // 检查当前窗口内的请求数\n        Long currentCount = redisTemplate.opsForZSet().count(windowKey, \n            currentTime - windowSize * 1000, currentTime);\n        \n        if (currentCount \u0026lt; permits) {\n            // 添加当前请求\n            redisTemplate.opsForZSet().add(windowKey, \n                String.valueOf(currentTime), currentTime);\n            return true;\n        }\n        \n        return false;\n    }\n    \n    private static final String CLEANUP_SCRIPT = \n        \u0026quot;redis.call(\u0026#39;ZREMRANGEBYSCORE\u0026#39;, KEYS[1], 0, ARGV[1]) \u0026quot; +\n        \u0026quot;return redis.call(\u0026#39;ZCARD\u0026#39;, KEYS[1])\u0026quot;;\n}\n\n@RestController\npublic class SeckillController {\n    \n    @Autowired\n    private SeckillService seckillService;\n    \n    @Autowired\n    private RateLimiter rateLimiter;\n    \n    @PostMapping(\u0026quot;/seckill/{productId}\u0026quot;)\n    public Result seckill(@PathVariable Long productId) {\n        Long userId = getCurrentUserId();\n        \n        // 接口级别限流\n        if (!rateLimiter.tryAcquire(\u0026quot;seckill:api\u0026quot;, 1000, 1000)) {\n            return Result.error(\u0026quot;系统繁忙\u0026quot;);\n        }\n        \n        // 用户级别限流\n        if (!rateLimiter.tryAcquire(\u0026quot;seckill:user:\u0026quot; + userId, 1, 10)) {\n            return Result.error(\u0026quot;操作过于频繁\u0026quot;);\n        }\n        \n        return seckillService.seckill(productId, userId);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e系统设计技巧\u003c/h2\u003e\n\u003ch3\u003e1. 性能优化\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003e性能优化策略：\n├── 缓存\n│   ├── 多级缓存\n│   ├── 缓存预热\n│   ├── 缓存更新\n│   └── 缓存穿透/雪崩\n├── 异步\n│   ├── 消息队列\n│   ├── 异步处理\n│   ├── 批量操作\n│   └── 异步回调\n├── 数据库\n│   ├── 索引优化\n│   ├── 读写分离\n│   ├── 分库分表\n│   └── 连接池优化\n└── 网络\n    ├── CDN加速\n    ├── HTTP/2\n    ├── 压缩传输\n    └── 连接复用\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e2. 可扩展性设计\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003e可扩展性原则：\n├── 无状态服务\n│   ├── 会话外部化\n│   ├── 文件存储\n│   └── 负载均衡\n├── 数据分片\n│   ├── 水平分片\n│   ├── 垂直分片\n│   └── 分片算法\n├── 微服务架构\n│   ├── 服务拆分\n│   ├── 服务治理\n│   └── 服务编排\n└── 弹性伸缩\n    ├── 自动扩容\n    ├── 负载监控\n    └── 资源调度\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e3. 面试技巧\u003c/h3\u003e\n\u003cpre\u003e\u003ccode\u003e面试答题技巧：\n├── 沟通确认\n│   ├── 明确需求\n│   ├── 确认约束\n│   └── 边界条件\n├── 结构化回答\n│   ├── 总体架构\n│   ├── 核心模块\n│   ├── 技术细节\n│   └── 优化改进\n├── 权衡取舍\n│   ├── 性能vs成本\n│   ├── 一致性vs可用性\n│   ├── 复杂度vs可维护性\n│   └── 安全vs便利性\n└── 总结回顾\n    ├── 设计亮点\n    ├── 潜在问题\n    ├── 优化方向\n    └── 扩展思路\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e总结\u003c/h2\u003e\n\u003cp\u003e系统设计是一个综合性技能，需要掌握：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e设计方法论\u003c/strong\u003e：系统的设计流程和思考方式\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e技术广度\u003c/strong\u003e：了解各种技术的特点和应用场景\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e实战经验\u003c/strong\u003e：通过实际项目积累经验\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e持续学习\u003c/strong\u003e：关注新技术和最佳实践\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e沟通表达\u003c/strong\u003e：能够清晰地表达设计思路\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e通过不断练习和总结，可以逐步提升系统设计能力，在面试和实际工作中都能设计出优秀的系统架构。\u003c/p\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"children\":[[\"$\",\"$Ld\",null,{\"href\":\"/notes\",\"className\":\"back-button\",\"style\":{\"display\":\"inline-block\",\"background\":\"var(--primary-color)\",\"color\":\"white\",\"border\":\"none\",\"padding\":\"10px 20px\",\"borderRadius\":\"6px\",\"cursor\":\"pointer\",\"marginBottom\":\"20px\",\"textDecoration\":\"none\"},\"children\":[\"← 返回\",\"笔记\",\"列表\"]}],[\"$\",\"article\",null,{\"className\":\"section\",\"children\":[[\"$\",\"header\",null,{\"className\":\"article-header\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"article-title\",\"children\":\"热门系统设计题及解题思路\"}],[\"$\",\"div\",null,{\"className\":\"article-meta\",\"children\":[[\"$\",\"div\",null,{\"className\":\"article-meta-info\",\"children\":[[\"$\",\"span\",null,{\"className\":\"article-date\",\"children\":\"2024-10-14\"}],[\"$\",\"span\",null,{\"className\":\"article-category\",\"children\":[\"• \",\"笔记\"]}]]}],[\"$\",\"div\",null,{\"className\":\"article-tags\",\"children\":[[\"$\",\"span\",\"系统设计\",{\"className\":\"tag\",\"children\":\"系统设计\"}],[\"$\",\"span\",\"面试\",{\"className\":\"tag\",\"children\":\"面试\"}],[\"$\",\"span\",\"架构设计\",{\"className\":\"tag\",\"children\":\"架构设计\"}],[\"$\",\"span\",\"分布式系统\",{\"className\":\"tag\",\"children\":\"分布式系统\"}],[\"$\",\"span\",\"技术方案\",{\"className\":\"tag\",\"children\":\"技术方案\"}]]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"card markdown-content\",\"dangerouslySetInnerHTML\":{\"__html\":\"$e\"}}]]}]]}]\n"])</script><script>self.__next_f.push([1,"9:[\"$\",\"html\",null,{\"lang\":\"zh-CN\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"link\",null,{\"rel\":\"stylesheet\",\"href\":\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css\"}],[\"$\",\"link\",null,{\"rel\":\"stylesheet\",\"href\":\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css\"}]]}],[\"$\",\"body\",null,{\"children\":[\"$\",\"div\",null,{\"className\":\"app\",\"children\":[[\"$\",\"$Lf\",null,{\"siteConfig\":{\"name\":\"Rudy Yang\",\"bio\":\"JAVA | AI | WEB3\",\"social\":[{\"name\":\"github\",\"icon\":\"fab fa-github\",\"url\":\"https://github.com/suogongy\"},{\"name\":\"twitter\",\"icon\":\"fab fa-twitter\",\"url\":\"https://twitter.com/suogongy\"},{\"name\":\"email\",\"icon\":\"fas fa-envelope\",\"url\":\"mailto:haiyuan1832@163.com\"}]}}],[\"$\",\"main\",null,{\"className\":\"main-content\",\"children\":[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"热门系统设计题及解题思路 - Personal GitHub Page\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"深入分析常见的系统设计面试题，包括设计思路、架构方案和技术选型，帮助开发者掌握系统设计的核心方法。\"}]]\n3:null\n"])</script></body></html>