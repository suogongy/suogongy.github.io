<!DOCTYPE html><html lang="zh-CN"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/eb4a34bff42c1814.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-c81f7fd28659d64f.js"/><script src="/_next/static/chunks/fd9d1056-e3d373074663785d.js" async=""></script><script src="/_next/static/chunks/117-86f31d03f8df68a5.js" async=""></script><script src="/_next/static/chunks/main-app-1bdc7b9537d0c130.js" async=""></script><script src="/_next/static/chunks/972-81dbad6abe39d3fa.js" async=""></script><script src="/_next/static/chunks/832-7ea2624e20755f9f.js" async=""></script><script src="/_next/static/chunks/app/%5Bcategory%5D/%5Bslug%5D/page-e466df95e55c7602.js" async=""></script><script src="/_next/static/chunks/app/layout-3ed2f387fb22aa2c.js" async=""></script><title>Redis高可用实战 - Personal GitHub Page</title><meta name="description" content="详细介绍Redis高可用架构的设计原理、实现方案和最佳实践，包括主从复制、哨兵模式、集群模式等核心技术的深入解析。"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css"/><script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body><div class="app"><header class="header "><nav class="nav-container"><a class="nav-brand" href="/"><i class="fas fa-terminal"></i>Rudy Yang</a><ul class="nav-menu"><li><a class="nav-link " href="/"><i class="fas fa-home"></i> 首页</a></li><li><a class="nav-link " href="/about/"><i class="fas fa-user"></i> 关于</a></li><li><a class="nav-link " href="/projects/"><i class="fas fa-code"></i> 项目</a></li><li><a class="nav-link " href="/notes/"><i class="fas fa-book"></i> 笔记</a></li><li><a class="nav-link " href="/articles/"><i class="fas fa-pen"></i> 随笔</a></li></ul></nav></header><main class="main-content"><div><a class="back-button" style="display:inline-block;background:var(--primary-color);color:white;border:none;padding:10px 20px;border-radius:6px;cursor:pointer;margin-bottom:20px;text-decoration:none" href="/notes/">← 返回<!-- -->笔记<!-- -->列表</a><article class="section"><header class="article-header"><h1 class="article-title">Redis高可用实战</h1><div class="article-meta"><div class="article-tags"><span class="tag">Redis</span><span class="tag">高可用</span><span class="tag">集群</span><span class="tag">哨兵</span><span class="tag">分布式缓存</span></div></div></header><div class="card markdown-content"><div class="markdown-content"><div><h1>Redis高可用实战</h1>
<blockquote>
<p>构建高可用的Redis架构是保障系统稳定性的关键</p>
</blockquote>
<h2>引言</h2>
<p>Redis作为高性能的内存数据库，在互联网应用中扮演着重要的角色。然而，单节点的Redis实例存在单点故障风险，一旦宕机会影响整个系统的可用性。本文将详细介绍Redis高可用架构的设计原理和实现方案。</p>
<h2>Redis高可用架构概述</h2>
<h3>1. 高可用架构目标</h3>
<p><strong>可用性指标</strong></p>
<ul>
<li>99.9%可用性（年停机时间不超过8.76小时）</li>
<li>99.99%可用性（年停机时间不超过52分钟）</li>
<li>快速故障检测和恢复（RTO &lt; 30秒）</li>
<li>最小数据丢失（RPO &lt; 1秒）</li>
</ul>
<p><strong>性能指标</strong></p>
<ul>
<li>高并发处理能力（十万级QPS）</li>
<li>低延迟响应（P99 &lt; 1ms）</li>
<li>高吞吐量（百万级OPS）</li>
<li>线性扩展能力</li>
</ul>
<h3>2. 高可用架构模式</h3>
<p><strong>主从模式</strong></p>
<ul>
<li>一主多从的复制架构</li>
<li>读写分离，提升读性能</li>
<li>主节点故障时需要手动切换</li>
<li>适合对可用性要求不高的场景</li>
</ul>
<p><strong>哨兵模式</strong></p>
<ul>
<li>自动监控和故障转移</li>
<li>哨兵集群监控主从节点</li>
<li>自动选举新的主节点</li>
<li>适合中小型应用</li>
</ul>
<p><strong>集群模式</strong></p>
<ul>
<li>分布式集群架构</li>
<li>数据分片存储</li>
<li>自动故障转移和恢复</li>
<li>适合大规模应用</li>
</ul>
<h2>主从复制架构</h2>
<h3>1. 主从复制配置</h3>
<p><strong>主节点配置</strong>：</p>
<pre><code class="language-conf"># redis.conf
bind 0.0.0.0
port 6379
requirepass your_password
masterauth your_password

# 持久化配置
save 900 1
save 300 10
save 60 10000
appendonly yes
appendfsync everysec
</code></pre>
<p><strong>从节点配置</strong>：</p>
<pre><code class="language-conf"># redis.conf
bind 0.0.0.0
port 6379
requirepass your_password

# 复制配置
replicaof master_ip 6379
masterauth your_password

# 只读模式
replica-read-only yes
</code></pre>
<p><strong>动态配置</strong>：</p>
<pre><code class="language-bash"># 在从节点执行
redis-cli -a your_password replicaof master_ip 6379

# 查看复制状态
redis-cli -a your_password info replication
</code></pre>
<h3>2. 复制原理详解</h3>
<p><strong>复制过程</strong>：</p>
<ol>
<li>从节点向主节点发送SYNC命令</li>
<li>主节点生成RDB快照文件</li>
<li>主节点将RDB文件发送给从节点</li>
<li>从节点加载RDB文件并恢复数据</li>
<li>主节点将写命令发送给从节点执行</li>
</ol>
<p><strong>增量复制</strong>：</p>
<pre><code class="language-bash"># 查看复制偏移量
redis-cli -a your_password info replication

# 主节点输出
master_replid:83a3b4f1d9e4f2a7b8c9d0e1f2a3b4c5d6e7f8a9
master_repl_offset:12345

# 从节点输出
slave_repl_offset:12345
</code></pre>
<h3>3. 复制延迟监控</h3>
<p><strong>监控脚本</strong>：</p>
<pre><code class="language-bash">#!/bin/bash
# monitor_replication_lag.sh

REDIS_CLI=&quot;redis-cli -a your_password&quot;
MASTER_IP=&quot;master_ip&quot;
SLAVE_IP=&quot;slave_ip&quot;

# 获取主节点偏移量
MASTER_OFFSET=$($REDIS_CLI -h $MASTER_IP info replication | grep master_repl_offset | cut -d: -f2)

# 获取从节点偏移量
SLAVE_OFFSET=$($REDIS_CLI -h $SLAVE_IP info replication | grep slave_repl_offset | cut -d: -f2)

# 计算延迟
LAG=$((MASTER_OFFSET - SLAVE_OFFSET))

if [ $LAG -gt 10000 ]; then
    echo &quot;WARNING: Replication lag is high: $LAG&quot;
    # 发送告警
fi
</code></pre>
<h2>哨兵模式架构</h2>
<h3>1. 哨兵配置</h3>
<p><strong>哨兵配置文件</strong>：</p>
<pre><code class="language-conf"># sentinel.conf
port 26379
sentinel monitor mymaster master_ip 6379 2
sentinel auth-pass mymaster your_password
sentinel down-after-milliseconds mymaster 5000
sentinel failover-timeout mymaster 180000
sentinel parallel-syncs mymaster 1
sentinel notification-script mymaster /opt/redis/sentinel_notify.sh
sentinel client-reconfig-script mymaster /opt/redis/sentinel_reconfig.sh
</code></pre>
<p><strong>多哨兵部署</strong>：</p>
<pre><code class="language-bash"># 在不同服务器上启动哨兵
redis-sentinel /opt/redis/sentinel.conf --port 26379
redis-sentinel /opt/redis/sentinel.conf --port 26380
redis-sentinel /opt/redis/sentinel.conf --port 26381
</code></pre>
<h3>2. 哨兵工作原理</h3>
<p><strong>故障检测</strong>：</p>
<ol>
<li>哨兵定期向主节点发送PING命令</li>
<li>如果主节点在down-after-milliseconds时间内无响应</li>
<li>哨兵认为主节点主观下线（S_DOWN）</li>
<li>多个哨兵确认后，主节点客观下线（O_DOWN）</li>
</ol>
<p><strong>故障转移</strong>：</p>
<ol>
<li>哨兵从从节点中选举新的主节点</li>
<li>将其他从节点指向新的主节点</li>
<li>通知客户端新的主节点地址</li>
<li>监控故障节点的恢复情况</li>
</ol>
<h3>3. 哨兵监控脚本</h3>
<p><strong>监控脚本</strong>：</p>
<pre><code class="language-bash">#!/bin/bash
# sentinel_monitor.sh

SENTINEL_CLI=&quot;redis-cli -p 26379&quot;
MASTER_NAME=&quot;mymaster&quot;

# 检查主节点状态
MASTER_STATUS=$($SENTINEL_CLI sentinel masters | grep $MASTER_NAME)

if [ -z &quot;$MASTER_STATUS&quot; ]; then
    echo &quot;ERROR: Master not found in sentinel&quot;
    exit 1
fi

# 获取主节点IP和端口
MASTER_IP=$(echo $MASTER_STATUS | awk &#39;{print $3}&#39;)
MASTER_PORT=$(echo $MASTER_STATUS | awk &#39;{print $5}&#39;)

# 检查主节点是否可达
redis-cli -h $MASTER_IP -p $MASTER_PORT ping &gt; /dev/null 2&gt;&amp;1

if [ $? -ne 0 ]; then
    echo &quot;WARNING: Master $MASTER_IP:$MASTER_PORT is not reachable&quot;
fi
</code></pre>
<h2>Redis集群架构</h2>
<h3>1. 集群配置</h3>
<p><strong>集群节点配置</strong>：</p>
<pre><code class="language-conf"># redis.conf
cluster-enabled yes
cluster-config-file nodes-6379.conf
cluster-node-timeout 15000
cluster-require-full-coverage yes
cluster-announce-ip node_ip
cluster-announce-port 6379
cluster-announce-bus-port 16379
</code></pre>
<p><strong>集群初始化</strong>：</p>
<pre><code class="language-bash"># 创建集群
redis-cli --cluster create \
    node1:6379 node2:6379 node3:6379 \
    node4:6379 node5:6379 node6:6379 \
    --cluster-replicas 1

# 检查集群状态
redis-cli --cluster check node1:6379
</code></pre>
<h3>2. 分片原理</h3>
<p><strong>数据分片</strong>：</p>
<ul>
<li>使用CRC16算法计算key的哈希值</li>
<li>哈希值对16384取模，确定槽位</li>
<li>每个节点负责一定范围的槽位</li>
<li>支持动态槽位迁移</li>
</ul>
<p><strong>槽位分布</strong>：</p>
<pre><code class="language-bash"># 查看槽位分布
redis-cli cluster nodes

# 输出示例
# 3a3b4f1d9e4f2a7b8c9d0e1f2a3b4c5d6e7f8a9 192.168.1.10:6379@16379 master - 0 1234567890123 1 connected 0-5460
# b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2 192.168.1.11:6379@16379 master - 0 1234567890123 2 connected 5461-10922
# c6d7e8f9a0b1c2d3e4f5a6b7c8d9e0f1a2b3c4 192.168.1.12:6379@16379 master - 0 1234567890123 3 connected 10923-16383
</code></pre>
<h3>3. 故障转移</h3>
<p><strong>节点故障</strong>：</p>
<ol>
<li>集群检测到节点故障</li>
<li>主节点故障时，从节点自动升级为主节点</li>
<li>重新分配槽位，保证集群完整</li>
<li>客户端自动重定向到正确节点</li>
</ol>
<p><strong>手动故障转移</strong>：</p>
<pre><code class="language-bash"># 手动故障转移
redis-cli --cluster failover node_ip:6379

# 槽位重平衡
redis-cli --cluster rebalance node_ip:6379
</code></pre>
<h2>高可用客户端配置</h2>
<h3>1. Java客户端配置</h3>
<p><strong>Jedis哨兵配置</strong>：</p>
<pre><code class="language-java">import redis.clients.jedis.*;
import java.util.*;

public class RedisSentinelExample {
    
    private JedisSentinelPool sentinelPool;
    
    public void initSentinelPool() {
        Set&lt;String&gt; sentinels = new HashSet&lt;&gt;();
        sentinels.add(&quot;sentinel1:26379&quot;);
        sentinels.add(&quot;sentinel2:26379&quot;);
        sentinels.add(&quot;sentinel3:26379&quot;);
        
        JedisPoolConfig config = new JedisPoolConfig();
        config.setMaxTotal(100);
        config.setMaxIdle(20);
        config.setMinIdle(5);
        
        sentinelPool = new JedisSentinelPool(
            &quot;mymaster&quot;, 
            sentinels, 
            config, 
            2000, 
            &quot;your_password&quot;
        );
    }
    
    public void executeWithRetry() {
        try (Jedis jedis = sentinelPool.getResource()) {
            jedis.set(&quot;key&quot;, &quot;value&quot;);
            String result = jedis.get(&quot;key&quot;);
            System.out.println(result);
        } catch (JedisConnectionException e) {
            // 处理连接异常，自动重试
            executeWithRetry();
        }
    }
}
</code></pre>
<p><strong>Lettuce集群配置</strong>：</p>
<pre><code class="language-java">import io.lettuce.core.*;
import io.lettuce.core.cluster.*;

public class RedisClusterExample {
    
    private RedisClusterClient clusterClient;
    
    public void initClusterClient() {
        clusterClient = RedisClusterClient.create(
            RedisURI.create(&quot;redis://node1:6379&quot;)
        );
        
        ClusterTopologyRefreshOptions topologyOptions = 
            ClusterTopologyRefreshOptions.builder()
                .enablePeriodicRefresh(Duration.ofSeconds(60))
                .enableAllAdaptiveRefreshTriggers()
                .build();
        
        ClusterClientOptions clientOptions = ClusterClientOptions.builder()
            .topologyRefreshOptions(topologyOptions)
            .autoReconnect(true)
            .build();
            
        clusterClient.setOptions(clientOptions);
    }
    
    public void executeCommand() {
        StatefulRedisClusterConnection&lt;String, String&gt; connection = 
            clusterClient.connect();
            
        RedisAdvancedClusterCommands&lt;String, String&gt; commands = 
            connection.sync();
            
        commands.set(&quot;key&quot;, &quot;value&quot;);
        String result = commands.get(&quot;key&quot;);
        
        connection.close();
    }
}
</code></pre>
<h3>2. Python客户端配置</h3>
<p><strong>Redis-py哨兵配置</strong>：</p>
<pre><code class="language-python">import redis
from redis.sentinel import Sentinel

class RedisSentinelClient:
    
    def __init__(self):
        self.sentinel = Sentinel([
            (&#39;sentinel1&#39;, 26379),
            (&#39;sentinel2&#39;, 26379),
            (&#39;sentinel3&#39;, 26379)
        ], socket_timeout=0.1)
        
        self.master = self.sentinel.master_for(
            &#39;mymaster&#39;, 
            socket_timeout=0.1,
            password=&#39;your_password&#39;
        )
        
        self.slave = self.sentinel.slave_for(
            &#39;mymaster&#39;,
            socket_timeout=0.1,
            password=&#39;your_password&#39;
        )
    
    def write_operation(self):
        try:
            result = self.master.set(&#39;key&#39;, &#39;value&#39;)
            return result
        except redis.ConnectionError:
            # 重试逻辑
            return self.write_operation()
    
    def read_operation(self):
        try:
            result = self.slave.get(&#39;key&#39;)
            return result
        except redis.ConnectionError:
            # 降级到主节点读取
            return self.master.get(&#39;key&#39;)
</code></pre>
<p><strong>Redis-py集群配置</strong>：</p>
<pre><code class="language-python">from rediscluster import RedisCluster

class RedisClusterClient:
    
    def __init__(self):
        startup_nodes = [
            {&quot;host&quot;: &quot;node1&quot;, &quot;port&quot;: &quot;6379&quot;},
            {&quot;host&quot;: &quot;node2&quot;, &quot;port&quot;: &quot;6379&quot;},
            {&quot;host&quot;: &quot;node3&quot;, &quot;port&quot;: &quot;6379&quot;}
        ]
        
        self.client = RedisCluster(
            startup_nodes=startup_nodes,
            decode_responses=True,
            skip_full_coverage_check=True,
            max_connections_per_node=100
        )
    
    def execute_with_retry(self, func, *args, **kwargs):
        max_retries = 3
        for i in range(max_retries):
            try:
                return func(*args, **kwargs)
            except redis.exceptions.ConnectionError:
                if i == max_retries - 1:
                    raise
                continue
</code></pre>
<h2>监控和运维</h2>
<h3>1. 性能监控</h3>
<p><strong>关键指标监控</strong>：</p>
<pre><code class="language-bash"># 内存使用情况
redis-cli info memory | grep used_memory_human

# 连接数
redis-cli info clients

# 命令执行统计
redis-cli info stats

# 慢查询日志
redis-cli slowlog get 10
</code></pre>
<p><strong>Prometheus监控配置</strong>：</p>
<pre><code class="language-yaml"># redis_exporter配置
global:
  scrape_interval: 15s

scrape_configs:
  - job_name: &#39;redis&#39;
    static_configs:
      - targets: [&#39;redis-exporter:9121&#39;]
    relabel_configs:
      - source_labels: [__address__]
        target_label: __param_target
      - source_labels: [__param_target]
        target_label: instance
      - target_label: __address__
        replacement: redis-exporter:9121
</code></pre>
<h3>2. 告警规则</h3>
<p><strong>Grafana告警规则</strong>：</p>
<pre><code class="language-yaml">groups:
  - name: redis
    rules:
      - alert: RedisDown
        expr: redis_up == 0
        for: 1m
        labels:
          severity: critical
        annotations:
          summary: &quot;Redis instance is down&quot;
          
      - alert: RedisMemoryHigh
        expr: redis_memory_used_bytes / redis_memory_max_bytes &gt; 0.9
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: &quot;Redis memory usage is high&quot;
          
      - alert: RedisConnectionsHigh
        expr: redis_connected_clients &gt; 1000
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: &quot;Redis has too many connections&quot;
</code></pre>
<h3>3. 运维脚本</h3>
<p><strong>批量操作脚本</strong>：</p>
<pre><code class="language-bash">#!/bin/bash
# redis_cluster_ops.sh

NODES=(&quot;node1:6379&quot; &quot;node2:6379&quot; &quot;node3:6379&quot;)
PASSWORD=&quot;your_password&quot;

# 批量执行命令
execute_on_cluster() {
    local cmd=$1
    for node in &quot;${NODES[@]}&quot;; do
        echo &quot;Executing on $node: $cmd&quot;
        redis-cli -h ${node%:*} -p ${node#*:} -a $PASSWORD $cmd
    done
}

# 集群健康检查
cluster_health_check() {
    echo &quot;Checking cluster health...&quot;
    execute_on_cluster &quot;cluster nodes&quot;
    execute_on_cluster &quot;info replication&quot;
}

# 备份数据
backup_cluster() {
    local backup_dir=&quot;/backup/redis/$(date +%Y%m%d_%H%M%S)&quot;
    mkdir -p $backup_dir
    
    for node in &quot;${NODES[@]}&quot;; do
        redis-cli -h ${node%:*} -p ${node#*:} -a $PASSWORD \
            --rdb $backup_dir/${node%:*}.rdb
    done
}

# 调用示例
case &quot;$1&quot; in
    &quot;health&quot;)
        cluster_health_check
        ;;
    &quot;backup&quot;)
        backup_cluster
        ;;
    *)
        echo &quot;Usage: $0 {health|backup}&quot;
        ;;
esac
</code></pre>
<h2>性能优化</h2>
<h3>1. 内存优化</h3>
<p><strong>内存配置优化</strong>：</p>
<pre><code class="language-conf"># redis.conf
maxmemory 4gb
maxmemory-policy allkeys-lru

# 淘汰策略选择
# volatile-lru: 淘汰设置了TTL且最少使用的key
# allkeys-lru: 淘汰最少使用的key
# volatile-random: 随机淘汰设置了TTL的key
# allkeys-random: 随机淘汰key
# volatile-ttl: 淘汰即将过期的key
# noeviction: 不淘汰，返回错误
</code></pre>
<p><strong>数据结构优化</strong>：</p>
<pre><code class="language-bash"># 使用Hash代替String存储对象
HSET user:1001 name &quot;张三&quot; age 25 email &quot;zhangsan@example.com&quot;

# 使用List代替多个String
LPUSH recent:users user:1001 user:1002 user:1003

# 使用Set进行快速查找
SADD user:1001:tags tag1 tag2 tag3
SISMEMBER user:1001:tags tag1

# 使用Sorted Set进行排序
ZADD ranking 100 user:1001 90 user:1002 80 user:1003
</code></pre>
<h3>2. 网络优化</h3>
<p><strong>TCP参数优化</strong>：</p>
<pre><code class="language-conf"># 系统级优化
echo &#39;net.core.somaxconn = 65535&#39; &gt;&gt; /etc/sysctl.conf
echo &#39;net.ipv4.tcp_max_syn_backlog = 65535&#39; &gt;&gt; /etc/sysctl.conf
echo &#39;net.core.netdev_max_backlog = 5000&#39; &gt;&gt; /etc/sysctl.conf

sysctl -p
</code></pre>
<p><strong>Redis连接优化</strong>：</p>
<pre><code class="language-conf"># redis.conf
tcp-keepalive 300
tcp-backlog 511
timeout 0
</code></pre>
<h3>3. 持久化优化</h3>
<p><strong>RDB优化</strong>：</p>
<pre><code class="language-conf"># 优化RDB保存策略
save 900 1
save 300 10
save 60 10000

# 启用压缩
rdbcompression yes

# 启用校验和
rdbchecksum yes
</code></pre>
<p><strong>AOF优化</strong>：</p>
<pre><code class="language-conf"># 启用AOF
appendonly yes

# AOF重写策略
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb

# fsync策略
appendfsync everysec
</code></pre>
<h2>安全配置</h2>
<h3>1. 认证和授权</h3>
<p><strong>密码认证</strong>：</p>
<pre><code class="language-conf"># redis.conf
requirepass your_strong_password

# 禁用危险命令
rename-command FLUSHDB &quot;&quot;
rename-command FLUSHALL &quot;&quot;
rename-command KEYS &quot;&quot;
rename-command CONFIG &quot;CONFIG_b835c3f8a5d2e7f1&quot;
</code></pre>
<h3>2. 网络安全</h3>
<p><strong>绑定IP和端口</strong>：</p>
<pre><code class="language-conf"># 绑定特定IP
bind 127.0.0.1 10.0.0.1

# 修改默认端口
port 6380
</code></pre>
<p><strong>防火墙配置</strong>：</p>
<pre><code class="language-bash"># iptables规则
iptables -A INPUT -p tcp --dport 6379 -s 10.0.0.0/8 -j ACCEPT
iptables -A INPUT -p tcp --dport 6379 -j DROP
</code></pre>
<h3>3. SSL/TLS加密</h3>
<p><strong>SSL配置</strong>：</p>
<pre><code class="language-conf"># redis.conf
tls-port 6380
tls-cert-file /path/to/redis.crt
tls-key-file /path/to/redis.key
tls-ca-cert-file /path/to/ca.crt
</code></pre>
<h2>总结</h2>
<p>构建Redis高可用架构需要综合考虑多个方面：</p>
<ol>
<li><strong>架构选择</strong>：根据业务需求选择主从、哨兵或集群模式</li>
<li><strong>配置优化</strong>：合理配置内存、网络、持久化等参数</li>
<li><strong>监控告警</strong>：建立完善的监控体系和告警机制</li>
<li><strong>运维管理</strong>：制定标准化的运维流程和应急预案</li>
<li><strong>安全防护</strong>：实施多层次的安全防护措施</li>
</ol>
<p>通过合理的架构设计和持续的优化改进，可以构建出稳定、高效、安全的Redis高可用系统，为业务发展提供可靠的缓存服务支撑。</p>
</div></div></div></article></div></main></div><script src="/_next/static/chunks/webpack-c81f7fd28659d64f.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/eb4a34bff42c1814.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"2:I[2846,[],\"\"]\n5:I[4707,[],\"\"]\n8:I[6423,[],\"\"]\nb:I[1060,[],\"\"]\n6:[\"category\",\"notes\",\"d\"]\n7:[\"slug\",\"redis-high-availability\",\"d\"]\nc:[]\n0:[\"$\",\"$L2\",null,{\"buildId\":\"build\",\"assetPrefix\":\"\",\"urlParts\":[\"\",\"notes\",\"redis-high-availability\",\"\"],\"initialTree\":[\"\",{\"children\":[[\"category\",\"notes\",\"d\"],{\"children\":[[\"slug\",\"redis-high-availability\",\"d\"],{\"children\":[\"__PAGE__?{\\\"category\\\":\\\"notes\\\",\\\"slug\\\":\\\"redis-high-availability\\\"}\",{}]}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"category\",\"notes\",\"d\"],{\"children\":[[\"slug\",\"redis-high-availability\",\"d\"],{\"children\":[\"__PAGE__\",{},[[\"$L3\",\"$L4\",null],null],null]},[null,[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$6\",\"children\",\"$7\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}]],null]},[null,[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$6\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}]],null]},[[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/eb4a34bff42c1814.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],\"$L9\"],null],null],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$La\"],\"globalErrorComponent\":\"$b\",\"missingSlots\":\"$Wc\"}]\n"])</script><script>self.__next_f.push([1,"d:I[2972,[\"972\",\"static/chunks/972-81dbad6abe39d3fa.js\",\"832\",\"static/chunks/832-7ea2624e20755f9f.js\",\"621\",\"static/chunks/app/%5Bcategory%5D/%5Bslug%5D/page-e466df95e55c7602.js\"],\"\"]\ne:I[2024,[\"972\",\"static/chunks/972-81dbad6abe39d3fa.js\",\"832\",\"static/chunks/832-7ea2624e20755f9f.js\",\"621\",\"static/chunks/app/%5Bcategory%5D/%5Bslug%5D/page-e466df95e55c7602.js\"],\"default\"]\n10:I[7140,[\"972\",\"static/chunks/972-81dbad6abe39d3fa.js\",\"185\",\"static/chunks/app/layout-3ed2f387fb22aa2c.js\"],\"default\"]\nf:T3ec4,"])</script><script>self.__next_f.push([1,"\n# Redis高可用实战\n\n\u003e 构建高可用的Redis架构是保障系统稳定性的关键\n\n## 引言\n\nRedis作为高性能的内存数据库，在互联网应用中扮演着重要的角色。然而，单节点的Redis实例存在单点故障风险，一旦宕机会影响整个系统的可用性。本文将详细介绍Redis高可用架构的设计原理和实现方案。\n\n## Redis高可用架构概述\n\n### 1. 高可用架构目标\n\n**可用性指标**\n- 99.9%可用性（年停机时间不超过8.76小时）\n- 99.99%可用性（年停机时间不超过52分钟）\n- 快速故障检测和恢复（RTO \u003c 30秒）\n- 最小数据丢失（RPO \u003c 1秒）\n\n**性能指标**\n- 高并发处理能力（十万级QPS）\n- 低延迟响应（P99 \u003c 1ms）\n- 高吞吐量（百万级OPS）\n- 线性扩展能力\n\n### 2. 高可用架构模式\n\n**主从模式**\n- 一主多从的复制架构\n- 读写分离，提升读性能\n- 主节点故障时需要手动切换\n- 适合对可用性要求不高的场景\n\n**哨兵模式**\n- 自动监控和故障转移\n- 哨兵集群监控主从节点\n- 自动选举新的主节点\n- 适合中小型应用\n\n**集群模式**\n- 分布式集群架构\n- 数据分片存储\n- 自动故障转移和恢复\n- 适合大规模应用\n\n## 主从复制架构\n\n### 1. 主从复制配置\n\n**主节点配置**：\n```conf\n# redis.conf\nbind 0.0.0.0\nport 6379\nrequirepass your_password\nmasterauth your_password\n\n# 持久化配置\nsave 900 1\nsave 300 10\nsave 60 10000\nappendonly yes\nappendfsync everysec\n```\n\n**从节点配置**：\n```conf\n# redis.conf\nbind 0.0.0.0\nport 6379\nrequirepass your_password\n\n# 复制配置\nreplicaof master_ip 6379\nmasterauth your_password\n\n# 只读模式\nreplica-read-only yes\n```\n\n**动态配置**：\n```bash\n# 在从节点执行\nredis-cli -a your_password replicaof master_ip 6379\n\n# 查看复制状态\nredis-cli -a your_password info replication\n```\n\n### 2. 复制原理详解\n\n**复制过程**：\n1. 从节点向主节点发送SYNC命令\n2. 主节点生成RDB快照文件\n3. 主节点将RDB文件发送给从节点\n4. 从节点加载RDB文件并恢复数据\n5. 主节点将写命令发送给从节点执行\n\n**增量复制**：\n```bash\n# 查看复制偏移量\nredis-cli -a your_password info replication\n\n# 主节点输出\nmaster_replid:83a3b4f1d9e4f2a7b8c9d0e1f2a3b4c5d6e7f8a9\nmaster_repl_offset:12345\n\n# 从节点输出\nslave_repl_offset:12345\n```\n\n### 3. 复制延迟监控\n\n**监控脚本**：\n```bash\n#!/bin/bash\n# monitor_replication_lag.sh\n\nREDIS_CLI=\"redis-cli -a your_password\"\nMASTER_IP=\"master_ip\"\nSLAVE_IP=\"slave_ip\"\n\n# 获取主节点偏移量\nMASTER_OFFSET=$($REDIS_CLI -h $MASTER_IP info replication | grep master_repl_offset | cut -d: -f2)\n\n# 获取从节点偏移量\nSLAVE_OFFSET=$($REDIS_CLI -h $SLAVE_IP info replication | grep slave_repl_offset | cut -d: -f2)\n\n# 计算延迟\nLAG=$((MASTER_OFFSET - SLAVE_OFFSET))\n\nif [ $LAG -gt 10000 ]; then\n    echo \"WARNING: Replication lag is high: $LAG\"\n    # 发送告警\nfi\n```\n\n## 哨兵模式架构\n\n### 1. 哨兵配置\n\n**哨兵配置文件**：\n```conf\n# sentinel.conf\nport 26379\nsentinel monitor mymaster master_ip 6379 2\nsentinel auth-pass mymaster your_password\nsentinel down-after-milliseconds mymaster 5000\nsentinel failover-timeout mymaster 180000\nsentinel parallel-syncs mymaster 1\nsentinel notification-script mymaster /opt/redis/sentinel_notify.sh\nsentinel client-reconfig-script mymaster /opt/redis/sentinel_reconfig.sh\n```\n\n**多哨兵部署**：\n```bash\n# 在不同服务器上启动哨兵\nredis-sentinel /opt/redis/sentinel.conf --port 26379\nredis-sentinel /opt/redis/sentinel.conf --port 26380\nredis-sentinel /opt/redis/sentinel.conf --port 26381\n```\n\n### 2. 哨兵工作原理\n\n**故障检测**：\n1. 哨兵定期向主节点发送PING命令\n2. 如果主节点在down-after-milliseconds时间内无响应\n3. 哨兵认为主节点主观下线（S_DOWN）\n4. 多个哨兵确认后，主节点客观下线（O_DOWN）\n\n**故障转移**：\n1. 哨兵从从节点中选举新的主节点\n2. 将其他从节点指向新的主节点\n3. 通知客户端新的主节点地址\n4. 监控故障节点的恢复情况\n\n### 3. 哨兵监控脚本\n\n**监控脚本**：\n```bash\n#!/bin/bash\n# sentinel_monitor.sh\n\nSENTINEL_CLI=\"redis-cli -p 26379\"\nMASTER_NAME=\"mymaster\"\n\n# 检查主节点状态\nMASTER_STATUS=$($SENTINEL_CLI sentinel masters | grep $MASTER_NAME)\n\nif [ -z \"$MASTER_STATUS\" ]; then\n    echo \"ERROR: Master not found in sentinel\"\n    exit 1\nfi\n\n# 获取主节点IP和端口\nMASTER_IP=$(echo $MASTER_STATUS | awk '{print $3}')\nMASTER_PORT=$(echo $MASTER_STATUS | awk '{print $5}')\n\n# 检查主节点是否可达\nredis-cli -h $MASTER_IP -p $MASTER_PORT ping \u003e /dev/null 2\u003e\u00261\n\nif [ $? -ne 0 ]; then\n    echo \"WARNING: Master $MASTER_IP:$MASTER_PORT is not reachable\"\nfi\n```\n\n## Redis集群架构\n\n### 1. 集群配置\n\n**集群节点配置**：\n```conf\n# redis.conf\ncluster-enabled yes\ncluster-config-file nodes-6379.conf\ncluster-node-timeout 15000\ncluster-require-full-coverage yes\ncluster-announce-ip node_ip\ncluster-announce-port 6379\ncluster-announce-bus-port 16379\n```\n\n**集群初始化**：\n```bash\n# 创建集群\nredis-cli --cluster create \\\n    node1:6379 node2:6379 node3:6379 \\\n    node4:6379 node5:6379 node6:6379 \\\n    --cluster-replicas 1\n\n# 检查集群状态\nredis-cli --cluster check node1:6379\n```\n\n### 2. 分片原理\n\n**数据分片**：\n- 使用CRC16算法计算key的哈希值\n- 哈希值对16384取模，确定槽位\n- 每个节点负责一定范围的槽位\n- 支持动态槽位迁移\n\n**槽位分布**：\n```bash\n# 查看槽位分布\nredis-cli cluster nodes\n\n# 输出示例\n# 3a3b4f1d9e4f2a7b8c9d0e1f2a3b4c5d6e7f8a9 192.168.1.10:6379@16379 master - 0 1234567890123 1 connected 0-5460\n# b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2 192.168.1.11:6379@16379 master - 0 1234567890123 2 connected 5461-10922\n# c6d7e8f9a0b1c2d3e4f5a6b7c8d9e0f1a2b3c4 192.168.1.12:6379@16379 master - 0 1234567890123 3 connected 10923-16383\n```\n\n### 3. 故障转移\n\n**节点故障**：\n1. 集群检测到节点故障\n2. 主节点故障时，从节点自动升级为主节点\n3. 重新分配槽位，保证集群完整\n4. 客户端自动重定向到正确节点\n\n**手动故障转移**：\n```bash\n# 手动故障转移\nredis-cli --cluster failover node_ip:6379\n\n# 槽位重平衡\nredis-cli --cluster rebalance node_ip:6379\n```\n\n## 高可用客户端配置\n\n### 1. Java客户端配置\n\n**Jedis哨兵配置**：\n```java\nimport redis.clients.jedis.*;\nimport java.util.*;\n\npublic class RedisSentinelExample {\n    \n    private JedisSentinelPool sentinelPool;\n    \n    public void initSentinelPool() {\n        Set\u003cString\u003e sentinels = new HashSet\u003c\u003e();\n        sentinels.add(\"sentinel1:26379\");\n        sentinels.add(\"sentinel2:26379\");\n        sentinels.add(\"sentinel3:26379\");\n        \n        JedisPoolConfig config = new JedisPoolConfig();\n        config.setMaxTotal(100);\n        config.setMaxIdle(20);\n        config.setMinIdle(5);\n        \n        sentinelPool = new JedisSentinelPool(\n            \"mymaster\", \n            sentinels, \n            config, \n            2000, \n            \"your_password\"\n        );\n    }\n    \n    public void executeWithRetry() {\n        try (Jedis jedis = sentinelPool.getResource()) {\n            jedis.set(\"key\", \"value\");\n            String result = jedis.get(\"key\");\n            System.out.println(result);\n        } catch (JedisConnectionException e) {\n            // 处理连接异常，自动重试\n            executeWithRetry();\n        }\n    }\n}\n```\n\n**Lettuce集群配置**：\n```java\nimport io.lettuce.core.*;\nimport io.lettuce.core.cluster.*;\n\npublic class RedisClusterExample {\n    \n    private RedisClusterClient clusterClient;\n    \n    public void initClusterClient() {\n        clusterClient = RedisClusterClient.create(\n            RedisURI.create(\"redis://node1:6379\")\n        );\n        \n        ClusterTopologyRefreshOptions topologyOptions = \n            ClusterTopologyRefreshOptions.builder()\n                .enablePeriodicRefresh(Duration.ofSeconds(60))\n                .enableAllAdaptiveRefreshTriggers()\n                .build();\n        \n        ClusterClientOptions clientOptions = ClusterClientOptions.builder()\n            .topologyRefreshOptions(topologyOptions)\n            .autoReconnect(true)\n            .build();\n            \n        clusterClient.setOptions(clientOptions);\n    }\n    \n    public void executeCommand() {\n        StatefulRedisClusterConnection\u003cString, String\u003e connection = \n            clusterClient.connect();\n            \n        RedisAdvancedClusterCommands\u003cString, String\u003e commands = \n            connection.sync();\n            \n        commands.set(\"key\", \"value\");\n        String result = commands.get(\"key\");\n        \n        connection.close();\n    }\n}\n```\n\n### 2. Python客户端配置\n\n**Redis-py哨兵配置**：\n```python\nimport redis\nfrom redis.sentinel import Sentinel\n\nclass RedisSentinelClient:\n    \n    def __init__(self):\n        self.sentinel = Sentinel([\n            ('sentinel1', 26379),\n            ('sentinel2', 26379),\n            ('sentinel3', 26379)\n        ], socket_timeout=0.1)\n        \n        self.master = self.sentinel.master_for(\n            'mymaster', \n            socket_timeout=0.1,\n            password='your_password'\n        )\n        \n        self.slave = self.sentinel.slave_for(\n            'mymaster',\n            socket_timeout=0.1,\n            password='your_password'\n        )\n    \n    def write_operation(self):\n        try:\n            result = self.master.set('key', 'value')\n            return result\n        except redis.ConnectionError:\n            # 重试逻辑\n            return self.write_operation()\n    \n    def read_operation(self):\n        try:\n            result = self.slave.get('key')\n            return result\n        except redis.ConnectionError:\n            # 降级到主节点读取\n            return self.master.get('key')\n```\n\n**Redis-py集群配置**：\n```python\nfrom rediscluster import RedisCluster\n\nclass RedisClusterClient:\n    \n    def __init__(self):\n        startup_nodes = [\n            {\"host\": \"node1\", \"port\": \"6379\"},\n            {\"host\": \"node2\", \"port\": \"6379\"},\n            {\"host\": \"node3\", \"port\": \"6379\"}\n        ]\n        \n        self.client = RedisCluster(\n            startup_nodes=startup_nodes,\n            decode_responses=True,\n            skip_full_coverage_check=True,\n            max_connections_per_node=100\n        )\n    \n    def execute_with_retry(self, func, *args, **kwargs):\n        max_retries = 3\n        for i in range(max_retries):\n            try:\n                return func(*args, **kwargs)\n            except redis.exceptions.ConnectionError:\n                if i == max_retries - 1:\n                    raise\n                continue\n```\n\n## 监控和运维\n\n### 1. 性能监控\n\n**关键指标监控**：\n```bash\n# 内存使用情况\nredis-cli info memory | grep used_memory_human\n\n# 连接数\nredis-cli info clients\n\n# 命令执行统计\nredis-cli info stats\n\n# 慢查询日志\nredis-cli slowlog get 10\n```\n\n**Prometheus监控配置**：\n```yaml\n# redis_exporter配置\nglobal:\n  scrape_interval: 15s\n\nscrape_configs:\n  - job_name: 'redis'\n    static_configs:\n      - targets: ['redis-exporter:9121']\n    relabel_configs:\n      - source_labels: [__address__]\n        target_label: __param_target\n      - source_labels: [__param_target]\n        target_label: instance\n      - target_label: __address__\n        replacement: redis-exporter:9121\n```\n\n### 2. 告警规则\n\n**Grafana告警规则**：\n```yaml\ngroups:\n  - name: redis\n    rules:\n      - alert: RedisDown\n        expr: redis_up == 0\n        for: 1m\n        labels:\n          severity: critical\n        annotations:\n          summary: \"Redis instance is down\"\n          \n      - alert: RedisMemoryHigh\n        expr: redis_memory_used_bytes / redis_memory_max_bytes \u003e 0.9\n        for: 5m\n        labels:\n          severity: warning\n        annotations:\n          summary: \"Redis memory usage is high\"\n          \n      - alert: RedisConnectionsHigh\n        expr: redis_connected_clients \u003e 1000\n        for: 5m\n        labels:\n          severity: warning\n        annotations:\n          summary: \"Redis has too many connections\"\n```\n\n### 3. 运维脚本\n\n**批量操作脚本**：\n```bash\n#!/bin/bash\n# redis_cluster_ops.sh\n\nNODES=(\"node1:6379\" \"node2:6379\" \"node3:6379\")\nPASSWORD=\"your_password\"\n\n# 批量执行命令\nexecute_on_cluster() {\n    local cmd=$1\n    for node in \"${NODES[@]}\"; do\n        echo \"Executing on $node: $cmd\"\n        redis-cli -h ${node%:*} -p ${node#*:} -a $PASSWORD $cmd\n    done\n}\n\n# 集群健康检查\ncluster_health_check() {\n    echo \"Checking cluster health...\"\n    execute_on_cluster \"cluster nodes\"\n    execute_on_cluster \"info replication\"\n}\n\n# 备份数据\nbackup_cluster() {\n    local backup_dir=\"/backup/redis/$(date +%Y%m%d_%H%M%S)\"\n    mkdir -p $backup_dir\n    \n    for node in \"${NODES[@]}\"; do\n        redis-cli -h ${node%:*} -p ${node#*:} -a $PASSWORD \\\n            --rdb $backup_dir/${node%:*}.rdb\n    done\n}\n\n# 调用示例\ncase \"$1\" in\n    \"health\")\n        cluster_health_check\n        ;;\n    \"backup\")\n        backup_cluster\n        ;;\n    *)\n        echo \"Usage: $0 {health|backup}\"\n        ;;\nesac\n```\n\n## 性能优化\n\n### 1. 内存优化\n\n**内存配置优化**：\n```conf\n# redis.conf\nmaxmemory 4gb\nmaxmemory-policy allkeys-lru\n\n# 淘汰策略选择\n# volatile-lru: 淘汰设置了TTL且最少使用的key\n# allkeys-lru: 淘汰最少使用的key\n# volatile-random: 随机淘汰设置了TTL的key\n# allkeys-random: 随机淘汰key\n# volatile-ttl: 淘汰即将过期的key\n# noeviction: 不淘汰，返回错误\n```\n\n**数据结构优化**：\n```bash\n# 使用Hash代替String存储对象\nHSET user:1001 name \"张三\" age 25 email \"zhangsan@example.com\"\n\n# 使用List代替多个String\nLPUSH recent:users user:1001 user:1002 user:1003\n\n# 使用Set进行快速查找\nSADD user:1001:tags tag1 tag2 tag3\nSISMEMBER user:1001:tags tag1\n\n# 使用Sorted Set进行排序\nZADD ranking 100 user:1001 90 user:1002 80 user:1003\n```\n\n### 2. 网络优化\n\n**TCP参数优化**：\n```conf\n# 系统级优化\necho 'net.core.somaxconn = 65535' \u003e\u003e /etc/sysctl.conf\necho 'net.ipv4.tcp_max_syn_backlog = 65535' \u003e\u003e /etc/sysctl.conf\necho 'net.core.netdev_max_backlog = 5000' \u003e\u003e /etc/sysctl.conf\n\nsysctl -p\n```\n\n**Redis连接优化**：\n```conf\n# redis.conf\ntcp-keepalive 300\ntcp-backlog 511\ntimeout 0\n```\n\n### 3. 持久化优化\n\n**RDB优化**：\n```conf\n# 优化RDB保存策略\nsave 900 1\nsave 300 10\nsave 60 10000\n\n# 启用压缩\nrdbcompression yes\n\n# 启用校验和\nrdbchecksum yes\n```\n\n**AOF优化**：\n```conf\n# 启用AOF\nappendonly yes\n\n# AOF重写策略\nauto-aof-rewrite-percentage 100\nauto-aof-rewrite-min-size 64mb\n\n# fsync策略\nappendfsync everysec\n```\n\n## 安全配置\n\n### 1. 认证和授权\n\n**密码认证**：\n```conf\n# redis.conf\nrequirepass your_strong_password\n\n# 禁用危险命令\nrename-command FLUSHDB \"\"\nrename-command FLUSHALL \"\"\nrename-command KEYS \"\"\nrename-command CONFIG \"CONFIG_b835c3f8a5d2e7f1\"\n```\n\n### 2. 网络安全\n\n**绑定IP和端口**：\n```conf\n# 绑定特定IP\nbind 127.0.0.1 10.0.0.1\n\n# 修改默认端口\nport 6380\n```\n\n**防火墙配置**：\n```bash\n# iptables规则\niptables -A INPUT -p tcp --dport 6379 -s 10.0.0.0/8 -j ACCEPT\niptables -A INPUT -p tcp --dport 6379 -j DROP\n```\n\n### 3. SSL/TLS加密\n\n**SSL配置**：\n```conf\n# redis.conf\ntls-port 6380\ntls-cert-file /path/to/redis.crt\ntls-key-file /path/to/redis.key\ntls-ca-cert-file /path/to/ca.crt\n```\n\n## 总结\n\n构建Redis高可用架构需要综合考虑多个方面：\n\n1. **架构选择**：根据业务需求选择主从、哨兵或集群模式\n2. **配置优化**：合理配置内存、网络、持久化等参数\n3. **监控告警**：建立完善的监控体系和告警机制\n4. **运维管理**：制定标准化的运维流程和应急预案\n5. **安全防护**：实施多层次的安全防护措施\n\n通过合理的架构设计和持续的优化改进，可以构建出稳定、高效、安全的Redis高可用系统，为业务发展提供可靠的缓存服务支撑。"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"children\":[[\"$\",\"$Ld\",null,{\"href\":\"/notes\",\"className\":\"back-button\",\"style\":{\"display\":\"inline-block\",\"background\":\"var(--primary-color)\",\"color\":\"white\",\"border\":\"none\",\"padding\":\"10px 20px\",\"borderRadius\":\"6px\",\"cursor\":\"pointer\",\"marginBottom\":\"20px\",\"textDecoration\":\"none\"},\"children\":[\"← 返回\",\"笔记\",\"列表\"]}],[\"$\",\"article\",null,{\"className\":\"section\",\"children\":[[\"$\",\"header\",null,{\"className\":\"article-header\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"article-title\",\"children\":\"Redis高可用实战\"}],[\"$\",\"div\",null,{\"className\":\"article-meta\",\"children\":[\"$\",\"div\",null,{\"className\":\"article-tags\",\"children\":[[\"$\",\"span\",\"Redis\",{\"className\":\"tag\",\"children\":\"Redis\"}],[\"$\",\"span\",\"高可用\",{\"className\":\"tag\",\"children\":\"高可用\"}],[\"$\",\"span\",\"集群\",{\"className\":\"tag\",\"children\":\"集群\"}],[\"$\",\"span\",\"哨兵\",{\"className\":\"tag\",\"children\":\"哨兵\"}],[\"$\",\"span\",\"分布式缓存\",{\"className\":\"tag\",\"children\":\"分布式缓存\"}]]}]}]]}],[\"$\",\"div\",null,{\"className\":\"card markdown-content\",\"children\":[\"$\",\"$Le\",null,{\"content\":\"$f\"}]}]]}]]}]\n"])</script><script>self.__next_f.push([1,"9:[\"$\",\"html\",null,{\"lang\":\"zh-CN\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"link\",null,{\"rel\":\"stylesheet\",\"href\":\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css\"}],[\"$\",\"link\",null,{\"rel\":\"stylesheet\",\"href\":\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css\"}],[\"$\",\"script\",null,{\"src\":\"https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js\"}]]}],[\"$\",\"body\",null,{\"children\":[\"$\",\"div\",null,{\"className\":\"app\",\"children\":[[\"$\",\"$L10\",null,{\"siteConfig\":{\"name\":\"Rudy Yang\",\"bio\":\"JAVA | AI | WEB3\",\"social\":[{\"name\":\"github\",\"icon\":\"fab fa-github\",\"url\":\"https://github.com/suogongy\"},{\"name\":\"twitter\",\"icon\":\"fab fa-twitter\",\"url\":\"https://twitter.com/suogongy\"},{\"name\":\"email\",\"icon\":\"fas fa-envelope\",\"url\":\"mailto:haiyuan1832@163.com\"}]}}],[\"$\",\"main\",null,{\"className\":\"main-content\",\"children\":[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"Redis高可用实战 - Personal GitHub Page\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"详细介绍Redis高可用架构的设计原理、实现方案和最佳实践，包括主从复制、哨兵模式、集群模式等核心技术的深入解析。\"}]]\n3:null\n"])</script></body></html>