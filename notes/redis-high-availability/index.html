<!DOCTYPE html><html lang="zh-CN"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/55b7a9e84b417e65.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-c81f7fd28659d64f.js"/><script src="/_next/static/chunks/fd9d1056-9f91b5e418130764.js" async=""></script><script src="/_next/static/chunks/117-ee7b0ec54963e50f.js" async=""></script><script src="/_next/static/chunks/main-app-1bdc7b9537d0c130.js" async=""></script><script src="/_next/static/chunks/972-17ea62b17795b286.js" async=""></script><script src="/_next/static/chunks/app/%5Bcategory%5D/%5Bslug%5D/page-e1b46fcdbbb20f68.js" async=""></script><script src="/_next/static/chunks/app/layout-ca71fef930ed4111.js" async=""></script><title>Redis高可用实战 - Personal GitHub Page</title><meta name="description" content="详细介绍Redis高可用架构的设计原理、实现方案和最佳实践，包括主从复制、哨兵模式、集群模式等核心技术的深入解析。"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css"/><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body><div class="app"><header class="header "><nav class="nav-container"><a class="nav-brand" href="/"><i class="fas fa-terminal"></i>Rudy Yang</a><ul class="nav-menu"><li><a class="nav-link " href="/"><i class="fas fa-home"></i> 首页</a></li><li><a class="nav-link " href="/about/"><i class="fas fa-user"></i> 关于</a></li><li><a class="nav-link " href="/projects/"><i class="fas fa-code"></i> 项目</a></li><li><a class="nav-link " href="/notes/"><i class="fas fa-book"></i> 笔记</a></li><li><a class="nav-link " href="/articles/"><i class="fas fa-pen"></i> 随笔</a></li></ul></nav></header><main class="main-content"><div><a class="back-button" style="display:inline-block;background:var(--primary-color);color:white;border:none;padding:10px 20px;border-radius:6px;cursor:pointer;margin-bottom:20px;text-decoration:none" href="/notes/">← 返回<!-- -->笔记<!-- -->列表</a><article class="section"><header class="article-header"><h1 class="article-title">Redis高可用实战</h1><div class="article-meta"><div class="article-meta-info"><span class="article-date">2024-10-14</span><span class="article-category">• <!-- -->笔记</span></div><div class="article-tags"><span class="tag">Redis</span><span class="tag">高可用</span><span class="tag">集群</span><span class="tag">哨兵</span><span class="tag">分布式缓存</span></div></div></header><div class="card markdown-content"><h1>Redis高可用实战</h1>
<blockquote>
<p>构建高可用的Redis架构是保障系统稳定性的关键</p>
</blockquote>
<h2>引言</h2>
<p>Redis作为高性能的内存数据库，在互联网应用中扮演着重要的角色。然而，单节点的Redis实例存在单点故障风险，一旦宕机会影响整个系统的可用性。本文将详细介绍Redis高可用架构的设计原理和实现方案。</p>
<h2>Redis高可用架构概述</h2>
<h3>1. 高可用架构目标</h3>
<p><strong>可用性指标</strong></p>
<ul>
<li>99.9%可用性（年停机时间不超过8.76小时）</li>
<li>99.99%可用性（年停机时间不超过52分钟）</li>
<li>快速故障检测和恢复（RTO &lt; 30秒）</li>
<li>最小数据丢失（RPO &lt; 1秒）</li>
</ul>
<p><strong>性能指标</strong></p>
<ul>
<li>高并发处理能力（十万级QPS）</li>
<li>低延迟响应（P99 &lt; 1ms）</li>
<li>高吞吐量（百万级OPS）</li>
<li>线性扩展能力</li>
</ul>
<h3>2. 高可用架构模式</h3>
<p><strong>主从模式</strong></p>
<ul>
<li>一主多从的复制架构</li>
<li>读写分离，提升读性能</li>
<li>主节点故障时需要手动切换</li>
<li>适合对可用性要求不高的场景</li>
</ul>
<p><strong>哨兵模式</strong></p>
<ul>
<li>自动监控和故障转移</li>
<li>哨兵集群监控主从节点</li>
<li>自动选举新的主节点</li>
<li>适合中小型应用</li>
</ul>
<p><strong>集群模式</strong></p>
<ul>
<li>分布式集群架构</li>
<li>数据分片存储</li>
<li>自动故障转移和恢复</li>
<li>适合大规模应用</li>
</ul>
<h2>主从复制架构</h2>
<h3>1. 主从复制配置</h3>
<p><strong>主节点配置</strong>：</p>
<pre><code class="language-conf"># redis.conf
bind 0.0.0.0
port 6379
requirepass your_password
masterauth your_password

# 持久化配置
save 900 1
save 300 10
save 60 10000
appendonly yes
appendfsync everysec
</code></pre>
<p><strong>从节点配置</strong>：</p>
<pre><code class="language-conf"># redis.conf
bind 0.0.0.0
port 6379
requirepass your_password

# 复制配置
replicaof master_ip 6379
masterauth your_password

# 只读模式
replica-read-only yes
</code></pre>
<p><strong>动态配置</strong>：</p>
<pre><code class="language-bash"># 在从节点执行
redis-cli -a your_password replicaof master_ip 6379

# 查看复制状态
redis-cli -a your_password info replication
</code></pre>
<h3>2. 复制原理详解</h3>
<p><strong>复制过程</strong>：</p>
<ol>
<li>从节点向主节点发送SYNC命令</li>
<li>主节点生成RDB快照文件</li>
<li>主节点将RDB文件发送给从节点</li>
<li>从节点加载RDB文件并恢复数据</li>
<li>主节点将写命令发送给从节点执行</li>
</ol>
<p><strong>增量复制</strong>：</p>
<pre><code class="language-bash"># 查看复制偏移量
redis-cli -a your_password info replication

# 主节点输出
master_replid:83a3b4f1d9e4f2a7b8c9d0e1f2a3b4c5d6e7f8a9
master_repl_offset:12345

# 从节点输出
slave_repl_offset:12345
</code></pre>
<h3>3. 复制延迟监控</h3>
<p><strong>监控脚本</strong>：</p>
<pre><code class="language-bash">#!/bin/bash
# monitor_replication_lag.sh

REDIS_CLI=&quot;redis-cli -a your_password&quot;
MASTER_IP=&quot;master_ip&quot;
SLAVE_IP=&quot;slave_ip&quot;

# 获取主节点偏移量
MASTER_OFFSET=$($REDIS_CLI -h $MASTER_IP info replication | grep master_repl_offset | cut -d: -f2)

# 获取从节点偏移量
SLAVE_OFFSET=$($REDIS_CLI -h $SLAVE_IP info replication | grep slave_repl_offset | cut -d: -f2)

# 计算延迟
LAG=$((MASTER_OFFSET - SLAVE_OFFSET))

if [ $LAG -gt 10000 ]; then
    echo &quot;WARNING: Replication lag is high: $LAG&quot;
    # 发送告警
fi
</code></pre>
<h2>哨兵模式架构</h2>
<h3>1. 哨兵配置</h3>
<p><strong>哨兵配置文件</strong>：</p>
<pre><code class="language-conf"># sentinel.conf
port 26379
sentinel monitor mymaster master_ip 6379 2
sentinel auth-pass mymaster your_password
sentinel down-after-milliseconds mymaster 5000
sentinel failover-timeout mymaster 180000
sentinel parallel-syncs mymaster 1
sentinel notification-script mymaster /opt/redis/sentinel_notify.sh
sentinel client-reconfig-script mymaster /opt/redis/sentinel_reconfig.sh
</code></pre>
<p><strong>多哨兵部署</strong>：</p>
<pre><code class="language-bash"># 在不同服务器上启动哨兵
redis-sentinel /opt/redis/sentinel.conf --port 26379
redis-sentinel /opt/redis/sentinel.conf --port 26380
redis-sentinel /opt/redis/sentinel.conf --port 26381
</code></pre>
<h3>2. 哨兵工作原理</h3>
<p><strong>故障检测</strong>：</p>
<ol>
<li>哨兵定期向主节点发送PING命令</li>
<li>如果主节点在down-after-milliseconds时间内无响应</li>
<li>哨兵认为主节点主观下线（S_DOWN）</li>
<li>多个哨兵确认后，主节点客观下线（O_DOWN）</li>
</ol>
<p><strong>故障转移</strong>：</p>
<ol>
<li>哨兵从从节点中选举新的主节点</li>
<li>将其他从节点指向新的主节点</li>
<li>通知客户端新的主节点地址</li>
<li>监控故障节点的恢复情况</li>
</ol>
<h3>3. 哨兵监控脚本</h3>
<p><strong>监控脚本</strong>：</p>
<pre><code class="language-bash">#!/bin/bash
# sentinel_monitor.sh

SENTINEL_CLI=&quot;redis-cli -p 26379&quot;
MASTER_NAME=&quot;mymaster&quot;

# 检查主节点状态
MASTER_STATUS=$($SENTINEL_CLI sentinel masters | grep $MASTER_NAME)

if [ -z &quot;$MASTER_STATUS&quot; ]; then
    echo &quot;ERROR: Master not found in sentinel&quot;
    exit 1
fi

# 获取主节点IP和端口
MASTER_IP=$(echo $MASTER_STATUS | awk &#39;{print $3}&#39;)
MASTER_PORT=$(echo $MASTER_STATUS | awk &#39;{print $5}&#39;)

# 检查主节点是否可达
redis-cli -h $MASTER_IP -p $MASTER_PORT ping &gt; /dev/null 2&gt;&amp;1

if [ $? -ne 0 ]; then
    echo &quot;WARNING: Master $MASTER_IP:$MASTER_PORT is not reachable&quot;
fi
</code></pre>
<h2>Redis集群架构</h2>
<h3>1. 集群配置</h3>
<p><strong>集群节点配置</strong>：</p>
<pre><code class="language-conf"># redis.conf
cluster-enabled yes
cluster-config-file nodes-6379.conf
cluster-node-timeout 15000
cluster-require-full-coverage yes
cluster-announce-ip node_ip
cluster-announce-port 6379
cluster-announce-bus-port 16379
</code></pre>
<p><strong>集群初始化</strong>：</p>
<pre><code class="language-bash"># 创建集群
redis-cli --cluster create \
    node1:6379 node2:6379 node3:6379 \
    node4:6379 node5:6379 node6:6379 \
    --cluster-replicas 1

# 检查集群状态
redis-cli --cluster check node1:6379
</code></pre>
<h3>2. 分片原理</h3>
<p><strong>数据分片</strong>：</p>
<ul>
<li>使用CRC16算法计算key的哈希值</li>
<li>哈希值对16384取模，确定槽位</li>
<li>每个节点负责一定范围的槽位</li>
<li>支持动态槽位迁移</li>
</ul>
<p><strong>槽位分布</strong>：</p>
<pre><code class="language-bash"># 查看槽位分布
redis-cli cluster nodes

# 输出示例
# 3a3b4f1d9e4f2a7b8c9d0e1f2a3b4c5d6e7f8a9 192.168.1.10:6379@16379 master - 0 1234567890123 1 connected 0-5460
# b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2 192.168.1.11:6379@16379 master - 0 1234567890123 2 connected 5461-10922
# c6d7e8f9a0b1c2d3e4f5a6b7c8d9e0f1a2b3c4 192.168.1.12:6379@16379 master - 0 1234567890123 3 connected 10923-16383
</code></pre>
<h3>3. 故障转移</h3>
<p><strong>节点故障</strong>：</p>
<ol>
<li>集群检测到节点故障</li>
<li>主节点故障时，从节点自动升级为主节点</li>
<li>重新分配槽位，保证集群完整</li>
<li>客户端自动重定向到正确节点</li>
</ol>
<p><strong>手动故障转移</strong>：</p>
<pre><code class="language-bash"># 手动故障转移
redis-cli --cluster failover node_ip:6379

# 槽位重平衡
redis-cli --cluster rebalance node_ip:6379
</code></pre>
<h2>高可用客户端配置</h2>
<h3>1. Java客户端配置</h3>
<p><strong>Jedis哨兵配置</strong>：</p>
<pre><code class="language-java">import redis.clients.jedis.*;
import java.util.*;

public class RedisSentinelExample {
    
    private JedisSentinelPool sentinelPool;
    
    public void initSentinelPool() {
        Set&lt;String&gt; sentinels = new HashSet&lt;&gt;();
        sentinels.add(&quot;sentinel1:26379&quot;);
        sentinels.add(&quot;sentinel2:26379&quot;);
        sentinels.add(&quot;sentinel3:26379&quot;);
        
        JedisPoolConfig config = new JedisPoolConfig();
        config.setMaxTotal(100);
        config.setMaxIdle(20);
        config.setMinIdle(5);
        
        sentinelPool = new JedisSentinelPool(
            &quot;mymaster&quot;, 
            sentinels, 
            config, 
            2000, 
            &quot;your_password&quot;
        );
    }
    
    public void executeWithRetry() {
        try (Jedis jedis = sentinelPool.getResource()) {
            jedis.set(&quot;key&quot;, &quot;value&quot;);
            String result = jedis.get(&quot;key&quot;);
            System.out.println(result);
        } catch (JedisConnectionException e) {
            // 处理连接异常，自动重试
            executeWithRetry();
        }
    }
}
</code></pre>
<p><strong>Lettuce集群配置</strong>：</p>
<pre><code class="language-java">import io.lettuce.core.*;
import io.lettuce.core.cluster.*;

public class RedisClusterExample {
    
    private RedisClusterClient clusterClient;
    
    public void initClusterClient() {
        clusterClient = RedisClusterClient.create(
            RedisURI.create(&quot;redis://node1:6379&quot;)
        );
        
        ClusterTopologyRefreshOptions topologyOptions = 
            ClusterTopologyRefreshOptions.builder()
                .enablePeriodicRefresh(Duration.ofSeconds(60))
                .enableAllAdaptiveRefreshTriggers()
                .build();
        
        ClusterClientOptions clientOptions = ClusterClientOptions.builder()
            .topologyRefreshOptions(topologyOptions)
            .autoReconnect(true)
            .build();
            
        clusterClient.setOptions(clientOptions);
    }
    
    public void executeCommand() {
        StatefulRedisClusterConnection&lt;String, String&gt; connection = 
            clusterClient.connect();
            
        RedisAdvancedClusterCommands&lt;String, String&gt; commands = 
            connection.sync();
            
        commands.set(&quot;key&quot;, &quot;value&quot;);
        String result = commands.get(&quot;key&quot;);
        
        connection.close();
    }
}
</code></pre>
<h3>2. Python客户端配置</h3>
<p><strong>Redis-py哨兵配置</strong>：</p>
<pre><code class="language-python">import redis
from redis.sentinel import Sentinel

class RedisSentinelClient:
    
    def __init__(self):
        self.sentinel = Sentinel([
            (&#39;sentinel1&#39;, 26379),
            (&#39;sentinel2&#39;, 26379),
            (&#39;sentinel3&#39;, 26379)
        ], socket_timeout=0.1)
        
        self.master = self.sentinel.master_for(
            &#39;mymaster&#39;, 
            socket_timeout=0.1,
            password=&#39;your_password&#39;
        )
        
        self.slave = self.sentinel.slave_for(
            &#39;mymaster&#39;,
            socket_timeout=0.1,
            password=&#39;your_password&#39;
        )
    
    def write_operation(self):
        try:
            result = self.master.set(&#39;key&#39;, &#39;value&#39;)
            return result
        except redis.ConnectionError:
            # 重试逻辑
            return self.write_operation()
    
    def read_operation(self):
        try:
            result = self.slave.get(&#39;key&#39;)
            return result
        except redis.ConnectionError:
            # 降级到主节点读取
            return self.master.get(&#39;key&#39;)
</code></pre>
<p><strong>Redis-py集群配置</strong>：</p>
<pre><code class="language-python">from rediscluster import RedisCluster

class RedisClusterClient:
    
    def __init__(self):
        startup_nodes = [
            {&quot;host&quot;: &quot;node1&quot;, &quot;port&quot;: &quot;6379&quot;},
            {&quot;host&quot;: &quot;node2&quot;, &quot;port&quot;: &quot;6379&quot;},
            {&quot;host&quot;: &quot;node3&quot;, &quot;port&quot;: &quot;6379&quot;}
        ]
        
        self.client = RedisCluster(
            startup_nodes=startup_nodes,
            decode_responses=True,
            skip_full_coverage_check=True,
            max_connections_per_node=100
        )
    
    def execute_with_retry(self, func, *args, **kwargs):
        max_retries = 3
        for i in range(max_retries):
            try:
                return func(*args, **kwargs)
            except redis.exceptions.ConnectionError:
                if i == max_retries - 1:
                    raise
                continue
</code></pre>
<h2>监控和运维</h2>
<h3>1. 性能监控</h3>
<p><strong>关键指标监控</strong>：</p>
<pre><code class="language-bash"># 内存使用情况
redis-cli info memory | grep used_memory_human

# 连接数
redis-cli info clients

# 命令执行统计
redis-cli info stats

# 慢查询日志
redis-cli slowlog get 10
</code></pre>
<p><strong>Prometheus监控配置</strong>：</p>
<pre><code class="language-yaml"># redis_exporter配置
global:
  scrape_interval: 15s

scrape_configs:
  - job_name: &#39;redis&#39;
    static_configs:
      - targets: [&#39;redis-exporter:9121&#39;]
    relabel_configs:
      - source_labels: [__address__]
        target_label: __param_target
      - source_labels: [__param_target]
        target_label: instance
      - target_label: __address__
        replacement: redis-exporter:9121
</code></pre>
<h3>2. 告警规则</h3>
<p><strong>Grafana告警规则</strong>：</p>
<pre><code class="language-yaml">groups:
  - name: redis
    rules:
      - alert: RedisDown
        expr: redis_up == 0
        for: 1m
        labels:
          severity: critical
        annotations:
          summary: &quot;Redis instance is down&quot;
          
      - alert: RedisMemoryHigh
        expr: redis_memory_used_bytes / redis_memory_max_bytes &gt; 0.9
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: &quot;Redis memory usage is high&quot;
          
      - alert: RedisConnectionsHigh
        expr: redis_connected_clients &gt; 1000
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: &quot;Redis has too many connections&quot;
</code></pre>
<h3>3. 运维脚本</h3>
<p><strong>批量操作脚本</strong>：</p>
<pre><code class="language-bash">#!/bin/bash
# redis_cluster_ops.sh

NODES=(&quot;node1:6379&quot; &quot;node2:6379&quot; &quot;node3:6379&quot;)
PASSWORD=&quot;your_password&quot;

# 批量执行命令
execute_on_cluster() {
    local cmd=$1
    for node in &quot;${NODES[@]}&quot;; do
        echo &quot;Executing on $node: $cmd&quot;
        redis-cli -h ${node%:*} -p ${node#*:} -a $PASSWORD $cmd
    done
}

# 集群健康检查
cluster_health_check() {
    echo &quot;Checking cluster health...&quot;
    execute_on_cluster &quot;cluster nodes&quot;
    execute_on_cluster &quot;info replication&quot;
}

# 备份数据
backup_cluster() {
    local backup_dir=&quot;/backup/redis/$(date +%Y%m%d_%H%M%S)&quot;
    mkdir -p $backup_dir
    
    for node in &quot;${NODES[@]}&quot;; do
        redis-cli -h ${node%:*} -p ${node#*:} -a $PASSWORD \
            --rdb $backup_dir/${node%:*}.rdb
    done
}

# 调用示例
case &quot;$1&quot; in
    &quot;health&quot;)
        cluster_health_check
        ;;
    &quot;backup&quot;)
        backup_cluster
        ;;
    *)
        echo &quot;Usage: $0 {health|backup}&quot;
        ;;
esac
</code></pre>
<h2>性能优化</h2>
<h3>1. 内存优化</h3>
<p><strong>内存配置优化</strong>：</p>
<pre><code class="language-conf"># redis.conf
maxmemory 4gb
maxmemory-policy allkeys-lru

# 淘汰策略选择
# volatile-lru: 淘汰设置了TTL且最少使用的key
# allkeys-lru: 淘汰最少使用的key
# volatile-random: 随机淘汰设置了TTL的key
# allkeys-random: 随机淘汰key
# volatile-ttl: 淘汰即将过期的key
# noeviction: 不淘汰，返回错误
</code></pre>
<p><strong>数据结构优化</strong>：</p>
<pre><code class="language-bash"># 使用Hash代替String存储对象
HSET user:1001 name &quot;张三&quot; age 25 email &quot;zhangsan@example.com&quot;

# 使用List代替多个String
LPUSH recent:users user:1001 user:1002 user:1003

# 使用Set进行快速查找
SADD user:1001:tags tag1 tag2 tag3
SISMEMBER user:1001:tags tag1

# 使用Sorted Set进行排序
ZADD ranking 100 user:1001 90 user:1002 80 user:1003
</code></pre>
<h3>2. 网络优化</h3>
<p><strong>TCP参数优化</strong>：</p>
<pre><code class="language-conf"># 系统级优化
echo &#39;net.core.somaxconn = 65535&#39; &gt;&gt; /etc/sysctl.conf
echo &#39;net.ipv4.tcp_max_syn_backlog = 65535&#39; &gt;&gt; /etc/sysctl.conf
echo &#39;net.core.netdev_max_backlog = 5000&#39; &gt;&gt; /etc/sysctl.conf

sysctl -p
</code></pre>
<p><strong>Redis连接优化</strong>：</p>
<pre><code class="language-conf"># redis.conf
tcp-keepalive 300
tcp-backlog 511
timeout 0
</code></pre>
<h3>3. 持久化优化</h3>
<p><strong>RDB优化</strong>：</p>
<pre><code class="language-conf"># 优化RDB保存策略
save 900 1
save 300 10
save 60 10000

# 启用压缩
rdbcompression yes

# 启用校验和
rdbchecksum yes
</code></pre>
<p><strong>AOF优化</strong>：</p>
<pre><code class="language-conf"># 启用AOF
appendonly yes

# AOF重写策略
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb

# fsync策略
appendfsync everysec
</code></pre>
<h2>安全配置</h2>
<h3>1. 认证和授权</h3>
<p><strong>密码认证</strong>：</p>
<pre><code class="language-conf"># redis.conf
requirepass your_strong_password

# 禁用危险命令
rename-command FLUSHDB &quot;&quot;
rename-command FLUSHALL &quot;&quot;
rename-command KEYS &quot;&quot;
rename-command CONFIG &quot;CONFIG_b835c3f8a5d2e7f1&quot;
</code></pre>
<h3>2. 网络安全</h3>
<p><strong>绑定IP和端口</strong>：</p>
<pre><code class="language-conf"># 绑定特定IP
bind 127.0.0.1 10.0.0.1

# 修改默认端口
port 6380
</code></pre>
<p><strong>防火墙配置</strong>：</p>
<pre><code class="language-bash"># iptables规则
iptables -A INPUT -p tcp --dport 6379 -s 10.0.0.0/8 -j ACCEPT
iptables -A INPUT -p tcp --dport 6379 -j DROP
</code></pre>
<h3>3. SSL/TLS加密</h3>
<p><strong>SSL配置</strong>：</p>
<pre><code class="language-conf"># redis.conf
tls-port 6380
tls-cert-file /path/to/redis.crt
tls-key-file /path/to/redis.key
tls-ca-cert-file /path/to/ca.crt
</code></pre>
<h2>总结</h2>
<p>构建Redis高可用架构需要综合考虑多个方面：</p>
<ol>
<li><strong>架构选择</strong>：根据业务需求选择主从、哨兵或集群模式</li>
<li><strong>配置优化</strong>：合理配置内存、网络、持久化等参数</li>
<li><strong>监控告警</strong>：建立完善的监控体系和告警机制</li>
<li><strong>运维管理</strong>：制定标准化的运维流程和应急预案</li>
<li><strong>安全防护</strong>：实施多层次的安全防护措施</li>
</ol>
<p>通过合理的架构设计和持续的优化改进，可以构建出稳定、高效、安全的Redis高可用系统，为业务发展提供可靠的缓存服务支撑。</p>
</div></article></div></main></div><script src="/_next/static/chunks/webpack-c81f7fd28659d64f.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/55b7a9e84b417e65.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"2:I[2846,[],\"\"]\n5:I[4707,[],\"\"]\n8:I[6423,[],\"\"]\nb:I[1060,[],\"\"]\n6:[\"category\",\"notes\",\"d\"]\n7:[\"slug\",\"redis-high-availability\",\"d\"]\nc:[]\n0:[\"$\",\"$L2\",null,{\"buildId\":\"build\",\"assetPrefix\":\"\",\"urlParts\":[\"\",\"notes\",\"redis-high-availability\",\"\"],\"initialTree\":[\"\",{\"children\":[[\"category\",\"notes\",\"d\"],{\"children\":[[\"slug\",\"redis-high-availability\",\"d\"],{\"children\":[\"__PAGE__?{\\\"category\\\":\\\"notes\\\",\\\"slug\\\":\\\"redis-high-availability\\\"}\",{}]}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"category\",\"notes\",\"d\"],{\"children\":[[\"slug\",\"redis-high-availability\",\"d\"],{\"children\":[\"__PAGE__\",{},[[\"$L3\",\"$L4\",null],null],null]},[null,[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$6\",\"children\",\"$7\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}]],null]},[null,[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$6\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}]],null]},[[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/55b7a9e84b417e65.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],\"$L9\"],null],null],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$La\"],\"globalErrorComponent\":\"$b\",\"missingSlots\":\"$Wc\"}]\n"])</script><script>self.__next_f.push([1,"d:I[2972,[\"972\",\"static/chunks/972-17ea62b17795b286.js\",\"621\",\"static/chunks/app/%5Bcategory%5D/%5Bslug%5D/page-e1b46fcdbbb20f68.js\"],\"\"]\nf:I[7140,[\"972\",\"static/chunks/972-17ea62b17795b286.js\",\"185\",\"static/chunks/app/layout-ca71fef930ed4111.js\"],\"default\"]\ne:T4b8a,"])</script><script>self.__next_f.push([1,"\u003ch1\u003eRedis高可用实战\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e构建高可用的Redis架构是保障系统稳定性的关键\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003e引言\u003c/h2\u003e\n\u003cp\u003eRedis作为高性能的内存数据库，在互联网应用中扮演着重要的角色。然而，单节点的Redis实例存在单点故障风险，一旦宕机会影响整个系统的可用性。本文将详细介绍Redis高可用架构的设计原理和实现方案。\u003c/p\u003e\n\u003ch2\u003eRedis高可用架构概述\u003c/h2\u003e\n\u003ch3\u003e1. 高可用架构目标\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e可用性指标\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e99.9%可用性（年停机时间不超过8.76小时）\u003c/li\u003e\n\u003cli\u003e99.99%可用性（年停机时间不超过52分钟）\u003c/li\u003e\n\u003cli\u003e快速故障检测和恢复（RTO \u0026lt; 30秒）\u003c/li\u003e\n\u003cli\u003e最小数据丢失（RPO \u0026lt; 1秒）\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e性能指标\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e高并发处理能力（十万级QPS）\u003c/li\u003e\n\u003cli\u003e低延迟响应（P99 \u0026lt; 1ms）\u003c/li\u003e\n\u003cli\u003e高吞吐量（百万级OPS）\u003c/li\u003e\n\u003cli\u003e线性扩展能力\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e2. 高可用架构模式\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e主从模式\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e一主多从的复制架构\u003c/li\u003e\n\u003cli\u003e读写分离，提升读性能\u003c/li\u003e\n\u003cli\u003e主节点故障时需要手动切换\u003c/li\u003e\n\u003cli\u003e适合对可用性要求不高的场景\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e哨兵模式\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e自动监控和故障转移\u003c/li\u003e\n\u003cli\u003e哨兵集群监控主从节点\u003c/li\u003e\n\u003cli\u003e自动选举新的主节点\u003c/li\u003e\n\u003cli\u003e适合中小型应用\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e集群模式\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e分布式集群架构\u003c/li\u003e\n\u003cli\u003e数据分片存储\u003c/li\u003e\n\u003cli\u003e自动故障转移和恢复\u003c/li\u003e\n\u003cli\u003e适合大规模应用\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e主从复制架构\u003c/h2\u003e\n\u003ch3\u003e1. 主从复制配置\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e主节点配置\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-conf\"\u003e# redis.conf\nbind 0.0.0.0\nport 6379\nrequirepass your_password\nmasterauth your_password\n\n# 持久化配置\nsave 900 1\nsave 300 10\nsave 60 10000\nappendonly yes\nappendfsync everysec\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e从节点配置\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-conf\"\u003e# redis.conf\nbind 0.0.0.0\nport 6379\nrequirepass your_password\n\n# 复制配置\nreplicaof master_ip 6379\nmasterauth your_password\n\n# 只读模式\nreplica-read-only yes\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e动态配置\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 在从节点执行\nredis-cli -a your_password replicaof master_ip 6379\n\n# 查看复制状态\nredis-cli -a your_password info replication\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e2. 复制原理详解\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e复制过程\u003c/strong\u003e：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e从节点向主节点发送SYNC命令\u003c/li\u003e\n\u003cli\u003e主节点生成RDB快照文件\u003c/li\u003e\n\u003cli\u003e主节点将RDB文件发送给从节点\u003c/li\u003e\n\u003cli\u003e从节点加载RDB文件并恢复数据\u003c/li\u003e\n\u003cli\u003e主节点将写命令发送给从节点执行\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cstrong\u003e增量复制\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 查看复制偏移量\nredis-cli -a your_password info replication\n\n# 主节点输出\nmaster_replid:83a3b4f1d9e4f2a7b8c9d0e1f2a3b4c5d6e7f8a9\nmaster_repl_offset:12345\n\n# 从节点输出\nslave_repl_offset:12345\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e3. 复制延迟监控\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e监控脚本\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e#!/bin/bash\n# monitor_replication_lag.sh\n\nREDIS_CLI=\u0026quot;redis-cli -a your_password\u0026quot;\nMASTER_IP=\u0026quot;master_ip\u0026quot;\nSLAVE_IP=\u0026quot;slave_ip\u0026quot;\n\n# 获取主节点偏移量\nMASTER_OFFSET=$($REDIS_CLI -h $MASTER_IP info replication | grep master_repl_offset | cut -d: -f2)\n\n# 获取从节点偏移量\nSLAVE_OFFSET=$($REDIS_CLI -h $SLAVE_IP info replication | grep slave_repl_offset | cut -d: -f2)\n\n# 计算延迟\nLAG=$((MASTER_OFFSET - SLAVE_OFFSET))\n\nif [ $LAG -gt 10000 ]; then\n    echo \u0026quot;WARNING: Replication lag is high: $LAG\u0026quot;\n    # 发送告警\nfi\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e哨兵模式架构\u003c/h2\u003e\n\u003ch3\u003e1. 哨兵配置\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e哨兵配置文件\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-conf\"\u003e# sentinel.conf\nport 26379\nsentinel monitor mymaster master_ip 6379 2\nsentinel auth-pass mymaster your_password\nsentinel down-after-milliseconds mymaster 5000\nsentinel failover-timeout mymaster 180000\nsentinel parallel-syncs mymaster 1\nsentinel notification-script mymaster /opt/redis/sentinel_notify.sh\nsentinel client-reconfig-script mymaster /opt/redis/sentinel_reconfig.sh\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e多哨兵部署\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 在不同服务器上启动哨兵\nredis-sentinel /opt/redis/sentinel.conf --port 26379\nredis-sentinel /opt/redis/sentinel.conf --port 26380\nredis-sentinel /opt/redis/sentinel.conf --port 26381\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e2. 哨兵工作原理\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e故障检测\u003c/strong\u003e：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e哨兵定期向主节点发送PING命令\u003c/li\u003e\n\u003cli\u003e如果主节点在down-after-milliseconds时间内无响应\u003c/li\u003e\n\u003cli\u003e哨兵认为主节点主观下线（S_DOWN）\u003c/li\u003e\n\u003cli\u003e多个哨兵确认后，主节点客观下线（O_DOWN）\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cstrong\u003e故障转移\u003c/strong\u003e：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e哨兵从从节点中选举新的主节点\u003c/li\u003e\n\u003cli\u003e将其他从节点指向新的主节点\u003c/li\u003e\n\u003cli\u003e通知客户端新的主节点地址\u003c/li\u003e\n\u003cli\u003e监控故障节点的恢复情况\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003e3. 哨兵监控脚本\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e监控脚本\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e#!/bin/bash\n# sentinel_monitor.sh\n\nSENTINEL_CLI=\u0026quot;redis-cli -p 26379\u0026quot;\nMASTER_NAME=\u0026quot;mymaster\u0026quot;\n\n# 检查主节点状态\nMASTER_STATUS=$($SENTINEL_CLI sentinel masters | grep $MASTER_NAME)\n\nif [ -z \u0026quot;$MASTER_STATUS\u0026quot; ]; then\n    echo \u0026quot;ERROR: Master not found in sentinel\u0026quot;\n    exit 1\nfi\n\n# 获取主节点IP和端口\nMASTER_IP=$(echo $MASTER_STATUS | awk \u0026#39;{print $3}\u0026#39;)\nMASTER_PORT=$(echo $MASTER_STATUS | awk \u0026#39;{print $5}\u0026#39;)\n\n# 检查主节点是否可达\nredis-cli -h $MASTER_IP -p $MASTER_PORT ping \u0026gt; /dev/null 2\u0026gt;\u0026amp;1\n\nif [ $? -ne 0 ]; then\n    echo \u0026quot;WARNING: Master $MASTER_IP:$MASTER_PORT is not reachable\u0026quot;\nfi\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eRedis集群架构\u003c/h2\u003e\n\u003ch3\u003e1. 集群配置\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e集群节点配置\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-conf\"\u003e# redis.conf\ncluster-enabled yes\ncluster-config-file nodes-6379.conf\ncluster-node-timeout 15000\ncluster-require-full-coverage yes\ncluster-announce-ip node_ip\ncluster-announce-port 6379\ncluster-announce-bus-port 16379\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e集群初始化\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 创建集群\nredis-cli --cluster create \\\n    node1:6379 node2:6379 node3:6379 \\\n    node4:6379 node5:6379 node6:6379 \\\n    --cluster-replicas 1\n\n# 检查集群状态\nredis-cli --cluster check node1:6379\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e2. 分片原理\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e数据分片\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e使用CRC16算法计算key的哈希值\u003c/li\u003e\n\u003cli\u003e哈希值对16384取模，确定槽位\u003c/li\u003e\n\u003cli\u003e每个节点负责一定范围的槽位\u003c/li\u003e\n\u003cli\u003e支持动态槽位迁移\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e槽位分布\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 查看槽位分布\nredis-cli cluster nodes\n\n# 输出示例\n# 3a3b4f1d9e4f2a7b8c9d0e1f2a3b4c5d6e7f8a9 192.168.1.10:6379@16379 master - 0 1234567890123 1 connected 0-5460\n# b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2 192.168.1.11:6379@16379 master - 0 1234567890123 2 connected 5461-10922\n# c6d7e8f9a0b1c2d3e4f5a6b7c8d9e0f1a2b3c4 192.168.1.12:6379@16379 master - 0 1234567890123 3 connected 10923-16383\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e3. 故障转移\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e节点故障\u003c/strong\u003e：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e集群检测到节点故障\u003c/li\u003e\n\u003cli\u003e主节点故障时，从节点自动升级为主节点\u003c/li\u003e\n\u003cli\u003e重新分配槽位，保证集群完整\u003c/li\u003e\n\u003cli\u003e客户端自动重定向到正确节点\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cstrong\u003e手动故障转移\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 手动故障转移\nredis-cli --cluster failover node_ip:6379\n\n# 槽位重平衡\nredis-cli --cluster rebalance node_ip:6379\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e高可用客户端配置\u003c/h2\u003e\n\u003ch3\u003e1. Java客户端配置\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eJedis哨兵配置\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eimport redis.clients.jedis.*;\nimport java.util.*;\n\npublic class RedisSentinelExample {\n    \n    private JedisSentinelPool sentinelPool;\n    \n    public void initSentinelPool() {\n        Set\u0026lt;String\u0026gt; sentinels = new HashSet\u0026lt;\u0026gt;();\n        sentinels.add(\u0026quot;sentinel1:26379\u0026quot;);\n        sentinels.add(\u0026quot;sentinel2:26379\u0026quot;);\n        sentinels.add(\u0026quot;sentinel3:26379\u0026quot;);\n        \n        JedisPoolConfig config = new JedisPoolConfig();\n        config.setMaxTotal(100);\n        config.setMaxIdle(20);\n        config.setMinIdle(5);\n        \n        sentinelPool = new JedisSentinelPool(\n            \u0026quot;mymaster\u0026quot;, \n            sentinels, \n            config, \n            2000, \n            \u0026quot;your_password\u0026quot;\n        );\n    }\n    \n    public void executeWithRetry() {\n        try (Jedis jedis = sentinelPool.getResource()) {\n            jedis.set(\u0026quot;key\u0026quot;, \u0026quot;value\u0026quot;);\n            String result = jedis.get(\u0026quot;key\u0026quot;);\n            System.out.println(result);\n        } catch (JedisConnectionException e) {\n            // 处理连接异常，自动重试\n            executeWithRetry();\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eLettuce集群配置\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eimport io.lettuce.core.*;\nimport io.lettuce.core.cluster.*;\n\npublic class RedisClusterExample {\n    \n    private RedisClusterClient clusterClient;\n    \n    public void initClusterClient() {\n        clusterClient = RedisClusterClient.create(\n            RedisURI.create(\u0026quot;redis://node1:6379\u0026quot;)\n        );\n        \n        ClusterTopologyRefreshOptions topologyOptions = \n            ClusterTopologyRefreshOptions.builder()\n                .enablePeriodicRefresh(Duration.ofSeconds(60))\n                .enableAllAdaptiveRefreshTriggers()\n                .build();\n        \n        ClusterClientOptions clientOptions = ClusterClientOptions.builder()\n            .topologyRefreshOptions(topologyOptions)\n            .autoReconnect(true)\n            .build();\n            \n        clusterClient.setOptions(clientOptions);\n    }\n    \n    public void executeCommand() {\n        StatefulRedisClusterConnection\u0026lt;String, String\u0026gt; connection = \n            clusterClient.connect();\n            \n        RedisAdvancedClusterCommands\u0026lt;String, String\u0026gt; commands = \n            connection.sync();\n            \n        commands.set(\u0026quot;key\u0026quot;, \u0026quot;value\u0026quot;);\n        String result = commands.get(\u0026quot;key\u0026quot;);\n        \n        connection.close();\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e2. Python客户端配置\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eRedis-py哨兵配置\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eimport redis\nfrom redis.sentinel import Sentinel\n\nclass RedisSentinelClient:\n    \n    def __init__(self):\n        self.sentinel = Sentinel([\n            (\u0026#39;sentinel1\u0026#39;, 26379),\n            (\u0026#39;sentinel2\u0026#39;, 26379),\n            (\u0026#39;sentinel3\u0026#39;, 26379)\n        ], socket_timeout=0.1)\n        \n        self.master = self.sentinel.master_for(\n            \u0026#39;mymaster\u0026#39;, \n            socket_timeout=0.1,\n            password=\u0026#39;your_password\u0026#39;\n        )\n        \n        self.slave = self.sentinel.slave_for(\n            \u0026#39;mymaster\u0026#39;,\n            socket_timeout=0.1,\n            password=\u0026#39;your_password\u0026#39;\n        )\n    \n    def write_operation(self):\n        try:\n            result = self.master.set(\u0026#39;key\u0026#39;, \u0026#39;value\u0026#39;)\n            return result\n        except redis.ConnectionError:\n            # 重试逻辑\n            return self.write_operation()\n    \n    def read_operation(self):\n        try:\n            result = self.slave.get(\u0026#39;key\u0026#39;)\n            return result\n        except redis.ConnectionError:\n            # 降级到主节点读取\n            return self.master.get(\u0026#39;key\u0026#39;)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eRedis-py集群配置\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom rediscluster import RedisCluster\n\nclass RedisClusterClient:\n    \n    def __init__(self):\n        startup_nodes = [\n            {\u0026quot;host\u0026quot;: \u0026quot;node1\u0026quot;, \u0026quot;port\u0026quot;: \u0026quot;6379\u0026quot;},\n            {\u0026quot;host\u0026quot;: \u0026quot;node2\u0026quot;, \u0026quot;port\u0026quot;: \u0026quot;6379\u0026quot;},\n            {\u0026quot;host\u0026quot;: \u0026quot;node3\u0026quot;, \u0026quot;port\u0026quot;: \u0026quot;6379\u0026quot;}\n        ]\n        \n        self.client = RedisCluster(\n            startup_nodes=startup_nodes,\n            decode_responses=True,\n            skip_full_coverage_check=True,\n            max_connections_per_node=100\n        )\n    \n    def execute_with_retry(self, func, *args, **kwargs):\n        max_retries = 3\n        for i in range(max_retries):\n            try:\n                return func(*args, **kwargs)\n            except redis.exceptions.ConnectionError:\n                if i == max_retries - 1:\n                    raise\n                continue\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e监控和运维\u003c/h2\u003e\n\u003ch3\u003e1. 性能监控\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e关键指标监控\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 内存使用情况\nredis-cli info memory | grep used_memory_human\n\n# 连接数\nredis-cli info clients\n\n# 命令执行统计\nredis-cli info stats\n\n# 慢查询日志\nredis-cli slowlog get 10\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003ePrometheus监控配置\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-yaml\"\u003e# redis_exporter配置\nglobal:\n  scrape_interval: 15s\n\nscrape_configs:\n  - job_name: \u0026#39;redis\u0026#39;\n    static_configs:\n      - targets: [\u0026#39;redis-exporter:9121\u0026#39;]\n    relabel_configs:\n      - source_labels: [__address__]\n        target_label: __param_target\n      - source_labels: [__param_target]\n        target_label: instance\n      - target_label: __address__\n        replacement: redis-exporter:9121\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e2. 告警规则\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eGrafana告警规则\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-yaml\"\u003egroups:\n  - name: redis\n    rules:\n      - alert: RedisDown\n        expr: redis_up == 0\n        for: 1m\n        labels:\n          severity: critical\n        annotations:\n          summary: \u0026quot;Redis instance is down\u0026quot;\n          \n      - alert: RedisMemoryHigh\n        expr: redis_memory_used_bytes / redis_memory_max_bytes \u0026gt; 0.9\n        for: 5m\n        labels:\n          severity: warning\n        annotations:\n          summary: \u0026quot;Redis memory usage is high\u0026quot;\n          \n      - alert: RedisConnectionsHigh\n        expr: redis_connected_clients \u0026gt; 1000\n        for: 5m\n        labels:\n          severity: warning\n        annotations:\n          summary: \u0026quot;Redis has too many connections\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e3. 运维脚本\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e批量操作脚本\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e#!/bin/bash\n# redis_cluster_ops.sh\n\nNODES=(\u0026quot;node1:6379\u0026quot; \u0026quot;node2:6379\u0026quot; \u0026quot;node3:6379\u0026quot;)\nPASSWORD=\u0026quot;your_password\u0026quot;\n\n# 批量执行命令\nexecute_on_cluster() {\n    local cmd=$1\n    for node in \u0026quot;${NODES[@]}\u0026quot;; do\n        echo \u0026quot;Executing on $node: $cmd\u0026quot;\n        redis-cli -h ${node%:*} -p ${node#*:} -a $PASSWORD $cmd\n    done\n}\n\n# 集群健康检查\ncluster_health_check() {\n    echo \u0026quot;Checking cluster health...\u0026quot;\n    execute_on_cluster \u0026quot;cluster nodes\u0026quot;\n    execute_on_cluster \u0026quot;info replication\u0026quot;\n}\n\n# 备份数据\nbackup_cluster() {\n    local backup_dir=\u0026quot;/backup/redis/$(date +%Y%m%d_%H%M%S)\u0026quot;\n    mkdir -p $backup_dir\n    \n    for node in \u0026quot;${NODES[@]}\u0026quot;; do\n        redis-cli -h ${node%:*} -p ${node#*:} -a $PASSWORD \\\n            --rdb $backup_dir/${node%:*}.rdb\n    done\n}\n\n# 调用示例\ncase \u0026quot;$1\u0026quot; in\n    \u0026quot;health\u0026quot;)\n        cluster_health_check\n        ;;\n    \u0026quot;backup\u0026quot;)\n        backup_cluster\n        ;;\n    *)\n        echo \u0026quot;Usage: $0 {health|backup}\u0026quot;\n        ;;\nesac\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e性能优化\u003c/h2\u003e\n\u003ch3\u003e1. 内存优化\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e内存配置优化\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-conf\"\u003e# redis.conf\nmaxmemory 4gb\nmaxmemory-policy allkeys-lru\n\n# 淘汰策略选择\n# volatile-lru: 淘汰设置了TTL且最少使用的key\n# allkeys-lru: 淘汰最少使用的key\n# volatile-random: 随机淘汰设置了TTL的key\n# allkeys-random: 随机淘汰key\n# volatile-ttl: 淘汰即将过期的key\n# noeviction: 不淘汰，返回错误\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e数据结构优化\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# 使用Hash代替String存储对象\nHSET user:1001 name \u0026quot;张三\u0026quot; age 25 email \u0026quot;zhangsan@example.com\u0026quot;\n\n# 使用List代替多个String\nLPUSH recent:users user:1001 user:1002 user:1003\n\n# 使用Set进行快速查找\nSADD user:1001:tags tag1 tag2 tag3\nSISMEMBER user:1001:tags tag1\n\n# 使用Sorted Set进行排序\nZADD ranking 100 user:1001 90 user:1002 80 user:1003\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e2. 网络优化\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eTCP参数优化\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-conf\"\u003e# 系统级优化\necho \u0026#39;net.core.somaxconn = 65535\u0026#39; \u0026gt;\u0026gt; /etc/sysctl.conf\necho \u0026#39;net.ipv4.tcp_max_syn_backlog = 65535\u0026#39; \u0026gt;\u0026gt; /etc/sysctl.conf\necho \u0026#39;net.core.netdev_max_backlog = 5000\u0026#39; \u0026gt;\u0026gt; /etc/sysctl.conf\n\nsysctl -p\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eRedis连接优化\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-conf\"\u003e# redis.conf\ntcp-keepalive 300\ntcp-backlog 511\ntimeout 0\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e3. 持久化优化\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eRDB优化\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-conf\"\u003e# 优化RDB保存策略\nsave 900 1\nsave 300 10\nsave 60 10000\n\n# 启用压缩\nrdbcompression yes\n\n# 启用校验和\nrdbchecksum yes\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eAOF优化\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-conf\"\u003e# 启用AOF\nappendonly yes\n\n# AOF重写策略\nauto-aof-rewrite-percentage 100\nauto-aof-rewrite-min-size 64mb\n\n# fsync策略\nappendfsync everysec\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e安全配置\u003c/h2\u003e\n\u003ch3\u003e1. 认证和授权\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e密码认证\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-conf\"\u003e# redis.conf\nrequirepass your_strong_password\n\n# 禁用危险命令\nrename-command FLUSHDB \u0026quot;\u0026quot;\nrename-command FLUSHALL \u0026quot;\u0026quot;\nrename-command KEYS \u0026quot;\u0026quot;\nrename-command CONFIG \u0026quot;CONFIG_b835c3f8a5d2e7f1\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e2. 网络安全\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e绑定IP和端口\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-conf\"\u003e# 绑定特定IP\nbind 127.0.0.1 10.0.0.1\n\n# 修改默认端口\nport 6380\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e防火墙配置\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e# iptables规则\niptables -A INPUT -p tcp --dport 6379 -s 10.0.0.0/8 -j ACCEPT\niptables -A INPUT -p tcp --dport 6379 -j DROP\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e3. SSL/TLS加密\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eSSL配置\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-conf\"\u003e# redis.conf\ntls-port 6380\ntls-cert-file /path/to/redis.crt\ntls-key-file /path/to/redis.key\ntls-ca-cert-file /path/to/ca.crt\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e总结\u003c/h2\u003e\n\u003cp\u003e构建Redis高可用架构需要综合考虑多个方面：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e架构选择\u003c/strong\u003e：根据业务需求选择主从、哨兵或集群模式\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e配置优化\u003c/strong\u003e：合理配置内存、网络、持久化等参数\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e监控告警\u003c/strong\u003e：建立完善的监控体系和告警机制\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e运维管理\u003c/strong\u003e：制定标准化的运维流程和应急预案\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e安全防护\u003c/strong\u003e：实施多层次的安全防护措施\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e通过合理的架构设计和持续的优化改进，可以构建出稳定、高效、安全的Redis高可用系统，为业务发展提供可靠的缓存服务支撑。\u003c/p\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"children\":[[\"$\",\"$Ld\",null,{\"href\":\"/notes\",\"className\":\"back-button\",\"style\":{\"display\":\"inline-block\",\"background\":\"var(--primary-color)\",\"color\":\"white\",\"border\":\"none\",\"padding\":\"10px 20px\",\"borderRadius\":\"6px\",\"cursor\":\"pointer\",\"marginBottom\":\"20px\",\"textDecoration\":\"none\"},\"children\":[\"← 返回\",\"笔记\",\"列表\"]}],[\"$\",\"article\",null,{\"className\":\"section\",\"children\":[[\"$\",\"header\",null,{\"className\":\"article-header\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"article-title\",\"children\":\"Redis高可用实战\"}],[\"$\",\"div\",null,{\"className\":\"article-meta\",\"children\":[[\"$\",\"div\",null,{\"className\":\"article-meta-info\",\"children\":[[\"$\",\"span\",null,{\"className\":\"article-date\",\"children\":\"2024-10-14\"}],[\"$\",\"span\",null,{\"className\":\"article-category\",\"children\":[\"• \",\"笔记\"]}]]}],[\"$\",\"div\",null,{\"className\":\"article-tags\",\"children\":[[\"$\",\"span\",\"Redis\",{\"className\":\"tag\",\"children\":\"Redis\"}],[\"$\",\"span\",\"高可用\",{\"className\":\"tag\",\"children\":\"高可用\"}],[\"$\",\"span\",\"集群\",{\"className\":\"tag\",\"children\":\"集群\"}],[\"$\",\"span\",\"哨兵\",{\"className\":\"tag\",\"children\":\"哨兵\"}],[\"$\",\"span\",\"分布式缓存\",{\"className\":\"tag\",\"children\":\"分布式缓存\"}]]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"card markdown-content\",\"dangerouslySetInnerHTML\":{\"__html\":\"$e\"}}]]}]]}]\n"])</script><script>self.__next_f.push([1,"9:[\"$\",\"html\",null,{\"lang\":\"zh-CN\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"link\",null,{\"rel\":\"stylesheet\",\"href\":\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css\"}],[\"$\",\"link\",null,{\"rel\":\"stylesheet\",\"href\":\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css\"}]]}],[\"$\",\"body\",null,{\"children\":[\"$\",\"div\",null,{\"className\":\"app\",\"children\":[[\"$\",\"$Lf\",null,{\"siteConfig\":{\"name\":\"Rudy Yang\",\"bio\":\"JAVA | AI | WEB3\",\"social\":[{\"name\":\"github\",\"icon\":\"fab fa-github\",\"url\":\"https://github.com/suogongy\"},{\"name\":\"twitter\",\"icon\":\"fab fa-twitter\",\"url\":\"https://twitter.com/suogongy\"},{\"name\":\"email\",\"icon\":\"fas fa-envelope\",\"url\":\"mailto:haiyuan1832@163.com\"}]}}],[\"$\",\"main\",null,{\"className\":\"main-content\",\"children\":[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"Redis高可用实战 - Personal GitHub Page\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"详细介绍Redis高可用架构的设计原理、实现方案和最佳实践，包括主从复制、哨兵模式、集群模式等核心技术的深入解析。\"}]]\n3:null\n"])</script></body></html>