3:I[4707,[],""]
6:I[6423,[],""]
4:["category","notes","d"]
5:["slug","java-production-troubleshooting","d"]
0:["build",[[["",{"children":[["category","notes","d"],{"children":[["slug","java-production-troubleshooting","d"],{"children":["__PAGE__?{\"category\":\"notes\",\"slug\":\"java-production-troubleshooting\"}",{}]}]}]},"$undefined","$undefined",true],["",{"children":[["category","notes","d"],{"children":[["slug","java-production-troubleshooting","d"],{"children":["__PAGE__",{},[["$L1","$L2",null],null],null]},[null,["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","$4","children","$5","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L6",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined"}]],null]},[null,["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","$4","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L6",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined"}]],null]},[[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/55b7a9e84b417e65.css","precedence":"next","crossOrigin":"$undefined"}]],"$L7"],null],null],["$L8",null]]]]
9:I[2972,["972","static/chunks/972-17ea62b17795b286.js","621","static/chunks/app/%5Bcategory%5D/%5Bslug%5D/page-e1b46fcdbbb20f68.js"],""]
b:I[7140,["972","static/chunks/972-17ea62b17795b286.js","185","static/chunks/app/layout-ca71fef930ed4111.js"],"default"]
a:T5141,<h1>Java项目线上问题排查</h1>
<blockquote>
<p>线上问题排查是Java开发者的必备技能，掌握正确的排查方法和工具是关键</p>
</blockquote>
<h2>问题分类与排查思路</h2>
<h3>1. 常见问题类型</h3>
<pre><code>Java线上问题分类：
├── CPU问题
│   ├── CPU使用率过高
│   ├── CPU负载过高
│   └── 上下文切换频繁
├── 内存问题
│   ├── 内存溢出（OOM）
│   ├── 内存泄漏
│   └── GC频繁
├── 线程问题
│   ├── 死锁
│   ├── 线程阻塞
│   └── 线程数过多
├── 网络问题
│   ├── 连接超时
│   ├── 连接池耗尽
│   └── 网络延迟
└── 应用问题
    ├── 响应缓慢
    ├── 错误率升高
    └── 间歇性故障
</code></pre>
<h3>2. 排查方法论</h3>
<p><strong>问题排查流程</strong></p>
<pre><code>1. 问题现象确认
   ├── 确定问题影响范围
   ├── 收集关键指标
   └── 复现问题现象

2. 初步诊断
   ├── 查看系统资源
   ├── 分析应用日志
   └── 检查监控指标

3. 深入分析
   ├── 使用专业工具
   ├── 分析堆栈信息
   └── 定位根本原因

4. 解决方案
   ├── 制定修复方案
   ├── 实施变更
   └── 验证效果
</code></pre>
<h2>CPU问题排查</h2>
<h3>1. CPU使用率过高</h3>
<p><strong>排查步骤</strong></p>
<pre><code class="language-bash"># 1. 查看CPU使用率
top -p &lt;pid&gt;

# 2. 查看线程CPU使用情况
top -H -p &lt;pid&gt;

# 3. 导出线程栈
jstack &lt;pid&gt; &gt; thread_dump.txt

# 4. 将线程ID转换为16进制
printf &quot;%x\n&quot; &lt;thread_id&gt;

# 5. 在线程栈中查找对应线程
grep -A 20 &lt;hex_thread_id&gt; thread_dump.txt
</code></pre>
<p><strong>自动化排查脚本</strong></p>
<pre><code class="language-bash">#!/bin/bash
# cpu_troubleshoot.sh

PID=$1
if [ -z &quot;$PID&quot; ]; then
    echo &quot;Usage: $0 &lt;pid&gt;&quot;
    exit 1
fi

echo &quot;=== CPU使用情况 ===&quot;
top -p $PID -n 1 | head -20

echo &quot;=== 高CPU线程 ===&quot;
top -H -p $PID -n 1 | head -20

echo &quot;=== 生成线程栈 ===&quot;
jstack $PID &gt; thread_dump_$(date +%Y%m%d_%H%M%S).txt

echo &quot;=== 获取GC信息 ===&quot;
jstat -gc $PID 1s 10

echo &quot;=== 查看堆内存使用 ===&quot;
jmap -histo $PID | head -20
</code></pre>
<h3>2. Java代码中的CPU问题</h3>
<p><strong>死循环检测</strong></p>
<pre><code class="language-java">// 死循环示例
public class DeadLoop {
    public void process() {
        while (true) {
            // 没有退出条件的循环
            try {
                Thread.sleep(1);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
    }
}

// 频繁Full GC
public class FrequentGC {
    public void process() {
        List&lt;byte[]&gt; list = new ArrayList&lt;&gt;();
        while (true) {
            list.add(new byte[1024 * 1024]); // 1MB
        }
    }
}
</code></pre>
<p><strong>CPU密集型操作优化</strong></p>
<pre><code class="language-java">// 优化前
public List&lt;Integer&gt; calculatePrimes(int limit) {
    List&lt;Integer&gt; primes = new ArrayList&lt;&gt;();
    for (int i = 2; i &lt;= limit; i++) {
        if (isPrime(i)) {
            primes.add(i);
        }
    }
    return primes;
}

// 优化后：使用并行流
public List&lt;Integer&gt; calculatePrimes(int limit) {
    return IntStream.rangeClosed(2, limit)
        .parallel()
        .filter(this::isPrime)
        .boxed()
        .collect(Collectors.toList());
}
</code></pre>
<h2>内存问题排查</h2>
<h3>1. 内存溢出（OOM）</h3>
<p><strong>堆内存溢出</strong></p>
<pre><code class="language-bash"># 1. 查看内存使用
jstat -gc &lt;pid&gt; 1s 5

# 2. 生成堆转储文件
jmap -dump:format=b,file=heap.hprof &lt;pid&gt;

# 3. 分析堆转储文件
jhat heap.hprof

# 4. 使用MAT分析
# 启动MAT工具，导入heap.hprof文件
</code></pre>
<p><strong>OOM分析脚本</strong></p>
<pre><code class="language-bash">#!/bin/bash
# oom_analysis.sh

PID=$1
DUMP_FILE=&quot;heap_$(date +%Y%m%d_%H%M%S).hprof&quot;

echo &quot;=== 生成堆转储文件 ===&quot;
jmap -dump:format=b,file=$DUMP_FILE $PID

echo &quot;=== 堆转储文件大小 ===&quot;
ls -lh $DUMP_FILE

echo &quot;=== 使用MAT分析 ===&quot;
echo &quot;请使用MAT工具打开 $DUMP_FILE 进行分析&quot;

# 自动分析脚本
cat &gt; oom_analysis.py &lt;&lt; &#39;EOF&#39;
import sys
import re

def analyze_heap_dump(file_path):
    # 这里可以添加自动分析逻辑
    print(f&quot;分析堆转储文件: {file_path}&quot;)
    
if __name__ == &quot;__main__&quot;:
    if len(sys.argv) != 2:
        print(&quot;Usage: python oom_analysis.py &lt;heap_dump_file&gt;&quot;)
        sys.exit(1)
    
    analyze_heap_dump(sys.argv[1])
EOF

python oom_analysis.py $DUMP_FILE
</code></pre>
<h3>2. 内存泄漏检测</h3>
<p><strong>内存泄漏常见场景</strong></p>
<pre><code class="language-java">// 静态集合持有对象引用
public class MemoryLeak {
    private static final List&lt;Object&gt; cache = new ArrayList&lt;&gt;();
    
    public void addToCache(Object obj) {
        cache.add(obj); // 永远不会被清理
    }
}

// 未关闭的资源
public class ResourceLeak {
    public void processData() {
        try {
            Connection conn = getConnection();
            Statement stmt = conn.createStatement();
            ResultSet rs = stmt.executeQuery(&quot;SELECT * FROM large_table&quot;);
            // 没有关闭连接、Statement和ResultSet
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}

// 监听器未移除
public class ListenerLeak {
    private List&lt;EventListener&gt; listeners = new ArrayList&lt;&gt;();
    
    public void addListener(EventListener listener) {
        listeners.add(listener);
    }
    
    // 缺少removeListener方法
}
</code></pre>
<p><strong>内存泄漏检测工具</strong></p>
<pre><code class="language-java">// 使用WeakReference检测内存泄漏
public class MemoryLeakDetector {
    private static final Map&lt;String, WeakReference&lt;Object&gt;&gt; weakRefs = 
        new ConcurrentHashMap&lt;&gt;();
    
    public static void track(String key, Object obj) {
        weakRefs.put(key, new WeakReference&lt;&gt;(obj));
    }
    
    public static void checkLeaks() {
        for (Map.Entry&lt;String, WeakReference&lt;Object&gt;&gt; entry : weakRefs.entrySet()) {
            WeakReference&lt;Object&gt; ref = entry.getValue();
            if (ref.get() == null) {
                System.out.println(&quot;对象已被回收: &quot; + entry.getKey());
            } else {
                System.out.println(&quot;可能的内存泄漏: &quot; + entry.getKey());
            }
        }
    }
}
</code></pre>
<h2>线程问题排查</h2>
<h3>1. 死锁检测</h3>
<p><strong>死锁检测脚本</strong></p>
<pre><code class="language-bash">#!/bin/bash
# deadlock_detector.sh

PID=$1

echo &quot;=== 检测死锁 ===&quot;
jstack $PID | grep -A 20 &quot;Found one Java-level deadlock&quot;

echo &quot;=== 线程状态统计 ===&quot;
jstack $PID | grep -E &quot;java.lang.Thread.State:&quot; | sort | uniq -c

echo &quot;=== 阻塞线程 ===&quot;
jstack $PID | grep -A 5 &quot;BLOCKED&quot;
</code></pre>
<p><strong>死锁示例和分析</strong></p>
<pre><code class="language-java">// 死锁示例
public class DeadlockExample {
    private static final Object lock1 = new Object();
    private static final Object lock2 = new Object();
    
    public static void main(String[] args) {
        Thread thread1 = new Thread(() -&gt; {
            synchronized (lock1) {
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (lock2) {
                    System.out.println(&quot;Thread 1 acquired both locks&quot;);
                }
            }
        });
        
        Thread thread2 = new Thread(() -&gt; {
            synchronized (lock2) {
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (lock1) {
                    System.out.println(&quot;Thread 2 acquired both locks&quot;);
                }
            }
        });
        
        thread1.start();
        thread2.start();
    }
}
</code></pre>
<h3>2. 线程池问题</h3>
<p><strong>线程池监控</strong></p>
<pre><code class="language-java">@Component
public class ThreadPoolMonitor {
    
    @Autowired
    private ThreadPoolExecutor executor;
    
    @Scheduled(fixedRate = 5000)
    public void monitorThreadPool() {
        System.out.println(&quot;=== 线程池状态 ===&quot;);
        System.out.println(&quot;核心线程数: &quot; + executor.getCorePoolSize());
        System.out.println(&quot;最大线程数: &quot; + executor.getMaximumPoolSize());
        System.out.println(&quot;当前线程数: &quot; + executor.getActiveCount());
        System.out.println(&quot;队列大小: &quot; + executor.getQueue().size());
        System.out.println(&quot;完成任务数: &quot; + executor.getCompletedTaskCount());
        
        // 告警逻辑
        if (executor.getActiveCount() &gt; executor.getMaximumPoolSize() * 0.8) {
            System.out.println(&quot;警告: 线程池使用率过高&quot;);
        }
    }
}
</code></pre>
<h2>网络问题排查</h2>
<h3>1. 连接超时问题</h3>
<p><strong>网络连接监控</strong></p>
<pre><code class="language-java">@Component
public class NetworkMonitor {
    
    private final RestTemplate restTemplate;
    
    public NetworkMonitor() {
        this.restTemplate = new RestTemplate();
        
        // 配置连接超时
        HttpComponentsClientHttpRequestFactory factory = 
            new HttpComponentsClientHttpRequestFactory();
        factory.setConnectTimeout(5000);
        factory.setReadTimeout(10000);
        this.restTemplate.setRequestFactory(factory);
    }
    
    @Scheduled(fixedRate = 30000)
    public void checkConnectivity() {
        try {
            ResponseEntity&lt;String&gt; response = restTemplate.getForEntity(
                &quot;http://example.com/health&quot;, String.class);
            if (response.getStatusCode().is2xxSuccessful()) {
                System.out.println(&quot;网络连接正常&quot;);
            }
        } catch (Exception e) {
            System.err.println(&quot;网络连接异常: &quot; + e.getMessage());
        }
    }
}
</code></pre>
<h3>2. 连接池问题</h3>
<p><strong>数据库连接池监控</strong></p>
<pre><code class="language-java">@Component
public class ConnectionPoolMonitor {
    
    @Autowired
    private DataSource dataSource;
    
    @Scheduled(fixedRate = 10000)
    public void monitorConnectionPool() {
        if (dataSource instanceof HikariDataSource) {
            HikariDataSource hikariDataSource = (HikariDataSource) dataSource;
            HikariPoolMXBean poolProxy = hikariDataSource.getHikariPoolMXBean();
            
            System.out.println(&quot;=== 连接池状态 ===&quot;);
            System.out.println(&quot;活跃连接数: &quot; + poolProxy.getActiveConnections());
            System.out.println(&quot;空闲连接数: &quot; + poolProxy.getIdleConnections());
            System.out.println(&quot;总连接数: &quot; + poolProxy.getTotalConnections());
            System.out.println(&quot;等待线程数: &quot; + poolProxy.getThreadsAwaitingConnection());
            
            // 告警逻辑
            if (poolProxy.getActiveConnections() &gt; poolProxy.getTotalConnections() * 0.8) {
                System.err.println(&quot;警告: 连接池使用率过高&quot;);
            }
        }
    }
}
</code></pre>
<h2>日志分析</h2>
<h3>1. 日志配置优化</h3>
<p><strong>Logback配置</strong></p>
<pre><code class="language-xml">&lt;!-- logback.xml --&gt;
&lt;configuration&gt;
    &lt;appender name=&quot;CONSOLE&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;
        &lt;encoder&gt;
            &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;
    
    &lt;appender name=&quot;FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;
        &lt;file&gt;logs/application.log&lt;/file&gt;
        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;
            &lt;fileNamePattern&gt;logs/application.%d{yyyy-MM-dd}.%i.log&lt;/fileNamePattern&gt;
            &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt;
            &lt;maxHistory&gt;30&lt;/maxHistory&gt;
            &lt;totalSizeCap&gt;3GB&lt;/totalSizeCap&gt;
        &lt;/rollingPolicy&gt;
        &lt;encoder&gt;
            &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;
    
    &lt;!-- 异步日志 --&gt;
    &lt;appender name=&quot;ASYNC_FILE&quot; class=&quot;ch.qos.logback.classic.AsyncAppender&quot;&gt;
        &lt;discardingThreshold&gt;0&lt;/discardingThreshold&gt;
        &lt;queueSize&gt;1024&lt;/queueSize&gt;
        &lt;appender-ref ref=&quot;FILE&quot;/&gt;
    &lt;/appender&gt;
    
    &lt;root level=&quot;INFO&quot;&gt;
        &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;
        &lt;appender-ref ref=&quot;ASYNC_FILE&quot;/&gt;
    &lt;/root&gt;
&lt;/configuration&gt;
</code></pre>
<h3>2. 日志分析脚本</h3>
<p><strong>错误日志分析</strong></p>
<pre><code class="language-bash">#!/bin/bash
# log_analyzer.sh

LOG_FILE=$1
if [ -z &quot;$LOG_FILE&quot; ]; then
    echo &quot;Usage: $0 &lt;log_file&gt;&quot;
    exit 1
fi

echo &quot;=== 错误统计 ===&quot;
grep -E &quot;ERROR|Exception&quot; $LOG_FILE | awk &#39;{print $1, $2}&#39; | sort | uniq -c | sort -nr

echo &quot;=== 最近错误 ===&quot;
tail -100 $LOG_FILE | grep -E &quot;ERROR|Exception&quot; | tail -10

echo &quot;=== HTTP 5xx错误 ===&quot;
grep -E &quot;HTTP/1\.[01]\&quot; [5][0-9][0-9]&quot; $LOG_FILE | awk &#39;{print $7}&#39; | sort | uniq -c | sort -nr

echo &quot;=== 慢查询日志 ===&quot;
grep -E &quot;took.*ms&quot; $LOG_FILE | awk &#39;$NF &gt; 1000 {print $0}&#39;
</code></pre>
<h2>性能监控工具</h2>
<h3>1. JVM监控</h3>
<p><strong>JMX监控</strong></p>
<pre><code class="language-java">@Component
public class JVMMonitor {
    
    private final MemoryMXBean memoryMXBean;
    private final ThreadMXBean threadMXBean;
    private final RuntimeMXBean runtimeMXBean;
    
    public JVMMonitor() {
        MBeanServer mBeanServer = ManagementFactory.getPlatformMBeanServer();
        this.memoryMXBean = ManagementFactory.newPlatformMXBeanProxy(
            mBeanServer, ManagementFactory.MEMORY_MXBEAN_NAME, MemoryMXBean.class);
        this.threadMXBean = ManagementFactory.newPlatformMXBeanProxy(
            mBeanServer, ManagementFactory.THREAD_MXBEAN_NAME, ThreadMXBean.class);
        this.runtimeMXBean = ManagementFactory.newPlatformMXBeanProxy(
            mBeanServer, ManagementFactory.RUNTIME_MXBEAN_NAME, RuntimeMXBean.class);
    }
    
    @Scheduled(fixedRate = 10000)
    public void monitorJVM() {
        // 内存监控
        MemoryUsage heapUsage = memoryMXBean.getHeapMemoryUsage();
        double heapUsagePercent = (double) heapUsage.getUsed() / heapUsage.getMax() * 100;
        
        // 线程监控
        int threadCount = threadMXBean.getThreadCount();
        
        // GC监控
        List&lt;GarbageCollectorMXBean&gt; gcBeans = ManagementFactory.getGarbageCollectorMXBeans();
        
        System.out.println(&quot;=== JVM监控 ===&quot;);
        System.out.println(&quot;堆内存使用率: &quot; + String.format(&quot;%.2f%%&quot;, heapUsagePercent));
        System.out.println(&quot;线程数: &quot; + threadCount);
        
        // 告警逻辑
        if (heapUsagePercent &gt; 80) {
            System.err.println(&quot;警告: 堆内存使用率过高&quot;);
        }
    }
}
</code></pre>
<h3>2. 应用性能监控（APM）</h3>
<p><strong>自定义性能监控</strong></p>
<pre><code class="language-java">@Component
public class PerformanceMonitor {
    
    private final MeterRegistry meterRegistry;
    
    public PerformanceMonitor(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
    }
    
    public void recordApiCall(String apiName, long duration, String status) {
        Timer.Sample sample = Timer.start(meterRegistry);
        sample.stop(Timer.builder(&quot;api.call.time&quot;)
            .tag(&quot;api&quot;, apiName)
            .tag(&quot;status&quot;, status)
            .register(meterRegistry));
        
        Counter.builder(&quot;api.call.count&quot;)
            .tag(&quot;api&quot;, apiName)
            .tag(&quot;status&quot;, status)
            .register(meterRegistry)
            .increment();
    }
    
    @Aspect
    @Component
    public class ApiMonitorAspect {
        
        @Around(&quot;@annotation(Monitored)&quot;)
        public Object monitorApi(ProceedingJoinPoint joinPoint) throws Throwable {
            long startTime = System.currentTimeMillis();
            String apiName = joinPoint.getSignature().getName();
            
            try {
                Object result = joinPoint.proceed();
                long duration = System.currentTimeMillis() - startTime;
                
                performanceMonitor.recordApiCall(apiName, duration, &quot;SUCCESS&quot;);
                return result;
            } catch (Exception e) {
                long duration = System.currentTimeMillis() - startTime;
                
                performanceMonitor.recordApiCall(apiName, duration, &quot;ERROR&quot;);
                throw e;
            }
        }
    }
}
</code></pre>
<h2>应急处理流程</h2>
<h3>1. 故障响应流程</h3>
<pre><code>故障响应流程：
1. 故障发现
   ├── 监控系统告警
   ├── 用户反馈
   └── 主动巡检

2. 故障确认
   ├── 确认影响范围
   ├── 评估严重程度
   └── 启动应急响应

3. 快速止损
   ├── 服务降级
   ├── 流量限制
   └── 紧急回滚

4. 问题定位
   ├── 收集日志
   ├── 分析监控数据
   └── 复现问题

5. 修复验证
   ├── 实施修复
   ├── 验证效果
   └── 恢复服务

6. 复盘总结
   ├── 分析根因
   ├── 制定改进措施
   └── 更新应急预案
</code></pre>
<h3>2. 应急脚本</h3>
<p><strong>服务快速重启脚本</strong></p>
<pre><code class="language-bash">#!/bin/bash
# emergency_restart.sh

SERVICE_NAME=$1
if [ -z &quot;$SERVICE_NAME&quot; ]; then
    echo &quot;Usage: $0 &lt;service_name&gt;&quot;
    exit 1
fi

echo &quot;=== 紧急重启服务: $SERVICE_NAME ===&quot;

# 1. 备份当前状态
echo &quot;备份服务状态...&quot;
systemctl status $SERVICE_NAME &gt; service_status_$(date +%Y%m%d_%H%M%S).txt

# 2. 停止服务
echo &quot;停止服务...&quot;
systemctl stop $SERVICE_NAME

# 3. 等待服务完全停止
sleep 5

# 4. 检查端口是否释放
PORT=$(netstat -tlnp | grep $SERVICE_NAME | awk &#39;{print $4}&#39; | cut -d: -f2)
if [ -n &quot;$PORT&quot; ]; then
    echo &quot;端口 $PORT 仍被占用，强制终止进程...&quot;
    pkill -f $SERVICE_NAME
fi

# 5. 启动服务
echo &quot;启动服务...&quot;
systemctl start $SERVICE_NAME

# 6. 检查服务状态
echo &quot;检查服务状态...&quot;
systemctl status $SERVICE_NAME

# 7. 验证服务可用性
echo &quot;验证服务可用性...&quot;
sleep 10
curl -f http://localhost:8080/health || echo &quot;服务健康检查失败&quot;

echo &quot;=== 重启完成 ===&quot;
</code></pre>
<h2>总结</h2>
<p>Java线上问题排查是一个系统性工程，需要掌握以下关键技能：</p>
<ol>
<li><strong>工具使用</strong>：熟练使用jstat、jstack、jmap、MAT等工具</li>
<li><strong>问题分类</strong>：能够快速识别问题类型和影响范围</li>
<li><strong>分析方法</strong>：掌握科学的分析方法和思路</li>
<li><strong>经验积累</strong>：通过实际案例积累经验</li>
<li><strong>预防措施</strong>：建立完善的监控和预防机制</li>
</ol>
<p>通过系统化的排查方法和工具使用，可以快速定位和解决线上问题，保障系统的稳定运行。</p>
2:["$","div",null,{"children":[["$","$L9",null,{"href":"/notes","className":"back-button","style":{"display":"inline-block","background":"var(--primary-color)","color":"white","border":"none","padding":"10px 20px","borderRadius":"6px","cursor":"pointer","marginBottom":"20px","textDecoration":"none"},"children":["← 返回","笔记","列表"]}],["$","article",null,{"className":"section","children":[["$","header",null,{"className":"article-header","children":[["$","h1",null,{"className":"article-title","children":"Java项目线上问题排查"}],["$","div",null,{"className":"article-meta","children":[["$","div",null,{"className":"article-meta-info","children":[["$","span",null,{"className":"article-date","children":"2024-10-14"}],["$","span",null,{"className":"article-category","children":["• ","笔记"]}]]}],["$","div",null,{"className":"article-tags","children":[["$","span","Java",{"className":"tag","children":"Java"}],["$","span","线上排查",{"className":"tag","children":"线上排查"}],["$","span","性能调优",{"className":"tag","children":"性能调优"}],["$","span","故障诊断",{"className":"tag","children":"故障诊断"}],["$","span","JVM",{"className":"tag","children":"JVM"}]]}]]}]]}],["$","div",null,{"className":"card markdown-content","dangerouslySetInnerHTML":{"__html":"$a"}}]]}]]}]
7:["$","html",null,{"lang":"zh-CN","children":[["$","head",null,{"children":[["$","link",null,{"rel":"stylesheet","href":"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"}],["$","link",null,{"rel":"stylesheet","href":"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css"}]]}],["$","body",null,{"children":["$","div",null,{"className":"app","children":[["$","$Lb",null,{"siteConfig":{"name":"Rudy Yang","bio":"JAVA | AI | WEB3","social":[{"name":"github","icon":"fab fa-github","url":"https://github.com/suogongy"},{"name":"twitter","icon":"fab fa-twitter","url":"https://twitter.com/suogongy"},{"name":"email","icon":"fas fa-envelope","url":"mailto:haiyuan1832@163.com"}]}}],["$","main",null,{"className":"main-content","children":["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L6",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":"404"}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],"notFoundStyles":[]}]}]]}]}]]}]
8:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"Java项目线上问题排查 - Personal GitHub Page"}],["$","meta","3",{"name":"description","content":"详细介绍Java项目在线上环境中常见的问题排查方法、诊断工具和解决方案，包括CPU、内存、线程、网络等方面的故障排查。"}]]
1:null
