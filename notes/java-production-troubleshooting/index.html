<!DOCTYPE html><html lang="zh-CN"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/7805da002e48e736.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-c81f7fd28659d64f.js"/><script src="/_next/static/chunks/fd9d1056-e3d373074663785d.js" async=""></script><script src="/_next/static/chunks/117-86f31d03f8df68a5.js" async=""></script><script src="/_next/static/chunks/main-app-1bdc7b9537d0c130.js" async=""></script><script src="/_next/static/chunks/972-81dbad6abe39d3fa.js" async=""></script><script src="/_next/static/chunks/832-7ea2624e20755f9f.js" async=""></script><script src="/_next/static/chunks/app/%5Bcategory%5D/%5Bslug%5D/page-e466df95e55c7602.js" async=""></script><script src="/_next/static/chunks/app/layout-f3fa7e3100be56de.js" async=""></script><title>Java项目线上问题排查 - Personal GitHub Page</title><meta name="description" content="详细介绍Java项目在线上环境中常见的问题排查方法、诊断工具和解决方案，包括CPU、内存、线程、网络等方面的故障排查。"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css"/><script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body><div class="app"><header class="header "><nav class="nav-container"><a class="nav-brand" href="/"><i class="fas fa-terminal"></i>海元</a><ul class="nav-menu "><li><a class="nav-link " href="/"><i class="fas fa-home"></i> 首页</a></li><li><a class="nav-link " href="/about/"><i class="fas fa-user"></i> 关于</a></li><li><a class="nav-link " href="/projects/"><i class="fas fa-code"></i> 项目</a></li><li><a class="nav-link " href="/notes/"><i class="fas fa-book"></i> 笔记</a></li><li><a class="nav-link " href="/articles/"><i class="fas fa-pen"></i> 随笔</a></li></ul></nav></header><main class="main-content"><div><a class="back-button" style="display:inline-block;background:var(--primary-color);color:white;border:none;padding:10px 20px;border-radius:6px;cursor:pointer;margin-bottom:20px;text-decoration:none" href="/notes/">← 返回<!-- -->笔记<!-- -->列表</a><article class="section"><header class="article-header"><h1 class="article-title">Java项目线上问题排查</h1><div class="article-meta"><div class="article-tags"><span class="tag">Java</span><span class="tag">线上排查</span><span class="tag">性能调优</span><span class="tag">故障诊断</span><span class="tag">JVM</span></div></div></header><div class="card markdown-content"><div class="markdown-content"><div><h1>Java项目线上问题排查</h1>
<blockquote>
<p>线上问题排查是Java开发者的必备技能，掌握正确的排查方法和工具是关键</p>
</blockquote>
<h2>问题分类与排查思路</h2>
<h3>1. 常见问题类型</h3>
<pre><code>Java线上问题分类：
├── CPU问题
│   ├── CPU使用率过高
│   ├── CPU负载过高
│   └── 上下文切换频繁
├── 内存问题
│   ├── 内存溢出（OOM）
│   ├── 内存泄漏
│   └── GC频繁
├── 线程问题
│   ├── 死锁
│   ├── 线程阻塞
│   └── 线程数过多
├── 网络问题
│   ├── 连接超时
│   ├── 连接池耗尽
│   └── 网络延迟
└── 应用问题
    ├── 响应缓慢
    ├── 错误率升高
    └── 间歇性故障
</code></pre>
<h3>2. 排查方法论</h3>
<p><strong>问题排查流程</strong></p>
<pre><code>1. 问题现象确认
   ├── 确定问题影响范围
   ├── 收集关键指标
   └── 复现问题现象

2. 初步诊断
   ├── 查看系统资源
   ├── 分析应用日志
   └── 检查监控指标

3. 深入分析
   ├── 使用专业工具
   ├── 分析堆栈信息
   └── 定位根本原因

4. 解决方案
   ├── 制定修复方案
   ├── 实施变更
   └── 验证效果
</code></pre>
<h2>CPU问题排查</h2>
<h3>1. CPU使用率过高</h3>
<p><strong>排查步骤</strong></p>
<pre><code class="language-bash"># 1. 查看CPU使用率
top -p &lt;pid&gt;

# 2. 查看线程CPU使用情况
top -H -p &lt;pid&gt;

# 3. 导出线程栈
jstack &lt;pid&gt; &gt; thread_dump.txt

# 4. 将线程ID转换为16进制
printf &quot;%x\n&quot; &lt;thread_id&gt;

# 5. 在线程栈中查找对应线程
grep -A 20 &lt;hex_thread_id&gt; thread_dump.txt
</code></pre>
<p><strong>自动化排查脚本</strong></p>
<pre><code class="language-bash">#!/bin/bash
# cpu_troubleshoot.sh

PID=$1
if [ -z &quot;$PID&quot; ]; then
    echo &quot;Usage: $0 &lt;pid&gt;&quot;
    exit 1
fi

echo &quot;=== CPU使用情况 ===&quot;
top -p $PID -n 1 | head -20

echo &quot;=== 高CPU线程 ===&quot;
top -H -p $PID -n 1 | head -20

echo &quot;=== 生成线程栈 ===&quot;
jstack $PID &gt; thread_dump_$(date +%Y%m%d_%H%M%S).txt

echo &quot;=== 获取GC信息 ===&quot;
jstat -gc $PID 1s 10

echo &quot;=== 查看堆内存使用 ===&quot;
jmap -histo $PID | head -20
</code></pre>
<h3>2. Java代码中的CPU问题</h3>
<p><strong>死循环检测</strong></p>
<pre><code class="language-java">// 死循环示例
public class DeadLoop {
    public void process() {
        while (true) {
            // 没有退出条件的循环
            try {
                Thread.sleep(1);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
    }
}

// 频繁Full GC
public class FrequentGC {
    public void process() {
        List&lt;byte[]&gt; list = new ArrayList&lt;&gt;();
        while (true) {
            list.add(new byte[1024 * 1024]); // 1MB
        }
    }
}
</code></pre>
<p><strong>CPU密集型操作优化</strong></p>
<pre><code class="language-java">// 优化前
public List&lt;Integer&gt; calculatePrimes(int limit) {
    List&lt;Integer&gt; primes = new ArrayList&lt;&gt;();
    for (int i = 2; i &lt;= limit; i++) {
        if (isPrime(i)) {
            primes.add(i);
        }
    }
    return primes;
}

// 优化后：使用并行流
public List&lt;Integer&gt; calculatePrimes(int limit) {
    return IntStream.rangeClosed(2, limit)
        .parallel()
        .filter(this::isPrime)
        .boxed()
        .collect(Collectors.toList());
}
</code></pre>
<h2>内存问题排查</h2>
<h3>1. 内存溢出（OOM）</h3>
<p><strong>堆内存溢出</strong></p>
<pre><code class="language-bash"># 1. 查看内存使用
jstat -gc &lt;pid&gt; 1s 5

# 2. 生成堆转储文件
jmap -dump:format=b,file=heap.hprof &lt;pid&gt;

# 3. 分析堆转储文件
jhat heap.hprof

# 4. 使用MAT分析
# 启动MAT工具，导入heap.hprof文件
</code></pre>
<p><strong>OOM分析脚本</strong></p>
<pre><code class="language-bash">#!/bin/bash
# oom_analysis.sh

PID=$1
DUMP_FILE=&quot;heap_$(date +%Y%m%d_%H%M%S).hprof&quot;

echo &quot;=== 生成堆转储文件 ===&quot;
jmap -dump:format=b,file=$DUMP_FILE $PID

echo &quot;=== 堆转储文件大小 ===&quot;
ls -lh $DUMP_FILE

echo &quot;=== 使用MAT分析 ===&quot;
echo &quot;请使用MAT工具打开 $DUMP_FILE 进行分析&quot;

# 自动分析脚本
cat &gt; oom_analysis.py &lt;&lt; &#39;EOF&#39;
import sys
import re

def analyze_heap_dump(file_path):
    # 这里可以添加自动分析逻辑
    print(f&quot;分析堆转储文件: {file_path}&quot;)
    
if __name__ == &quot;__main__&quot;:
    if len(sys.argv) != 2:
        print(&quot;Usage: python oom_analysis.py &lt;heap_dump_file&gt;&quot;)
        sys.exit(1)
    
    analyze_heap_dump(sys.argv[1])
EOF

python oom_analysis.py $DUMP_FILE
</code></pre>
<h3>2. 内存泄漏检测</h3>
<p><strong>内存泄漏常见场景</strong></p>
<pre><code class="language-java">// 静态集合持有对象引用
public class MemoryLeak {
    private static final List&lt;Object&gt; cache = new ArrayList&lt;&gt;();
    
    public void addToCache(Object obj) {
        cache.add(obj); // 永远不会被清理
    }
}

// 未关闭的资源
public class ResourceLeak {
    public void processData() {
        try {
            Connection conn = getConnection();
            Statement stmt = conn.createStatement();
            ResultSet rs = stmt.executeQuery(&quot;SELECT * FROM large_table&quot;);
            // 没有关闭连接、Statement和ResultSet
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}

// 监听器未移除
public class ListenerLeak {
    private List&lt;EventListener&gt; listeners = new ArrayList&lt;&gt;();
    
    public void addListener(EventListener listener) {
        listeners.add(listener);
    }
    
    // 缺少removeListener方法
}
</code></pre>
<p><strong>内存泄漏检测工具</strong></p>
<pre><code class="language-java">// 使用WeakReference检测内存泄漏
public class MemoryLeakDetector {
    private static final Map&lt;String, WeakReference&lt;Object&gt;&gt; weakRefs = 
        new ConcurrentHashMap&lt;&gt;();
    
    public static void track(String key, Object obj) {
        weakRefs.put(key, new WeakReference&lt;&gt;(obj));
    }
    
    public static void checkLeaks() {
        for (Map.Entry&lt;String, WeakReference&lt;Object&gt;&gt; entry : weakRefs.entrySet()) {
            WeakReference&lt;Object&gt; ref = entry.getValue();
            if (ref.get() == null) {
                System.out.println(&quot;对象已被回收: &quot; + entry.getKey());
            } else {
                System.out.println(&quot;可能的内存泄漏: &quot; + entry.getKey());
            }
        }
    }
}
</code></pre>
<h2>线程问题排查</h2>
<h3>1. 死锁检测</h3>
<p><strong>死锁检测脚本</strong></p>
<pre><code class="language-bash">#!/bin/bash
# deadlock_detector.sh

PID=$1

echo &quot;=== 检测死锁 ===&quot;
jstack $PID | grep -A 20 &quot;Found one Java-level deadlock&quot;

echo &quot;=== 线程状态统计 ===&quot;
jstack $PID | grep -E &quot;java.lang.Thread.State:&quot; | sort | uniq -c

echo &quot;=== 阻塞线程 ===&quot;
jstack $PID | grep -A 5 &quot;BLOCKED&quot;
</code></pre>
<p><strong>死锁示例和分析</strong></p>
<pre><code class="language-java">// 死锁示例
public class DeadlockExample {
    private static final Object lock1 = new Object();
    private static final Object lock2 = new Object();
    
    public static void main(String[] args) {
        Thread thread1 = new Thread(() -&gt; {
            synchronized (lock1) {
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (lock2) {
                    System.out.println(&quot;Thread 1 acquired both locks&quot;);
                }
            }
        });
        
        Thread thread2 = new Thread(() -&gt; {
            synchronized (lock2) {
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (lock1) {
                    System.out.println(&quot;Thread 2 acquired both locks&quot;);
                }
            }
        });
        
        thread1.start();
        thread2.start();
    }
}
</code></pre>
<h3>2. 线程池问题</h3>
<p><strong>线程池监控</strong></p>
<pre><code class="language-java">@Component
public class ThreadPoolMonitor {
    
    @Autowired
    private ThreadPoolExecutor executor;
    
    @Scheduled(fixedRate = 5000)
    public void monitorThreadPool() {
        System.out.println(&quot;=== 线程池状态 ===&quot;);
        System.out.println(&quot;核心线程数: &quot; + executor.getCorePoolSize());
        System.out.println(&quot;最大线程数: &quot; + executor.getMaximumPoolSize());
        System.out.println(&quot;当前线程数: &quot; + executor.getActiveCount());
        System.out.println(&quot;队列大小: &quot; + executor.getQueue().size());
        System.out.println(&quot;完成任务数: &quot; + executor.getCompletedTaskCount());
        
        // 告警逻辑
        if (executor.getActiveCount() &gt; executor.getMaximumPoolSize() * 0.8) {
            System.out.println(&quot;警告: 线程池使用率过高&quot;);
        }
    }
}
</code></pre>
<h2>网络问题排查</h2>
<h3>1. 连接超时问题</h3>
<p><strong>网络连接监控</strong></p>
<pre><code class="language-java">@Component
public class NetworkMonitor {
    
    private final RestTemplate restTemplate;
    
    public NetworkMonitor() {
        this.restTemplate = new RestTemplate();
        
        // 配置连接超时
        HttpComponentsClientHttpRequestFactory factory = 
            new HttpComponentsClientHttpRequestFactory();
        factory.setConnectTimeout(5000);
        factory.setReadTimeout(10000);
        this.restTemplate.setRequestFactory(factory);
    }
    
    @Scheduled(fixedRate = 30000)
    public void checkConnectivity() {
        try {
            ResponseEntity&lt;String&gt; response = restTemplate.getForEntity(
                &quot;http://example.com/health&quot;, String.class);
            if (response.getStatusCode().is2xxSuccessful()) {
                System.out.println(&quot;网络连接正常&quot;);
            }
        } catch (Exception e) {
            System.err.println(&quot;网络连接异常: &quot; + e.getMessage());
        }
    }
}
</code></pre>
<h3>2. 连接池问题</h3>
<p><strong>数据库连接池监控</strong></p>
<pre><code class="language-java">@Component
public class ConnectionPoolMonitor {
    
    @Autowired
    private DataSource dataSource;
    
    @Scheduled(fixedRate = 10000)
    public void monitorConnectionPool() {
        if (dataSource instanceof HikariDataSource) {
            HikariDataSource hikariDataSource = (HikariDataSource) dataSource;
            HikariPoolMXBean poolProxy = hikariDataSource.getHikariPoolMXBean();
            
            System.out.println(&quot;=== 连接池状态 ===&quot;);
            System.out.println(&quot;活跃连接数: &quot; + poolProxy.getActiveConnections());
            System.out.println(&quot;空闲连接数: &quot; + poolProxy.getIdleConnections());
            System.out.println(&quot;总连接数: &quot; + poolProxy.getTotalConnections());
            System.out.println(&quot;等待线程数: &quot; + poolProxy.getThreadsAwaitingConnection());
            
            // 告警逻辑
            if (poolProxy.getActiveConnections() &gt; poolProxy.getTotalConnections() * 0.8) {
                System.err.println(&quot;警告: 连接池使用率过高&quot;);
            }
        }
    }
}
</code></pre>
<h2>日志分析</h2>
<h3>1. 日志配置优化</h3>
<p><strong>Logback配置</strong></p>
<pre><code class="language-xml">&lt;!-- logback.xml --&gt;
&lt;configuration&gt;
    &lt;appender name=&quot;CONSOLE&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;
        &lt;encoder&gt;
            &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;
    
    &lt;appender name=&quot;FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;
        &lt;file&gt;logs/application.log&lt;/file&gt;
        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;
            &lt;fileNamePattern&gt;logs/application.%d{yyyy-MM-dd}.%i.log&lt;/fileNamePattern&gt;
            &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt;
            &lt;maxHistory&gt;30&lt;/maxHistory&gt;
            &lt;totalSizeCap&gt;3GB&lt;/totalSizeCap&gt;
        &lt;/rollingPolicy&gt;
        &lt;encoder&gt;
            &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;
    
    &lt;!-- 异步日志 --&gt;
    &lt;appender name=&quot;ASYNC_FILE&quot; class=&quot;ch.qos.logback.classic.AsyncAppender&quot;&gt;
        &lt;discardingThreshold&gt;0&lt;/discardingThreshold&gt;
        &lt;queueSize&gt;1024&lt;/queueSize&gt;
        &lt;appender-ref ref=&quot;FILE&quot;/&gt;
    &lt;/appender&gt;
    
    &lt;root level=&quot;INFO&quot;&gt;
        &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;
        &lt;appender-ref ref=&quot;ASYNC_FILE&quot;/&gt;
    &lt;/root&gt;
&lt;/configuration&gt;
</code></pre>
<h3>2. 日志分析脚本</h3>
<p><strong>错误日志分析</strong></p>
<pre><code class="language-bash">#!/bin/bash
# log_analyzer.sh

LOG_FILE=$1
if [ -z &quot;$LOG_FILE&quot; ]; then
    echo &quot;Usage: $0 &lt;log_file&gt;&quot;
    exit 1
fi

echo &quot;=== 错误统计 ===&quot;
grep -E &quot;ERROR|Exception&quot; $LOG_FILE | awk &#39;{print $1, $2}&#39; | sort | uniq -c | sort -nr

echo &quot;=== 最近错误 ===&quot;
tail -100 $LOG_FILE | grep -E &quot;ERROR|Exception&quot; | tail -10

echo &quot;=== HTTP 5xx错误 ===&quot;
grep -E &quot;HTTP/1\.[01]\&quot; [5][0-9][0-9]&quot; $LOG_FILE | awk &#39;{print $7}&#39; | sort | uniq -c | sort -nr

echo &quot;=== 慢查询日志 ===&quot;
grep -E &quot;took.*ms&quot; $LOG_FILE | awk &#39;$NF &gt; 1000 {print $0}&#39;
</code></pre>
<h2>性能监控工具</h2>
<h3>1. JVM监控</h3>
<p><strong>JMX监控</strong></p>
<pre><code class="language-java">@Component
public class JVMMonitor {
    
    private final MemoryMXBean memoryMXBean;
    private final ThreadMXBean threadMXBean;
    private final RuntimeMXBean runtimeMXBean;
    
    public JVMMonitor() {
        MBeanServer mBeanServer = ManagementFactory.getPlatformMBeanServer();
        this.memoryMXBean = ManagementFactory.newPlatformMXBeanProxy(
            mBeanServer, ManagementFactory.MEMORY_MXBEAN_NAME, MemoryMXBean.class);
        this.threadMXBean = ManagementFactory.newPlatformMXBeanProxy(
            mBeanServer, ManagementFactory.THREAD_MXBEAN_NAME, ThreadMXBean.class);
        this.runtimeMXBean = ManagementFactory.newPlatformMXBeanProxy(
            mBeanServer, ManagementFactory.RUNTIME_MXBEAN_NAME, RuntimeMXBean.class);
    }
    
    @Scheduled(fixedRate = 10000)
    public void monitorJVM() {
        // 内存监控
        MemoryUsage heapUsage = memoryMXBean.getHeapMemoryUsage();
        double heapUsagePercent = (double) heapUsage.getUsed() / heapUsage.getMax() * 100;
        
        // 线程监控
        int threadCount = threadMXBean.getThreadCount();
        
        // GC监控
        List&lt;GarbageCollectorMXBean&gt; gcBeans = ManagementFactory.getGarbageCollectorMXBeans();
        
        System.out.println(&quot;=== JVM监控 ===&quot;);
        System.out.println(&quot;堆内存使用率: &quot; + String.format(&quot;%.2f%%&quot;, heapUsagePercent));
        System.out.println(&quot;线程数: &quot; + threadCount);
        
        // 告警逻辑
        if (heapUsagePercent &gt; 80) {
            System.err.println(&quot;警告: 堆内存使用率过高&quot;);
        }
    }
}
</code></pre>
<h3>2. 应用性能监控（APM）</h3>
<p><strong>自定义性能监控</strong></p>
<pre><code class="language-java">@Component
public class PerformanceMonitor {
    
    private final MeterRegistry meterRegistry;
    
    public PerformanceMonitor(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
    }
    
    public void recordApiCall(String apiName, long duration, String status) {
        Timer.Sample sample = Timer.start(meterRegistry);
        sample.stop(Timer.builder(&quot;api.call.time&quot;)
            .tag(&quot;api&quot;, apiName)
            .tag(&quot;status&quot;, status)
            .register(meterRegistry));
        
        Counter.builder(&quot;api.call.count&quot;)
            .tag(&quot;api&quot;, apiName)
            .tag(&quot;status&quot;, status)
            .register(meterRegistry)
            .increment();
    }
    
    @Aspect
    @Component
    public class ApiMonitorAspect {
        
        @Around(&quot;@annotation(Monitored)&quot;)
        public Object monitorApi(ProceedingJoinPoint joinPoint) throws Throwable {
            long startTime = System.currentTimeMillis();
            String apiName = joinPoint.getSignature().getName();
            
            try {
                Object result = joinPoint.proceed();
                long duration = System.currentTimeMillis() - startTime;
                
                performanceMonitor.recordApiCall(apiName, duration, &quot;SUCCESS&quot;);
                return result;
            } catch (Exception e) {
                long duration = System.currentTimeMillis() - startTime;
                
                performanceMonitor.recordApiCall(apiName, duration, &quot;ERROR&quot;);
                throw e;
            }
        }
    }
}
</code></pre>
<h2>应急处理流程</h2>
<h3>1. 故障响应流程</h3>
<pre><code>故障响应流程：
1. 故障发现
   ├── 监控系统告警
   ├── 用户反馈
   └── 主动巡检

2. 故障确认
   ├── 确认影响范围
   ├── 评估严重程度
   └── 启动应急响应

3. 快速止损
   ├── 服务降级
   ├── 流量限制
   └── 紧急回滚

4. 问题定位
   ├── 收集日志
   ├── 分析监控数据
   └── 复现问题

5. 修复验证
   ├── 实施修复
   ├── 验证效果
   └── 恢复服务

6. 复盘总结
   ├── 分析根因
   ├── 制定改进措施
   └── 更新应急预案
</code></pre>
<h3>2. 应急脚本</h3>
<p><strong>服务快速重启脚本</strong></p>
<pre><code class="language-bash">#!/bin/bash
# emergency_restart.sh

SERVICE_NAME=$1
if [ -z &quot;$SERVICE_NAME&quot; ]; then
    echo &quot;Usage: $0 &lt;service_name&gt;&quot;
    exit 1
fi

echo &quot;=== 紧急重启服务: $SERVICE_NAME ===&quot;

# 1. 备份当前状态
echo &quot;备份服务状态...&quot;
systemctl status $SERVICE_NAME &gt; service_status_$(date +%Y%m%d_%H%M%S).txt

# 2. 停止服务
echo &quot;停止服务...&quot;
systemctl stop $SERVICE_NAME

# 3. 等待服务完全停止
sleep 5

# 4. 检查端口是否释放
PORT=$(netstat -tlnp | grep $SERVICE_NAME | awk &#39;{print $4}&#39; | cut -d: -f2)
if [ -n &quot;$PORT&quot; ]; then
    echo &quot;端口 $PORT 仍被占用，强制终止进程...&quot;
    pkill -f $SERVICE_NAME
fi

# 5. 启动服务
echo &quot;启动服务...&quot;
systemctl start $SERVICE_NAME

# 6. 检查服务状态
echo &quot;检查服务状态...&quot;
systemctl status $SERVICE_NAME

# 7. 验证服务可用性
echo &quot;验证服务可用性...&quot;
sleep 10
curl -f http://localhost:8080/health || echo &quot;服务健康检查失败&quot;

echo &quot;=== 重启完成 ===&quot;
</code></pre>
<h2>总结</h2>
<p>Java线上问题排查是一个系统性工程，需要掌握以下关键技能：</p>
<ol>
<li><strong>工具使用</strong>：熟练使用jstat、jstack、jmap、MAT等工具</li>
<li><strong>问题分类</strong>：能够快速识别问题类型和影响范围</li>
<li><strong>分析方法</strong>：掌握科学的分析方法和思路</li>
<li><strong>经验积累</strong>：通过实际案例积累经验</li>
<li><strong>预防措施</strong>：建立完善的监控和预防机制</li>
</ol>
<p>通过系统化的排查方法和工具使用，可以快速定位和解决线上问题，保障系统的稳定运行。</p>
</div></div></div></article></div></main></div><script src="/_next/static/chunks/webpack-c81f7fd28659d64f.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/7805da002e48e736.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"2:I[2846,[],\"\"]\n5:I[4707,[],\"\"]\n8:I[6423,[],\"\"]\nb:I[1060,[],\"\"]\n6:[\"category\",\"notes\",\"d\"]\n7:[\"slug\",\"java-production-troubleshooting\",\"d\"]\nc:[]\n0:[\"$\",\"$L2\",null,{\"buildId\":\"build\",\"assetPrefix\":\"\",\"urlParts\":[\"\",\"notes\",\"java-production-troubleshooting\",\"\"],\"initialTree\":[\"\",{\"children\":[[\"category\",\"notes\",\"d\"],{\"children\":[[\"slug\",\"java-production-troubleshooting\",\"d\"],{\"children\":[\"__PAGE__?{\\\"category\\\":\\\"notes\\\",\\\"slug\\\":\\\"java-production-troubleshooting\\\"}\",{}]}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"category\",\"notes\",\"d\"],{\"children\":[[\"slug\",\"java-production-troubleshooting\",\"d\"],{\"children\":[\"__PAGE__\",{},[[\"$L3\",\"$L4\",null],null],null]},[null,[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$6\",\"children\",\"$7\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}]],null]},[null,[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$6\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}]],null]},[[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/7805da002e48e736.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],\"$L9\"],null],null],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$La\"],\"globalErrorComponent\":\"$b\",\"missingSlots\":\"$Wc\"}]\n"])</script><script>self.__next_f.push([1,"d:I[2972,[\"972\",\"static/chunks/972-81dbad6abe39d3fa.js\",\"832\",\"static/chunks/832-7ea2624e20755f9f.js\",\"621\",\"static/chunks/app/%5Bcategory%5D/%5Bslug%5D/page-e466df95e55c7602.js\"],\"\"]\ne:I[2024,[\"972\",\"static/chunks/972-81dbad6abe39d3fa.js\",\"832\",\"static/chunks/832-7ea2624e20755f9f.js\",\"621\",\"static/chunks/app/%5Bcategory%5D/%5Bslug%5D/page-e466df95e55c7602.js\"],\"default\"]\n10:I[7140,[\"972\",\"static/chunks/972-81dbad6abe39d3fa.js\",\"185\",\"static/chunks/app/layout-f3fa7e3100be56de.js\"],\"default\"]\nf:T46b3,"])</script><script>self.__next_f.push([1,"\n# Java项目线上问题排查\n\n\u003e 线上问题排查是Java开发者的必备技能，掌握正确的排查方法和工具是关键\n\n## 问题分类与排查思路\n\n### 1. 常见问题类型\n\n```\nJava线上问题分类：\n├── CPU问题\n│   ├── CPU使用率过高\n│   ├── CPU负载过高\n│   └── 上下文切换频繁\n├── 内存问题\n│   ├── 内存溢出（OOM）\n│   ├── 内存泄漏\n│   └── GC频繁\n├── 线程问题\n│   ├── 死锁\n│   ├── 线程阻塞\n│   └── 线程数过多\n├── 网络问题\n│   ├── 连接超时\n│   ├── 连接池耗尽\n│   └── 网络延迟\n└── 应用问题\n    ├── 响应缓慢\n    ├── 错误率升高\n    └── 间歇性故障\n```\n\n### 2. 排查方法论\n\n**问题排查流程**\n```\n1. 问题现象确认\n   ├── 确定问题影响范围\n   ├── 收集关键指标\n   └── 复现问题现象\n\n2. 初步诊断\n   ├── 查看系统资源\n   ├── 分析应用日志\n   └── 检查监控指标\n\n3. 深入分析\n   ├── 使用专业工具\n   ├── 分析堆栈信息\n   └── 定位根本原因\n\n4. 解决方案\n   ├── 制定修复方案\n   ├── 实施变更\n   └── 验证效果\n```\n\n## CPU问题排查\n\n### 1. CPU使用率过高\n\n**排查步骤**\n```bash\n# 1. 查看CPU使用率\ntop -p \u003cpid\u003e\n\n# 2. 查看线程CPU使用情况\ntop -H -p \u003cpid\u003e\n\n# 3. 导出线程栈\njstack \u003cpid\u003e \u003e thread_dump.txt\n\n# 4. 将线程ID转换为16进制\nprintf \"%x\\n\" \u003cthread_id\u003e\n\n# 5. 在线程栈中查找对应线程\ngrep -A 20 \u003chex_thread_id\u003e thread_dump.txt\n```\n\n**自动化排查脚本**\n```bash\n#!/bin/bash\n# cpu_troubleshoot.sh\n\nPID=$1\nif [ -z \"$PID\" ]; then\n    echo \"Usage: $0 \u003cpid\u003e\"\n    exit 1\nfi\n\necho \"=== CPU使用情况 ===\"\ntop -p $PID -n 1 | head -20\n\necho \"=== 高CPU线程 ===\"\ntop -H -p $PID -n 1 | head -20\n\necho \"=== 生成线程栈 ===\"\njstack $PID \u003e thread_dump_$(date +%Y%m%d_%H%M%S).txt\n\necho \"=== 获取GC信息 ===\"\njstat -gc $PID 1s 10\n\necho \"=== 查看堆内存使用 ===\"\njmap -histo $PID | head -20\n```\n\n### 2. Java代码中的CPU问题\n\n**死循环检测**\n```java\n// 死循环示例\npublic class DeadLoop {\n    public void process() {\n        while (true) {\n            // 没有退出条件的循环\n            try {\n                Thread.sleep(1);\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n}\n\n// 频繁Full GC\npublic class FrequentGC {\n    public void process() {\n        List\u003cbyte[]\u003e list = new ArrayList\u003c\u003e();\n        while (true) {\n            list.add(new byte[1024 * 1024]); // 1MB\n        }\n    }\n}\n```\n\n**CPU密集型操作优化**\n```java\n// 优化前\npublic List\u003cInteger\u003e calculatePrimes(int limit) {\n    List\u003cInteger\u003e primes = new ArrayList\u003c\u003e();\n    for (int i = 2; i \u003c= limit; i++) {\n        if (isPrime(i)) {\n            primes.add(i);\n        }\n    }\n    return primes;\n}\n\n// 优化后：使用并行流\npublic List\u003cInteger\u003e calculatePrimes(int limit) {\n    return IntStream.rangeClosed(2, limit)\n        .parallel()\n        .filter(this::isPrime)\n        .boxed()\n        .collect(Collectors.toList());\n}\n```\n\n## 内存问题排查\n\n### 1. 内存溢出（OOM）\n\n**堆内存溢出**\n```bash\n# 1. 查看内存使用\njstat -gc \u003cpid\u003e 1s 5\n\n# 2. 生成堆转储文件\njmap -dump:format=b,file=heap.hprof \u003cpid\u003e\n\n# 3. 分析堆转储文件\njhat heap.hprof\n\n# 4. 使用MAT分析\n# 启动MAT工具，导入heap.hprof文件\n```\n\n**OOM分析脚本**\n```bash\n#!/bin/bash\n# oom_analysis.sh\n\nPID=$1\nDUMP_FILE=\"heap_$(date +%Y%m%d_%H%M%S).hprof\"\n\necho \"=== 生成堆转储文件 ===\"\njmap -dump:format=b,file=$DUMP_FILE $PID\n\necho \"=== 堆转储文件大小 ===\"\nls -lh $DUMP_FILE\n\necho \"=== 使用MAT分析 ===\"\necho \"请使用MAT工具打开 $DUMP_FILE 进行分析\"\n\n# 自动分析脚本\ncat \u003e oom_analysis.py \u003c\u003c 'EOF'\nimport sys\nimport re\n\ndef analyze_heap_dump(file_path):\n    # 这里可以添加自动分析逻辑\n    print(f\"分析堆转储文件: {file_path}\")\n    \nif __name__ == \"__main__\":\n    if len(sys.argv) != 2:\n        print(\"Usage: python oom_analysis.py \u003cheap_dump_file\u003e\")\n        sys.exit(1)\n    \n    analyze_heap_dump(sys.argv[1])\nEOF\n\npython oom_analysis.py $DUMP_FILE\n```\n\n### 2. 内存泄漏检测\n\n**内存泄漏常见场景**\n```java\n// 静态集合持有对象引用\npublic class MemoryLeak {\n    private static final List\u003cObject\u003e cache = new ArrayList\u003c\u003e();\n    \n    public void addToCache(Object obj) {\n        cache.add(obj); // 永远不会被清理\n    }\n}\n\n// 未关闭的资源\npublic class ResourceLeak {\n    public void processData() {\n        try {\n            Connection conn = getConnection();\n            Statement stmt = conn.createStatement();\n            ResultSet rs = stmt.executeQuery(\"SELECT * FROM large_table\");\n            // 没有关闭连接、Statement和ResultSet\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n// 监听器未移除\npublic class ListenerLeak {\n    private List\u003cEventListener\u003e listeners = new ArrayList\u003c\u003e();\n    \n    public void addListener(EventListener listener) {\n        listeners.add(listener);\n    }\n    \n    // 缺少removeListener方法\n}\n```\n\n**内存泄漏检测工具**\n```java\n// 使用WeakReference检测内存泄漏\npublic class MemoryLeakDetector {\n    private static final Map\u003cString, WeakReference\u003cObject\u003e\u003e weakRefs = \n        new ConcurrentHashMap\u003c\u003e();\n    \n    public static void track(String key, Object obj) {\n        weakRefs.put(key, new WeakReference\u003c\u003e(obj));\n    }\n    \n    public static void checkLeaks() {\n        for (Map.Entry\u003cString, WeakReference\u003cObject\u003e\u003e entry : weakRefs.entrySet()) {\n            WeakReference\u003cObject\u003e ref = entry.getValue();\n            if (ref.get() == null) {\n                System.out.println(\"对象已被回收: \" + entry.getKey());\n            } else {\n                System.out.println(\"可能的内存泄漏: \" + entry.getKey());\n            }\n        }\n    }\n}\n```\n\n## 线程问题排查\n\n### 1. 死锁检测\n\n**死锁检测脚本**\n```bash\n#!/bin/bash\n# deadlock_detector.sh\n\nPID=$1\n\necho \"=== 检测死锁 ===\"\njstack $PID | grep -A 20 \"Found one Java-level deadlock\"\n\necho \"=== 线程状态统计 ===\"\njstack $PID | grep -E \"java.lang.Thread.State:\" | sort | uniq -c\n\necho \"=== 阻塞线程 ===\"\njstack $PID | grep -A 5 \"BLOCKED\"\n```\n\n**死锁示例和分析**\n```java\n// 死锁示例\npublic class DeadlockExample {\n    private static final Object lock1 = new Object();\n    private static final Object lock2 = new Object();\n    \n    public static void main(String[] args) {\n        Thread thread1 = new Thread(() -\u003e {\n            synchronized (lock1) {\n                try {\n                    Thread.sleep(100);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                synchronized (lock2) {\n                    System.out.println(\"Thread 1 acquired both locks\");\n                }\n            }\n        });\n        \n        Thread thread2 = new Thread(() -\u003e {\n            synchronized (lock2) {\n                try {\n                    Thread.sleep(100);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                synchronized (lock1) {\n                    System.out.println(\"Thread 2 acquired both locks\");\n                }\n            }\n        });\n        \n        thread1.start();\n        thread2.start();\n    }\n}\n```\n\n### 2. 线程池问题\n\n**线程池监控**\n```java\n@Component\npublic class ThreadPoolMonitor {\n    \n    @Autowired\n    private ThreadPoolExecutor executor;\n    \n    @Scheduled(fixedRate = 5000)\n    public void monitorThreadPool() {\n        System.out.println(\"=== 线程池状态 ===\");\n        System.out.println(\"核心线程数: \" + executor.getCorePoolSize());\n        System.out.println(\"最大线程数: \" + executor.getMaximumPoolSize());\n        System.out.println(\"当前线程数: \" + executor.getActiveCount());\n        System.out.println(\"队列大小: \" + executor.getQueue().size());\n        System.out.println(\"完成任务数: \" + executor.getCompletedTaskCount());\n        \n        // 告警逻辑\n        if (executor.getActiveCount() \u003e executor.getMaximumPoolSize() * 0.8) {\n            System.out.println(\"警告: 线程池使用率过高\");\n        }\n    }\n}\n```\n\n## 网络问题排查\n\n### 1. 连接超时问题\n\n**网络连接监控**\n```java\n@Component\npublic class NetworkMonitor {\n    \n    private final RestTemplate restTemplate;\n    \n    public NetworkMonitor() {\n        this.restTemplate = new RestTemplate();\n        \n        // 配置连接超时\n        HttpComponentsClientHttpRequestFactory factory = \n            new HttpComponentsClientHttpRequestFactory();\n        factory.setConnectTimeout(5000);\n        factory.setReadTimeout(10000);\n        this.restTemplate.setRequestFactory(factory);\n    }\n    \n    @Scheduled(fixedRate = 30000)\n    public void checkConnectivity() {\n        try {\n            ResponseEntity\u003cString\u003e response = restTemplate.getForEntity(\n                \"http://example.com/health\", String.class);\n            if (response.getStatusCode().is2xxSuccessful()) {\n                System.out.println(\"网络连接正常\");\n            }\n        } catch (Exception e) {\n            System.err.println(\"网络连接异常: \" + e.getMessage());\n        }\n    }\n}\n```\n\n### 2. 连接池问题\n\n**数据库连接池监控**\n```java\n@Component\npublic class ConnectionPoolMonitor {\n    \n    @Autowired\n    private DataSource dataSource;\n    \n    @Scheduled(fixedRate = 10000)\n    public void monitorConnectionPool() {\n        if (dataSource instanceof HikariDataSource) {\n            HikariDataSource hikariDataSource = (HikariDataSource) dataSource;\n            HikariPoolMXBean poolProxy = hikariDataSource.getHikariPoolMXBean();\n            \n            System.out.println(\"=== 连接池状态 ===\");\n            System.out.println(\"活跃连接数: \" + poolProxy.getActiveConnections());\n            System.out.println(\"空闲连接数: \" + poolProxy.getIdleConnections());\n            System.out.println(\"总连接数: \" + poolProxy.getTotalConnections());\n            System.out.println(\"等待线程数: \" + poolProxy.getThreadsAwaitingConnection());\n            \n            // 告警逻辑\n            if (poolProxy.getActiveConnections() \u003e poolProxy.getTotalConnections() * 0.8) {\n                System.err.println(\"警告: 连接池使用率过高\");\n            }\n        }\n    }\n}\n```\n\n## 日志分析\n\n### 1. 日志配置优化\n\n**Logback配置**\n```xml\n\u003c!-- logback.xml --\u003e\n\u003cconfiguration\u003e\n    \u003cappender name=\"CONSOLE\" class=\"ch.qos.logback.core.ConsoleAppender\"\u003e\n        \u003cencoder\u003e\n            \u003cpattern\u003e%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n\u003c/pattern\u003e\n        \u003c/encoder\u003e\n    \u003c/appender\u003e\n    \n    \u003cappender name=\"FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"\u003e\n        \u003cfile\u003elogs/application.log\u003c/file\u003e\n        \u003crollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"\u003e\n            \u003cfileNamePattern\u003elogs/application.%d{yyyy-MM-dd}.%i.log\u003c/fileNamePattern\u003e\n            \u003cmaxFileSize\u003e100MB\u003c/maxFileSize\u003e\n            \u003cmaxHistory\u003e30\u003c/maxHistory\u003e\n            \u003ctotalSizeCap\u003e3GB\u003c/totalSizeCap\u003e\n        \u003c/rollingPolicy\u003e\n        \u003cencoder\u003e\n            \u003cpattern\u003e%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n\u003c/pattern\u003e\n        \u003c/encoder\u003e\n    \u003c/appender\u003e\n    \n    \u003c!-- 异步日志 --\u003e\n    \u003cappender name=\"ASYNC_FILE\" class=\"ch.qos.logback.classic.AsyncAppender\"\u003e\n        \u003cdiscardingThreshold\u003e0\u003c/discardingThreshold\u003e\n        \u003cqueueSize\u003e1024\u003c/queueSize\u003e\n        \u003cappender-ref ref=\"FILE\"/\u003e\n    \u003c/appender\u003e\n    \n    \u003croot level=\"INFO\"\u003e\n        \u003cappender-ref ref=\"CONSOLE\"/\u003e\n        \u003cappender-ref ref=\"ASYNC_FILE\"/\u003e\n    \u003c/root\u003e\n\u003c/configuration\u003e\n```\n\n### 2. 日志分析脚本\n\n**错误日志分析**\n```bash\n#!/bin/bash\n# log_analyzer.sh\n\nLOG_FILE=$1\nif [ -z \"$LOG_FILE\" ]; then\n    echo \"Usage: $0 \u003clog_file\u003e\"\n    exit 1\nfi\n\necho \"=== 错误统计 ===\"\ngrep -E \"ERROR|Exception\" $LOG_FILE | awk '{print $1, $2}' | sort | uniq -c | sort -nr\n\necho \"=== 最近错误 ===\"\ntail -100 $LOG_FILE | grep -E \"ERROR|Exception\" | tail -10\n\necho \"=== HTTP 5xx错误 ===\"\ngrep -E \"HTTP/1\\.[01]\\\" [5][0-9][0-9]\" $LOG_FILE | awk '{print $7}' | sort | uniq -c | sort -nr\n\necho \"=== 慢查询日志 ===\"\ngrep -E \"took.*ms\" $LOG_FILE | awk '$NF \u003e 1000 {print $0}'\n```\n\n## 性能监控工具\n\n### 1. JVM监控\n\n**JMX监控**\n```java\n@Component\npublic class JVMMonitor {\n    \n    private final MemoryMXBean memoryMXBean;\n    private final ThreadMXBean threadMXBean;\n    private final RuntimeMXBean runtimeMXBean;\n    \n    public JVMMonitor() {\n        MBeanServer mBeanServer = ManagementFactory.getPlatformMBeanServer();\n        this.memoryMXBean = ManagementFactory.newPlatformMXBeanProxy(\n            mBeanServer, ManagementFactory.MEMORY_MXBEAN_NAME, MemoryMXBean.class);\n        this.threadMXBean = ManagementFactory.newPlatformMXBeanProxy(\n            mBeanServer, ManagementFactory.THREAD_MXBEAN_NAME, ThreadMXBean.class);\n        this.runtimeMXBean = ManagementFactory.newPlatformMXBeanProxy(\n            mBeanServer, ManagementFactory.RUNTIME_MXBEAN_NAME, RuntimeMXBean.class);\n    }\n    \n    @Scheduled(fixedRate = 10000)\n    public void monitorJVM() {\n        // 内存监控\n        MemoryUsage heapUsage = memoryMXBean.getHeapMemoryUsage();\n        double heapUsagePercent = (double) heapUsage.getUsed() / heapUsage.getMax() * 100;\n        \n        // 线程监控\n        int threadCount = threadMXBean.getThreadCount();\n        \n        // GC监控\n        List\u003cGarbageCollectorMXBean\u003e gcBeans = ManagementFactory.getGarbageCollectorMXBeans();\n        \n        System.out.println(\"=== JVM监控 ===\");\n        System.out.println(\"堆内存使用率: \" + String.format(\"%.2f%%\", heapUsagePercent));\n        System.out.println(\"线程数: \" + threadCount);\n        \n        // 告警逻辑\n        if (heapUsagePercent \u003e 80) {\n            System.err.println(\"警告: 堆内存使用率过高\");\n        }\n    }\n}\n```\n\n### 2. 应用性能监控（APM）\n\n**自定义性能监控**\n```java\n@Component\npublic class PerformanceMonitor {\n    \n    private final MeterRegistry meterRegistry;\n    \n    public PerformanceMonitor(MeterRegistry meterRegistry) {\n        this.meterRegistry = meterRegistry;\n    }\n    \n    public void recordApiCall(String apiName, long duration, String status) {\n        Timer.Sample sample = Timer.start(meterRegistry);\n        sample.stop(Timer.builder(\"api.call.time\")\n            .tag(\"api\", apiName)\n            .tag(\"status\", status)\n            .register(meterRegistry));\n        \n        Counter.builder(\"api.call.count\")\n            .tag(\"api\", apiName)\n            .tag(\"status\", status)\n            .register(meterRegistry)\n            .increment();\n    }\n    \n    @Aspect\n    @Component\n    public class ApiMonitorAspect {\n        \n        @Around(\"@annotation(Monitored)\")\n        public Object monitorApi(ProceedingJoinPoint joinPoint) throws Throwable {\n            long startTime = System.currentTimeMillis();\n            String apiName = joinPoint.getSignature().getName();\n            \n            try {\n                Object result = joinPoint.proceed();\n                long duration = System.currentTimeMillis() - startTime;\n                \n                performanceMonitor.recordApiCall(apiName, duration, \"SUCCESS\");\n                return result;\n            } catch (Exception e) {\n                long duration = System.currentTimeMillis() - startTime;\n                \n                performanceMonitor.recordApiCall(apiName, duration, \"ERROR\");\n                throw e;\n            }\n        }\n    }\n}\n```\n\n## 应急处理流程\n\n### 1. 故障响应流程\n\n```\n故障响应流程：\n1. 故障发现\n   ├── 监控系统告警\n   ├── 用户反馈\n   └── 主动巡检\n\n2. 故障确认\n   ├── 确认影响范围\n   ├── 评估严重程度\n   └── 启动应急响应\n\n3. 快速止损\n   ├── 服务降级\n   ├── 流量限制\n   └── 紧急回滚\n\n4. 问题定位\n   ├── 收集日志\n   ├── 分析监控数据\n   └── 复现问题\n\n5. 修复验证\n   ├── 实施修复\n   ├── 验证效果\n   └── 恢复服务\n\n6. 复盘总结\n   ├── 分析根因\n   ├── 制定改进措施\n   └── 更新应急预案\n```\n\n### 2. 应急脚本\n\n**服务快速重启脚本**\n```bash\n#!/bin/bash\n# emergency_restart.sh\n\nSERVICE_NAME=$1\nif [ -z \"$SERVICE_NAME\" ]; then\n    echo \"Usage: $0 \u003cservice_name\u003e\"\n    exit 1\nfi\n\necho \"=== 紧急重启服务: $SERVICE_NAME ===\"\n\n# 1. 备份当前状态\necho \"备份服务状态...\"\nsystemctl status $SERVICE_NAME \u003e service_status_$(date +%Y%m%d_%H%M%S).txt\n\n# 2. 停止服务\necho \"停止服务...\"\nsystemctl stop $SERVICE_NAME\n\n# 3. 等待服务完全停止\nsleep 5\n\n# 4. 检查端口是否释放\nPORT=$(netstat -tlnp | grep $SERVICE_NAME | awk '{print $4}' | cut -d: -f2)\nif [ -n \"$PORT\" ]; then\n    echo \"端口 $PORT 仍被占用，强制终止进程...\"\n    pkill -f $SERVICE_NAME\nfi\n\n# 5. 启动服务\necho \"启动服务...\"\nsystemctl start $SERVICE_NAME\n\n# 6. 检查服务状态\necho \"检查服务状态...\"\nsystemctl status $SERVICE_NAME\n\n# 7. 验证服务可用性\necho \"验证服务可用性...\"\nsleep 10\ncurl -f http://localhost:8080/health || echo \"服务健康检查失败\"\n\necho \"=== 重启完成 ===\"\n```\n\n## 总结\n\nJava线上问题排查是一个系统性工程，需要掌握以下关键技能：\n\n1. **工具使用**：熟练使用jstat、jstack、jmap、MAT等工具\n2. **问题分类**：能够快速识别问题类型和影响范围\n3. **分析方法**：掌握科学的分析方法和思路\n4. **经验积累**：通过实际案例积累经验\n5. **预防措施**：建立完善的监控和预防机制\n\n通过系统化的排查方法和工具使用，可以快速定位和解决线上问题，保障系统的稳定运行。"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"children\":[[\"$\",\"$Ld\",null,{\"href\":\"/notes\",\"className\":\"back-button\",\"style\":{\"display\":\"inline-block\",\"background\":\"var(--primary-color)\",\"color\":\"white\",\"border\":\"none\",\"padding\":\"10px 20px\",\"borderRadius\":\"6px\",\"cursor\":\"pointer\",\"marginBottom\":\"20px\",\"textDecoration\":\"none\"},\"children\":[\"← 返回\",\"笔记\",\"列表\"]}],[\"$\",\"article\",null,{\"className\":\"section\",\"children\":[[\"$\",\"header\",null,{\"className\":\"article-header\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"article-title\",\"children\":\"Java项目线上问题排查\"}],[\"$\",\"div\",null,{\"className\":\"article-meta\",\"children\":[\"$\",\"div\",null,{\"className\":\"article-tags\",\"children\":[[\"$\",\"span\",\"Java\",{\"className\":\"tag\",\"children\":\"Java\"}],[\"$\",\"span\",\"线上排查\",{\"className\":\"tag\",\"children\":\"线上排查\"}],[\"$\",\"span\",\"性能调优\",{\"className\":\"tag\",\"children\":\"性能调优\"}],[\"$\",\"span\",\"故障诊断\",{\"className\":\"tag\",\"children\":\"故障诊断\"}],[\"$\",\"span\",\"JVM\",{\"className\":\"tag\",\"children\":\"JVM\"}]]}]}]]}],[\"$\",\"div\",null,{\"className\":\"card markdown-content\",\"children\":[\"$\",\"$Le\",null,{\"content\":\"$f\"}]}]]}]]}]\n"])</script><script>self.__next_f.push([1,"9:[\"$\",\"html\",null,{\"lang\":\"zh-CN\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"link\",null,{\"rel\":\"stylesheet\",\"href\":\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css\"}],[\"$\",\"link\",null,{\"rel\":\"stylesheet\",\"href\":\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css\"}],[\"$\",\"script\",null,{\"src\":\"https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js\"}]]}],[\"$\",\"body\",null,{\"children\":[\"$\",\"div\",null,{\"className\":\"app\",\"children\":[[\"$\",\"$L10\",null,{\"siteConfig\":{\"name\":\"海元\",\"bio\":\"JAVA | AI | WEB3\",\"social\":[{\"name\":\"github\",\"icon\":\"fab fa-github\",\"url\":\"https://github.com/suogongy\"},{\"name\":\"twitter\",\"icon\":\"fab fa-twitter\",\"url\":\"https://twitter.com/suogongy\"},{\"name\":\"email\",\"icon\":\"fas fa-envelope\",\"url\":\"mailto:haiyuan1832@163.com\"}]}}],[\"$\",\"main\",null,{\"className\":\"main-content\",\"children\":[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"Java项目线上问题排查 - Personal GitHub Page\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"详细介绍Java项目在线上环境中常见的问题排查方法、诊断工具和解决方案，包括CPU、内存、线程、网络等方面的故障排查。\"}]]\n3:null\n"])</script></body></html>