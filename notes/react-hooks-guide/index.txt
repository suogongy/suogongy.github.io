3:I[4707,[],""]
6:I[6423,[],""]
4:["category","notes","d"]
5:["slug","react-hooks-guide","d"]
0:["build",[[["",{"children":[["category","notes","d"],{"children":[["slug","react-hooks-guide","d"],{"children":["__PAGE__?{\"category\":\"notes\",\"slug\":\"react-hooks-guide\"}",{}]}]}]},"$undefined","$undefined",true],["",{"children":[["category","notes","d"],{"children":[["slug","react-hooks-guide","d"],{"children":["__PAGE__",{},[["$L1","$L2",null],null],null]},[null,["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","$4","children","$5","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L6",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined"}]],null]},[null,["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","$4","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L6",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined"}]],null]},[[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/55b7a9e84b417e65.css","precedence":"next","crossOrigin":"$undefined"}]],"$L7"],null],null],["$L8",null]]]]
9:I[2972,["972","static/chunks/972-17ea62b17795b286.js","621","static/chunks/app/%5Bcategory%5D/%5Bslug%5D/page-e1b46fcdbbb20f68.js"],""]
b:I[7140,["972","static/chunks/972-17ea62b17795b286.js","185","static/chunks/app/layout-ca71fef930ed4111.js"],"default"]
a:T2d48,<h1>React Hooks 完全指南</h1>
<p>React Hooks 是 React 16.8 引入的新特性，它让我们在不编写类组件的情况下使用 state 和其他 React 特性。</p>
<h2>目录</h2>
<ol>
<li><a href="#hooks-%E7%AE%80%E4%BB%8B">Hooks 简介</a></li>
<li><a href="#%E5%9F%BA%E6%9C%AC-hooks">基本 Hooks</a></li>
<li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89-hooks">自定义 Hooks</a></li>
<li><a href="#hooks-%E8%A7%84%E5%88%99">Hooks 规则</a></li>
<li><a href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5">最佳实践</a></li>
</ol>
<h2>Hooks 简介</h2>
<p>Hooks 是一些可以让你在函数组件里&quot;钩入&quot; React state 及生命周期等特性的函数。Hook 不能在类组件中使用 —— 这使得你不使用 class 也能使用 React。</p>
<h3>为什么需要 Hooks？</h3>
<ol>
<li><strong>组件逻辑复用</strong>：解决了高阶组件和 render props 的嵌套地狱问题</li>
<li><strong>复杂组件理解</strong>：将相关逻辑组织在一起，而不是分散在不同的生命周期方法中</li>
<li><strong>类组件的困惑</strong>：告别 <code>this</code> 指向的困扰</li>
</ol>
<h2>基本 Hooks</h2>
<h3>useState</h3>
<p><code>useState</code> 是最常用的 Hook，用于在函数组件中添加状态。</p>
<pre><code class="language-javascript">import React, { useState } from &#39;react&#39;;

function Counter() {
  // 声明一个新的叫做 &quot;count&quot; 的 state 变量
  const [count, setCount] = useState(0);

  return (
    &lt;div&gt;
      &lt;p&gt;You clicked {count} times&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;
        Click me
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<h4>useState 语法</h4>
<pre><code class="language-javascript">const [state, setState] = useState(initialState);
</code></pre>
<ul>
<li><code>state</code>：当前状态值</li>
<li><code>setState</code>：更新状态的函数</li>
<li><code>initialState</code>：初始状态值</li>
</ul>
<h4>函数式更新</h4>
<p>如果新的 state 需要通过使用先前的 state 计算得出，那么可以传递函数给 <code>setState</code>：</p>
<pre><code class="language-javascript">function Counter() {
  const [count, setCount] = useState(0);

  function handleClick() {
    setCount(prevCount =&gt; prevCount + 1);
  }

  return (
    &lt;button onClick={handleClick}&gt;
      Count: {count}
    &lt;/button&gt;
  );
}
</code></pre>
<h3>useEffect</h3>
<p><code>useEffect</code> Hook 可以让你在函数组件中执行副作用操作。</p>
<pre><code class="language-javascript">import React, { useState, useEffect } from &#39;react&#39;;

function Example() {
  const [count, setCount] = useState(0);

  // 相当于 componentDidMount 和 componentDidUpdate
  useEffect(() =&gt; {
    // 更新文档标题
    document.title = `You clicked ${count} times`;
  }, [count]); // 仅在 count 更改时更新

  return (
    &lt;div&gt;
      &lt;p&gt;You clicked {count} times&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;
        Click me
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<h4>清除副作用</h4>
<p>副作用函数还可以返回一个清除函数：</p>
<pre><code class="language-javascript">useEffect(() =&gt; {
  const subscription = props.source.subscribe();
  return () =&gt; {
    // 清除订阅
    subscription.unsubscribe();
  };
}, [props.source]);
</code></pre>
<h4>常见的使用场景</h4>
<ol>
<li><strong>数据获取</strong>：</li>
</ol>
<pre><code class="language-javascript">useEffect(() =&gt; {
  const fetchData = async () =&gt; {
    const result = await axios(&#39;https://api.example.com/data&#39;);
    setData(result.data);
  };
  
  fetchData();
}, []);
</code></pre>
<ol start="2">
<li><strong>订阅</strong>：</li>
</ol>
<pre><code class="language-javascript">useEffect(() =&gt; {
  const handleScroll = () =&gt; {
    console.log(window.scrollY);
  };
  
  window.addEventListener(&#39;scroll&#39;, handleScroll);
  return () =&gt; window.removeEventListener(&#39;scroll&#39;, handleScroll);
}, []);
</code></pre>
<ol start="3">
<li><strong>定时器</strong>：</li>
</ol>
<pre><code class="language-javascript">useEffect(() =&gt; {
  const timer = setInterval(() =&gt; {
    setTime(new Date());
  }, 1000);
  
  return () =&gt; clearInterval(timer);
}, []);
</code></pre>
<h3>useContext</h3>
<p><code>useContext</code> 可以在组件之间共享状态，而不需要显式地通过组件树逐层传递 props。</p>
<pre><code class="language-javascript">import React, { useContext, createContext } from &#39;react&#39;;

// 创建 Context
const ThemeContext = createContext(&#39;light&#39;);

function App() {
  return (
    &lt;ThemeContext.Provider value=&quot;dark&quot;&gt;
      &lt;Toolbar /&gt;
    &lt;/ThemeContext.Provider&gt;
  );
}

function Toolbar() {
  return (
    &lt;div&gt;
      &lt;ThemedButton /&gt;
    &lt;/div&gt;
  );
}

function ThemedButton() {
  const theme = useContext(ThemeContext);
  return &lt;button style={{ background: theme === &#39;dark&#39; ? &#39;#333&#39; : &#39;#FFF&#39; }}&gt;
    I am a {theme} button
  &lt;/button&gt;;
}
</code></pre>
<h2>自定义 Hooks</h2>
<p>自定义 Hook 是一个函数，其名称以 &quot;use&quot; 开头，函数内部可以调用其他的 Hook。</p>
<h3>创建自定义 Hook</h3>
<pre><code class="language-javascript">import { useState, useEffect } from &#39;react&#39;;

function useCounter(initialValue = 0) {
  const [count, setCount] = useState(initialValue);

  const increment = () =&gt; setCount(count + 1);
  const decrement = () =&gt; setCount(count - 1);
  const reset = () =&gt; setCount(initialValue);

  return { count, increment, decrement, reset };
}

// 使用自定义 Hook
function Counter() {
  const { count, increment, decrement, reset } = useCounter(10);

  return (
    &lt;div&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;
      &lt;button onClick={increment}&gt;+&lt;/button&gt;
      &lt;button onClick={decrement}&gt;-&lt;/button&gt;
      &lt;button onClick={reset}&gt;Reset&lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<h3>实用的自定义 Hook 示例</h3>
<h4>useLocalstorage</h4>
<pre><code class="language-javascript">function useLocalStorage(key, initialValue) {
  const [storedValue, setStoredValue] = useState(() =&gt; {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      return initialValue;
    }
  });

  const setValue = (value) =&gt; {
    try {
      setStoredValue(value);
      window.localStorage.setItem(key, JSON.stringify(value));
    } catch (error) {
      console.error(error);
    }
  };

  return [storedValue, setValue];
}
</code></pre>
<h4>useDebounce</h4>
<pre><code class="language-javascript">function useDebounce(value, delay) {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() =&gt; {
    const handler = setTimeout(() =&gt; {
      setDebouncedValue(value);
    }, delay);

    return () =&gt; {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}
</code></pre>
<h2>Hooks 规则</h2>
<p>使用 Hook 时必须遵循两条规则：</p>
<h3>1. 只在最顶层使用 Hook</h3>
<p>不要在循环、条件或嵌套函数中调用 Hook：</p>
<pre><code class="language-javascript">// ❌ 错误
function BadComponent() {
  if (someCondition) {
    const [count, setCount] = useState(0);
  }
}

// ✅ 正确
function GoodComponent() {
  const [count, setCount] = useState(0);
  
  if (someCondition) {
    // 在条件中使用 state
    return &lt;div&gt;{count}&lt;/div&gt;;
  }
}
</code></pre>
<h3>2. 只在 React 函数中调用 Hook</h3>
<p>不要在普通的 JavaScript 函数中调用 Hook：</p>
<pre><code class="language-javascript">// ❌ 错误
function handleSomething() {
  const [count, setCount] = useState(0);
}

// ✅ 正确
function MyComponent() {
  const [count, setCount] = useState(0);
  
  const handleSomething = () =&gt; {
    // 在事件处理函数中使用 state
    setCount(count + 1);
  };
}
</code></pre>
<h2>最佳实践</h2>
<h3>1. 合理组织 Hooks</h3>
<pre><code class="language-javascript">function UserProfile({ userId }) {
  // 将相关的 hooks 组织在一起
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // 数据获取逻辑
  useEffect(() =&gt; {
    fetchUser(userId)
      .then(setUser)
      .catch(setError)
      .finally(() =&gt; setLoading(false));
  }, [userId]);

  // 其他的 hooks...
  const theme = useContext(ThemeContext);
  
  // ...
}
</code></pre>
<h3>2. 使用自定义 Hook 抽象逻辑</h3>
<pre><code class="language-javascript">// 将数据获取逻辑抽象到自定义 Hook
function useUser(userId) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() =&gt; {
    fetchUser(userId)
      .then(setUser)
      .catch(setError)
      .finally(() =&gt; setLoading(false));
  }, [userId]);

  return { user, loading, error };
}

// 组件变得简洁
function UserProfile({ userId }) {
  const { user, loading, error } = useUser(userId);
  const theme = useContext(ThemeContext);
  
  if (loading) return &lt;Spinner /&gt;;
  if (error) return &lt;ErrorMessage error={error} /&gt;;
  
  return &lt;div&gt;{user.name}&lt;/div&gt;;
}
</code></pre>
<h3>3. 性能优化</h3>
<h4>useMemo</h4>
<pre><code class="language-javascript">function ExpensiveComponent({ items }) {
  const expensiveValue = useMemo(() =&gt; {
    return items.reduce((sum, item) =&gt; sum + item.value, 0);
  }, [items]);

  return &lt;div&gt;Total: {expensiveValue}&lt;/div&gt;;
}
</code></pre>
<h4>useCallback</h4>
<pre><code class="language-javascript">function ParentComponent() {
  const [count, setCount] = useState(0);

  const handleClick = useCallback(() =&gt; {
    console.log(&#39;Button clicked&#39;);
  }, []); // 空依赖数组，函数不会重新创建

  return (
    &lt;div&gt;
      &lt;ChildComponent onClick={handleClick} /&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;
        Count: {count}
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<h3>4. 错误边界和 Hooks</h3>
<pre><code class="language-javascript">function useErrorHandler() {
  const [error, setError] = useState(null);

  const resetError = () =&gt; setError(null);

  useEffect(() =&gt; {
    if (error) {
      throw error;
    }
  }, [error]);

  return setError;
}

// 使用示例
function MyComponent() {
  const setError = useErrorHandler();

  const handleAsyncOperation = async () =&gt; {
    try {
      await riskyOperation();
    } catch (err) {
      setError(err);
    }
  };

  return &lt;button onClick={handleAsyncOperation}&gt;Run Operation&lt;/button&gt;;
}
</code></pre>
<h2>总结</h2>
<p>React Hooks 为函数组件提供了强大的能力，让我们能够：</p>
<ol>
<li><strong>更好地组织代码逻辑</strong></li>
<li><strong>复用组件逻辑</strong></li>
<li><strong>简化组件结构</strong></li>
</ol>
<p>掌握 Hooks 需要理解其工作原理和遵循使用规则。通过合理使用内置 Hooks 和创建自定义 Hooks，我们可以构建更加清晰、可维护的 React 应用。</p>
<p>记住这两个关键点：</p>
<ul>
<li><strong>只在顶层调用 Hook</strong></li>
<li><strong>只在 React 函数中调用 Hook</strong></li>
</ul>
<p>这样就能充分发挥 Hooks 的威力！</p>
2:["$","div",null,{"children":[["$","$L9",null,{"href":"/notes","className":"back-button","style":{"display":"inline-block","background":"var(--primary-color)","color":"white","border":"none","padding":"10px 20px","borderRadius":"6px","cursor":"pointer","marginBottom":"20px","textDecoration":"none"},"children":["← 返回","技术笔记","列表"]}],["$","article",null,{"className":"section","children":[["$","header",null,{"className":"article-header","children":[["$","h1",null,{"className":"article-title","children":"React Hooks 完全指南"}],["$","div",null,{"className":"article-meta","children":[["$","div",null,{"className":"article-meta-info","children":[["$","span",null,{"className":"article-date","children":"2024-01-15"}],["$","span",null,{"className":"article-category","children":["• ","技术笔记"]}]]}],["$","div",null,{"className":"article-tags","children":[["$","span","React",{"className":"tag","children":"React"}],["$","span","JavaScript",{"className":"tag","children":"JavaScript"}],["$","span","前端",{"className":"tag","children":"前端"}]]}]]}]]}],["$","div",null,{"className":"card markdown-content","dangerouslySetInnerHTML":{"__html":"$a"}}]]}]]}]
7:["$","html",null,{"lang":"zh-CN","children":[["$","head",null,{"children":[["$","link",null,{"rel":"stylesheet","href":"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"}],["$","link",null,{"rel":"stylesheet","href":"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css"}]]}],["$","body",null,{"children":["$","div",null,{"className":"app","children":[["$","$Lb",null,{"siteConfig":{"name":"Rudy Yang","bio":"JAVA | AI | WEB3","social":[{"name":"github","icon":"fab fa-github","url":"https://github.com/suogongy"},{"name":"twitter","icon":"fab fa-twitter","url":"https://twitter.com/suogongy"},{"name":"email","icon":"fas fa-envelope","url":"mailto:haiyuan1832@163.com"}]}}],["$","main",null,{"className":"main-content","children":["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L6",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":"404"}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],"notFoundStyles":[]}]}]]}]}]]}]
8:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"React Hooks 完全指南 - Personal GitHub Page"}],["$","meta","3",{"name":"description","content":"全面掌握 React Hooks 的核心概念、使用方法和高级技巧"}]]
1:null
