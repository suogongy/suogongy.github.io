3:I[4707,[],""]
6:I[6423,[],""]
4:["category","notes","d"]
5:["slug","jvm-evolution-from5-to21","d"]
0:["build",[[["",{"children":[["category","notes","d"],{"children":[["slug","jvm-evolution-from5-to21","d"],{"children":["__PAGE__?{\"category\":\"notes\",\"slug\":\"jvm-evolution-from5-to21\"}",{}]}]}]},"$undefined","$undefined",true],["",{"children":[["category","notes","d"],{"children":[["slug","jvm-evolution-from5-to21","d"],{"children":["__PAGE__",{},[["$L1","$L2",null],null],null]},[null,["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","$4","children","$5","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L6",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined"}]],null]},[null,["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","$4","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L6",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined"}]],null]},[[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/eb4a34bff42c1814.css","precedence":"next","crossOrigin":"$undefined"}]],"$L7"],null],null],["$L8",null]]]]
9:I[2972,["972","static/chunks/972-81dbad6abe39d3fa.js","832","static/chunks/832-7ea2624e20755f9f.js","621","static/chunks/app/%5Bcategory%5D/%5Bslug%5D/page-e466df95e55c7602.js"],""]
a:I[2024,["972","static/chunks/972-81dbad6abe39d3fa.js","832","static/chunks/832-7ea2624e20755f9f.js","621","static/chunks/app/%5Bcategory%5D/%5Bslug%5D/page-e466df95e55c7602.js"],"default"]
c:I[7140,["972","static/chunks/972-81dbad6abe39d3fa.js","185","static/chunks/app/layout-3ed2f387fb22aa2c.js"],"default"]
b:T2d7d,
# JVM的发展之路，从5到21

> Java虚拟机的演进历程，是Java技术持续创新和性能提升的重要见证

## 引言

Java虚拟机（JVM）是Java技术的核心，它为Java程序提供了跨平台的能力。从Java 5到Java 21，JVM在性能、内存管理、垃圾回收、编译优化等方面都取得了巨大的进步。本文将详细介绍JVM在这一时期的重要发展和变化。

## Java 5 (Tiger, 2004年) - 里程碑式的改进

### 1. 垃圾回收器改进

**CMS垃圾回收器**
- 引入了CMS（Concurrent Mark Sweep）收集器
- 以获取最短回收停顿时间为目标
- 标记-清除算法，支持并发标记和并发清除
- 适用于对响应时间有要求的场景

**内存模型改进**
- 完善了Java内存模型（JMM）
- 引入了happens-before原则
- 提供了更好的并发编程支持
- 增强了volatile和synchronized的语义

### 2. 编译器优化

**逃逸分析**
- 引入逃逸分析技术
- 优化对象分配和同步
- 支持标量替换和栈上分配
- 提升了程序执行效率

**循环优化**
- 改进了循环优化技术
- 支持循环展开和循环不变量外提
- 提升了数值计算的性能

### 3. 监控和诊断

**JMX improvements**
- 增强了JMX监控能力
- 提供了更丰富的运行时信息
- 支持更细粒度的监控和管理

**代码示例**：
```java
// Java 5中的泛型和并发编程示例
import java.util.concurrent.*;
import java.util.*;

public class Java5Features {
    private Map<String, List<Integer>> genericMap = new HashMap<>();
    
    public void demonstrateConcurrency() {
        // 使用线程池和并发集合
        ExecutorService executor = Executors.newFixedThreadPool(4);
        BlockingQueue<String> queue = new LinkedBlockingQueue<>();
        
        // 提交任务
        Future<String> future = executor.submit(() -> {
            return "Task completed";
        });
    }
}
```

## Java 6 (Mustang, 2006年) - 性能优化年

### 1. 垃圾回收优化

**Parallel Old GC**
- 引入Parallel Old收集器
- 支持老年代的并行回收
- 提升了多核环境下的回收效率
- 适合吞吐量优先的应用

**内存管理改进**
- 优化了内存分配策略
- 改进了TLAB（Thread Local Allocation Buffer）
- 提升了多线程内存分配性能

### 2. 编译器升级

**JIT编译优化**
- 改进了即时编译器
- 支持更多的编译优化技术
- 提升了热点代码的执行效率
- 增强了分层编译能力

### 3. 监控工具

**VisualVM**
- 集成了多种监控工具
- 提供了可视化的性能分析
- 支持内存、CPU、线程等多维度监控
- 简化了性能调优工作

**配置示例**：
```bash
# Java 6 JVM调优参数示例
-Xms2g -Xmx4g  # 堆内存设置
-XX:+UseParallelGC  # 使用并行垃圾回收器
-XX:+PrintGCDetails  # 打印GC详细信息
-XX:+HeapDumpOnOutOfMemoryError  # OOM时生成堆转储
```

## Java 7 (Dolphin, 2011年) - 功能增强

### 1. 垃圾回收器改进

**G1垃圾回收器**
- 引入G1（Garbage First）收集器
- 基于区域的内存布局
- 支持可预测的停顿时间
- 适合大内存应用

**JVM启动优化**
- 改进了JVM启动性能
- 优化了类加载过程
- 减少了启动时间和内存占用

### 2. 动态语言支持

**InvokeDynamic**
- 引入 invokedynamic 指令
- 支持动态语言在JVM上运行
- 提升了动态语言的执行效率
- 为JVM生态系统扩展奠定基础

### 3. 压缩指针

**Compressed Oops**
- 引入压缩普通对象指针
- 在64位系统上节省内存
- 提升了内存利用效率
- 减少了GC压力

**G1配置示例**：
```bash
# G1垃圾回收器配置
-XX:+UseG1GC  # 启用G1收集器
-XX:MaxGCPauseMillis=200  # 最大GC停顿时间
-XX:G1HeapRegionSize=16m  # G1区域大小
-XX:G1NewSizePercent=30  # 新生代比例
```

## Java 8 (Spider, 2014年) - 里程碑式更新

### 1. Metaspace取代PermGen

**永久代移除**
- 移除了永久代（PermGen）
- 引入Metaspace（元空间）
- 使用本地内存存储类元数据
- 解决了永久代的内存溢出问题

**内存管理改进**
- 自动调整Metaspace大小
- 支持更灵活的内存管理
- 减少了内存相关的配置

### 2. Lambda表达式支持

**函数式编程**
- 支持Lambda表达式
- 引入函数式接口
- 提升了代码的简洁性和可读性
- 为Stream API奠定基础

**性能优化**
- 优化了Lambda表达式的执行
- 引入 invokedynamic 指令优化
- 提升了函数式编程的性能

### 3. 并发增强

**CompletableFuture**
- 引入CompletableFuture类
- 支持异步编程的新模式
- 提供了更强大的异步组合能力
- 简化了并发编程

**代码示例**：
```java
// Java 8新特性示例
import java.util.stream.*;
import java.util.concurrent.CompletableFuture;
import java.util.*;

public class Java8Features {
    
    public void demonstrateStreams() {
        List<String> list = Arrays.asList("a", "b", "c", "d");
        
        // Stream API使用
        List<String> result = list.stream()
            .filter(s -> s.startsWith("a"))
            .map(String::toUpperCase)
            .collect(Collectors.toList());
    }
    
    public void demonstrateAsync() {
        // CompletableFuture异步编程
        CompletableFuture<String> future = CompletableFuture
            .supplyAsync(() -> "Hello")
            .thenApply(s -> s + " World")
            .thenAccept(System.out::println);
    }
}
```

## Java 9-11 - 模块化和持续优化

### 1. Java 9 (2017年)

**模块化系统**
- 引入Jigsaw模块系统
- 提供了更好的封装性
- 减少了内存占用
- 提升了启动性能

**G1默认GC**
- G1成为默认垃圾回收器
- 改进了G1的性能和稳定性
- 提供了更好的GC日志

**JShell**
- 引入Java REPL工具
- 支持交互式编程
- 简化了Java学习和测试

### 2. Java 10 (2018年)

**局部变量类型推断**
- 引入var关键字
- 支持局部变量类型推断
- 提升了代码的简洁性
- 保持了类型安全

**性能优化**
- 改进了G1垃圾回收器
- 优化了JIT编译
- 提升了容器环境的性能

### 3. Java 11 (2018年) - LTS版本

**ZGC引入**
- 引入ZGC（Z Garbage Collector）
- 支持TB级堆内存
- 停顿时间控制在毫秒级
- 适合大内存、低延迟应用

**HTTP Client**
- 标准化HTTP Client API
- 支持HTTP/2和WebSocket
- 提供了现代化的HTTP编程接口

**性能提升**
- 进一步优化了G1收集器
- 改进了字符串操作性能
- 增强了JIT编译优化

**ZGC配置示例**：
```bash
# ZGC配置参数
-XX:+UseZGC  # 启用ZGC收集器
-XX:+UnlockExperimentalVMOptions  # 解锁实验性选项
-Xms4g -Xmx4g  # 堆内存设置
-XX:ZAllocationSpikeTolerance=5  # 分配峰值容忍度
```

## Java 12-17 - 新特性持续涌现

### 1. Java 12 (2019年)

**Shenandoah GC**
- 引入Shenandoah收集器
- 支持并发垃圾回收
- 提供更短的停顿时间
- 适合低延迟应用

**JVM常量API**
- 引入JVM常量API
- 提供了更好的字节码操作能力
- 支持动态语言实现

### 2. Java 13-17的重要改进

**记录类型（Records）**
- Java 14引入记录类型
- 简化了数据载体类的编写
- 提供了不可变性保证
- 减少了样板代码

**模式匹配**
- 引入模式匹配特性
- 简化了instanceof操作
- 增强了代码可读性
- 逐步完善中

**密封类（Sealed Classes）**
- Java 17引入密封类
- 提供了更好的继承控制
- 增强了类型系统的表达能力
- 支持更精确的建模

**代码示例**：
```java
// Java 14+ 新特性示例
public record Point(int x, int y) {}  // 记录类型

// 模式匹配示例
if (obj instanceof String s) {
    System.out.println(s.toUpperCase());
}

// 密封类示例
public sealed interface Shape 
    permits Circle, Rectangle, Triangle {}
    
final class Circle implements Shape {
    private final double radius;
}
```

## Java 21 (2023年) - 最新LTS版本

### 1. 虚拟线程（Virtual Threads）

**Project Loom**
- 引入虚拟线程技术
- 轻量级线程实现
- 大幅提升并发编程能力
- 支持百万级并发连接

**性能优势**
- 减少了线程创建和切换开销
- 提升了I/O密集型应用性能
- 简化了并发编程模型
- 更好的资源利用率

### 2. 分代ZGC

**Generational ZGC**
- 引入分代ZGC
- 支持分代垃圾回收
- 提升了垃圾回收效率
- 减少了GC停顿时间

### 3. 向量API（第四轮孵化）

**Vector API**
- 提供了向量计算能力
- 支持SIMD指令优化
- 提升了数值计算性能
- 适合科学计算应用

**虚拟线程示例**：
```java
// Java 21虚拟线程示例
import java.util.concurrent.*;
import java.util.stream.*;

public class VirtualThreads {
    
    public void demonstrateVirtualThreads() {
        // 创建虚拟线程
        try (ExecutorService executor = Executors.newVirtualThreadPerTaskExecutor()) {
            
            // 提交大量任务
            List<Future<String>> futures = IntStream.range(0, 1_000_000)
                .mapToObj(i -> executor.submit(() -> {
                    Thread.sleep(Duration.ofMillis(10));
                    return "Task " + i + " completed";
                }))
                .toList();
                
            // 等待所有任务完成
            futures.forEach(future -> {
                try {
                    future.get();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            });
        }
    }
}
```

## JVM性能调优最佳实践

### 1. 内存配置

**堆内存设置**
```bash
# 基础内存配置
-Xms4g -Xmx4g  # 初始和最大堆内存
-XX:NewRatio=2  # 新生代与老年代比例
-XX:SurvivorRatio=8  # Eden与Survivor比例
```

**元空间配置**
```bash
# Metaspace配置
-XX:MetaspaceSize=256m  # 初始元空间大小
-XX:MaxMetaspaceSize=512m  # 最大元空间大小
```

### 2. 垃圾回收选择

**不同场景的GC选择**
```bash
# 吞吐量优先 - Parallel GC
-XX:+UseParallelGC

# 低延迟优先 - G1 GC
-XX:+UseG1GC -XX:MaxGCPauseMillis=200

# 超低延迟 - ZGC
-XX:+UseZGC -Xmx8g

# 极低延迟 - Shenandoah GC
-XX:+UseShenandoahGC
```

### 3. 监控和诊断

**JVM监控参数**
```bash
# GC日志配置
-XX:+PrintGCDetails
-XX:+PrintGCDateStamps
-XX:+PrintGCTimeStamps
-Xloggc:/path/to/gc.log

# OOM处理
-XX:+HeapDumpOnOutOfMemoryError
-XX:HeapDumpPath=/path/to/dump.hprof
```

### 4. 性能优化建议

**代码优化**
- 减少对象创建和内存分配
- 使用对象池和缓存机制
- 避免内存泄漏和资源浪费
- 合理使用集合类和数据结构

**并发优化**
- 合理使用线程池和并发工具
- 避免过度同步和锁竞争
- 利用无锁数据结构和算法
- 考虑使用虚拟线程提升并发性能

## 总结

从Java 5到Java 21，JVM经历了巨大的发展和变化。主要改进包括：

1. **垃圾回收技术**：从简单的Serial GC到先进的ZGC和Shenandoah，停顿时间从秒级降低到毫秒级
2. **内存管理**：从永久代到元空间，从压缩指针到更高效的内存布局
3. **编译优化**：JIT编译器不断优化，支持更多的编译技术和优化策略
4. **并发支持**：从基础的synchronized到虚拟线程，并发编程能力大幅提升
5. **监控诊断**：从基础的JMX到丰富的监控工具和诊断能力

这些改进使得Java在现代应用场景中保持了强大的竞争力，无论是传统企业应用还是云原生应用，都能找到合适的JVM配置和优化方案。随着Java技术的持续发展，JVM将继续演进，为开发者提供更好的性能和更丰富的功能。2:["$","div",null,{"children":[["$","$L9",null,{"href":"/notes","className":"back-button","style":{"display":"inline-block","background":"var(--primary-color)","color":"white","border":"none","padding":"10px 20px","borderRadius":"6px","cursor":"pointer","marginBottom":"20px","textDecoration":"none"},"children":["← 返回","笔记","列表"]}],["$","article",null,{"className":"section","children":[["$","header",null,{"className":"article-header","children":[["$","h1",null,{"className":"article-title","children":"JVM的发展之路，从5到21"}],["$","div",null,{"className":"article-meta","children":[["$","div",null,{"className":"article-meta-info","children":[["$","span",null,{"className":"article-date","children":"2024-10-14"}],["$","span",null,{"className":"article-category","children":["• ","笔记"]}]]}],["$","div",null,{"className":"article-tags","children":[["$","span","JVM",{"className":"tag","children":"JVM"}],["$","span","Java",{"className":"tag","children":"Java"}],["$","span","虚拟机",{"className":"tag","children":"虚拟机"}],["$","span","性能优化",{"className":"tag","children":"性能优化"}],["$","span","垃圾回收",{"className":"tag","children":"垃圾回收"}]]}]]}]]}],["$","div",null,{"className":"card markdown-content","children":["$","$La",null,{"content":"$b"}]}]]}]]}]
7:["$","html",null,{"lang":"zh-CN","children":[["$","head",null,{"children":[["$","link",null,{"rel":"stylesheet","href":"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"}],["$","link",null,{"rel":"stylesheet","href":"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css"}],["$","script",null,{"src":"https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"}]]}],["$","body",null,{"children":["$","div",null,{"className":"app","children":[["$","$Lc",null,{"siteConfig":{"name":"Rudy Yang","bio":"JAVA | AI | WEB3","social":[{"name":"github","icon":"fab fa-github","url":"https://github.com/suogongy"},{"name":"twitter","icon":"fab fa-twitter","url":"https://twitter.com/suogongy"},{"name":"email","icon":"fas fa-envelope","url":"mailto:haiyuan1832@163.com"}]}}],["$","main",null,{"className":"main-content","children":["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L6",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":"404"}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],"notFoundStyles":[]}]}]]}]}]]}]
8:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"JVM的发展之路，从5到21 - Personal GitHub Page"}],["$","meta","3",{"name":"description","content":"Java虚拟机(JVM)作为Java技术的核心，从Java 5到Java 21经历了巨大的发展和变化。本文详细介绍JVM的重要演进历程、关键特性改进和性能优化。"}]]
1:null
