<!DOCTYPE html><html lang="zh-CN"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/7b42d4e858e38c6b.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-c81f7fd28659d64f.js"/><script src="/_next/static/chunks/fd9d1056-e3d373074663785d.js" async=""></script><script src="/_next/static/chunks/117-86f31d03f8df68a5.js" async=""></script><script src="/_next/static/chunks/main-app-1bdc7b9537d0c130.js" async=""></script><script src="/_next/static/chunks/972-81dbad6abe39d3fa.js" async=""></script><script src="/_next/static/chunks/832-2b131d9fe9982edb.js" async=""></script><script src="/_next/static/chunks/app/%5Bcategory%5D/%5Bslug%5D/page-eb51aa11033a73a2.js" async=""></script><script src="/_next/static/chunks/app/layout-f3fa7e3100be56de.js" async=""></script><script src="https://cdn.jsdelivr.net/npm/mermaid@10.9.1/dist/mermaid.min.js" async=""></script><title>JVM的发展之路，从5到21 - Personal GitHub Page</title><meta name="description" content="Java虚拟机(JVM)作为Java技术的核心，从Java 5到Java 21经历了巨大的发展和变化。本文详细介绍JVM的重要演进历程、关键特性改进和性能优化。"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css"/><script src="https://unpkg.com/markmap-autoloader@0.17.2"></script><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body><div class="app"><header class="header "><nav class="nav-container"><a class="nav-brand" href="/"><i class="fas fa-terminal"></i>海元</a><ul class="nav-menu "><li><a class="nav-link " href="/"><i class="fas fa-home"></i> 首页</a></li><li><a class="nav-link " href="/about/"><i class="fas fa-user"></i> 关于</a></li><li><a class="nav-link " href="/projects/"><i class="fas fa-code"></i> 项目</a></li><li><a class="nav-link " href="/notes/"><i class="fas fa-book"></i> 笔记</a></li><li><a class="nav-link " href="/articles/"><i class="fas fa-pen"></i> 随笔</a></li></ul></nav></header><main class="main-content"><div><a class="back-button" style="display:inline-block;background:var(--primary-color);color:white;border:none;padding:10px 20px;border-radius:6px;cursor:pointer;margin-bottom:20px;text-decoration:none" href="/notes/">← 返回<!-- -->笔记<!-- -->列表</a><article class="section"><header class="article-header"><h1 class="article-title">JVM的发展之路，从5到21</h1><div class="article-meta"><div class="article-tags"><span class="tag">JVM</span><span class="tag">Java</span><span class="tag">虚拟机</span><span class="tag">性能优化</span><span class="tag">垃圾回收</span></div></div></header><div class="card markdown-content"><div class="markdown-content"><div><h1>JVM的发展之路，从5到21</h1>
<blockquote>
<p>Java虚拟机的演进历程，是Java技术持续创新和性能提升的重要见证</p>
</blockquote>
<h2>引言</h2>
<p>Java虚拟机（JVM）是Java技术的核心，它为Java程序提供了跨平台的能力。从Java 5到Java 21，JVM在性能、内存管理、垃圾回收、编译优化等方面都取得了巨大的进步。本文将详细介绍JVM在这一时期的重要发展和变化。</p>
<h2>Java 5 (Tiger, 2004年) - 里程碑式的改进</h2>
<h3>1. 垃圾回收器改进</h3>
<p><strong>CMS垃圾回收器</strong></p>
<ul>
<li>引入了CMS（Concurrent Mark Sweep）收集器</li>
<li>以获取最短回收停顿时间为目标</li>
<li>标记-清除算法，支持并发标记和并发清除</li>
<li>适用于对响应时间有要求的场景</li>
</ul>
<p><strong>内存模型改进</strong></p>
<ul>
<li>完善了Java内存模型（JMM）</li>
<li>引入了happens-before原则</li>
<li>提供了更好的并发编程支持</li>
<li>增强了volatile和synchronized的语义</li>
</ul>
<h3>2. 编译器优化</h3>
<p><strong>逃逸分析</strong></p>
<ul>
<li>引入逃逸分析技术</li>
<li>优化对象分配和同步</li>
<li>支持标量替换和栈上分配</li>
<li>提升了程序执行效率</li>
</ul>
<p><strong>循环优化</strong></p>
<ul>
<li>改进了循环优化技术</li>
<li>支持循环展开和循环不变量外提</li>
<li>提升了数值计算的性能</li>
</ul>
<h3>3. 监控和诊断</h3>
<p><strong>JMX improvements</strong></p>
<ul>
<li>增强了JMX监控能力</li>
<li>提供了更丰富的运行时信息</li>
<li>支持更细粒度的监控和管理</li>
</ul>
<p><strong>代码示例</strong>：</p>
<pre><code class="language-java">// Java 5中的泛型和并发编程示例
import java.util.concurrent.*;
import java.util.*;

public class Java5Features {
    private Map&lt;String, List&lt;Integer&gt;&gt; genericMap = new HashMap&lt;&gt;();
    
    public void demonstrateConcurrency() {
        // 使用线程池和并发集合
        ExecutorService executor = Executors.newFixedThreadPool(4);
        BlockingQueue&lt;String&gt; queue = new LinkedBlockingQueue&lt;&gt;();
        
        // 提交任务
        Future&lt;String&gt; future = executor.submit(() -&gt; {
            return &quot;Task completed&quot;;
        });
    }
}
</code></pre>
<h2>Java 6 (Mustang, 2006年) - 性能优化年</h2>
<h3>1. 垃圾回收优化</h3>
<p><strong>Parallel Old GC</strong></p>
<ul>
<li>引入Parallel Old收集器</li>
<li>支持老年代的并行回收</li>
<li>提升了多核环境下的回收效率</li>
<li>适合吞吐量优先的应用</li>
</ul>
<p><strong>内存管理改进</strong></p>
<ul>
<li>优化了内存分配策略</li>
<li>改进了TLAB（Thread Local Allocation Buffer）</li>
<li>提升了多线程内存分配性能</li>
</ul>
<h3>2. 编译器升级</h3>
<p><strong>JIT编译优化</strong></p>
<ul>
<li>改进了即时编译器</li>
<li>支持更多的编译优化技术</li>
<li>提升了热点代码的执行效率</li>
<li>增强了分层编译能力</li>
</ul>
<h3>3. 监控工具</h3>
<p><strong>VisualVM</strong></p>
<ul>
<li>集成了多种监控工具</li>
<li>提供了可视化的性能分析</li>
<li>支持内存、CPU、线程等多维度监控</li>
<li>简化了性能调优工作</li>
</ul>
<p><strong>配置示例</strong>：</p>
<pre><code class="language-bash"># Java 6 JVM调优参数示例
-Xms2g -Xmx4g  # 堆内存设置
-XX:+UseParallelGC  # 使用并行垃圾回收器
-XX:+PrintGCDetails  # 打印GC详细信息
-XX:+HeapDumpOnOutOfMemoryError  # OOM时生成堆转储
</code></pre>
<h2>Java 7 (Dolphin, 2011年) - 功能增强</h2>
<h3>1. 垃圾回收器改进</h3>
<p><strong>G1垃圾回收器</strong></p>
<ul>
<li>引入G1（Garbage First）收集器</li>
<li>基于区域的内存布局</li>
<li>支持可预测的停顿时间</li>
<li>适合大内存应用</li>
</ul>
<p><strong>JVM启动优化</strong></p>
<ul>
<li>改进了JVM启动性能</li>
<li>优化了类加载过程</li>
<li>减少了启动时间和内存占用</li>
</ul>
<h3>2. 动态语言支持</h3>
<p><strong>InvokeDynamic</strong></p>
<ul>
<li>引入 invokedynamic 指令</li>
<li>支持动态语言在JVM上运行</li>
<li>提升了动态语言的执行效率</li>
<li>为JVM生态系统扩展奠定基础</li>
</ul>
<h3>3. 压缩指针</h3>
<p><strong>Compressed Oops</strong></p>
<ul>
<li>引入压缩普通对象指针</li>
<li>在64位系统上节省内存</li>
<li>提升了内存利用效率</li>
<li>减少了GC压力</li>
</ul>
<p><strong>G1配置示例</strong>：</p>
<pre><code class="language-bash"># G1垃圾回收器配置
-XX:+UseG1GC  # 启用G1收集器
-XX:MaxGCPauseMillis=200  # 最大GC停顿时间
-XX:G1HeapRegionSize=16m  # G1区域大小
-XX:G1NewSizePercent=30  # 新生代比例
</code></pre>
<h2>Java 8 (Spider, 2014年) - 里程碑式更新</h2>
<h3>1. Metaspace取代PermGen</h3>
<p><strong>永久代移除</strong></p>
<ul>
<li>移除了永久代（PermGen）</li>
<li>引入Metaspace（元空间）</li>
<li>使用本地内存存储类元数据</li>
<li>解决了永久代的内存溢出问题</li>
</ul>
<p><strong>内存管理改进</strong></p>
<ul>
<li>自动调整Metaspace大小</li>
<li>支持更灵活的内存管理</li>
<li>减少了内存相关的配置</li>
</ul>
<h3>2. Lambda表达式支持</h3>
<p><strong>函数式编程</strong></p>
<ul>
<li>支持Lambda表达式</li>
<li>引入函数式接口</li>
<li>提升了代码的简洁性和可读性</li>
<li>为Stream API奠定基础</li>
</ul>
<p><strong>性能优化</strong></p>
<ul>
<li>优化了Lambda表达式的执行</li>
<li>引入 invokedynamic 指令优化</li>
<li>提升了函数式编程的性能</li>
</ul>
<h3>3. 并发增强</h3>
<p><strong>CompletableFuture</strong></p>
<ul>
<li>引入CompletableFuture类</li>
<li>支持异步编程的新模式</li>
<li>提供了更强大的异步组合能力</li>
<li>简化了并发编程</li>
</ul>
<p><strong>代码示例</strong>：</p>
<pre><code class="language-java">// Java 8新特性示例
import java.util.stream.*;
import java.util.concurrent.CompletableFuture;
import java.util.*;

public class Java8Features {
    
    public void demonstrateStreams() {
        List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;);
        
        // Stream API使用
        List&lt;String&gt; result = list.stream()
            .filter(s -&gt; s.startsWith(&quot;a&quot;))
            .map(String::toUpperCase)
            .collect(Collectors.toList());
    }
    
    public void demonstrateAsync() {
        // CompletableFuture异步编程
        CompletableFuture&lt;String&gt; future = CompletableFuture
            .supplyAsync(() -&gt; &quot;Hello&quot;)
            .thenApply(s -&gt; s + &quot; World&quot;)
            .thenAccept(System.out::println);
    }
}
</code></pre>
<h2>Java 9-11 - 模块化和持续优化</h2>
<h3>1. Java 9 (2017年)</h3>
<p><strong>模块化系统</strong></p>
<ul>
<li>引入Jigsaw模块系统</li>
<li>提供了更好的封装性</li>
<li>减少了内存占用</li>
<li>提升了启动性能</li>
</ul>
<p><strong>G1默认GC</strong></p>
<ul>
<li>G1成为默认垃圾回收器</li>
<li>改进了G1的性能和稳定性</li>
<li>提供了更好的GC日志</li>
</ul>
<p><strong>JShell</strong></p>
<ul>
<li>引入Java REPL工具</li>
<li>支持交互式编程</li>
<li>简化了Java学习和测试</li>
</ul>
<h3>2. Java 10 (2018年)</h3>
<p><strong>局部变量类型推断</strong></p>
<ul>
<li>引入var关键字</li>
<li>支持局部变量类型推断</li>
<li>提升了代码的简洁性</li>
<li>保持了类型安全</li>
</ul>
<p><strong>性能优化</strong></p>
<ul>
<li>改进了G1垃圾回收器</li>
<li>优化了JIT编译</li>
<li>提升了容器环境的性能</li>
</ul>
<h3>3. Java 11 (2018年) - LTS版本</h3>
<p><strong>ZGC引入</strong></p>
<ul>
<li>引入ZGC（Z Garbage Collector）</li>
<li>支持TB级堆内存</li>
<li>停顿时间控制在毫秒级</li>
<li>适合大内存、低延迟应用</li>
</ul>
<p><strong>HTTP Client</strong></p>
<ul>
<li>标准化HTTP Client API</li>
<li>支持HTTP/2和WebSocket</li>
<li>提供了现代化的HTTP编程接口</li>
</ul>
<p><strong>性能提升</strong></p>
<ul>
<li>进一步优化了G1收集器</li>
<li>改进了字符串操作性能</li>
<li>增强了JIT编译优化</li>
</ul>
<p><strong>ZGC配置示例</strong>：</p>
<pre><code class="language-bash"># ZGC配置参数
-XX:+UseZGC  # 启用ZGC收集器
-XX:+UnlockExperimentalVMOptions  # 解锁实验性选项
-Xms4g -Xmx4g  # 堆内存设置
-XX:ZAllocationSpikeTolerance=5  # 分配峰值容忍度
</code></pre>
<h2>Java 12-17 - 新特性持续涌现</h2>
<h3>1. Java 12 (2019年)</h3>
<p><strong>Shenandoah GC</strong></p>
<ul>
<li>引入Shenandoah收集器</li>
<li>支持并发垃圾回收</li>
<li>提供更短的停顿时间</li>
<li>适合低延迟应用</li>
</ul>
<p><strong>JVM常量API</strong></p>
<ul>
<li>引入JVM常量API</li>
<li>提供了更好的字节码操作能力</li>
<li>支持动态语言实现</li>
</ul>
<h3>2. Java 13-17的重要改进</h3>
<p><strong>记录类型（Records）</strong></p>
<ul>
<li>Java 14引入记录类型</li>
<li>简化了数据载体类的编写</li>
<li>提供了不可变性保证</li>
<li>减少了样板代码</li>
</ul>
<p><strong>模式匹配</strong></p>
<ul>
<li>引入模式匹配特性</li>
<li>简化了instanceof操作</li>
<li>增强了代码可读性</li>
<li>逐步完善中</li>
</ul>
<p><strong>密封类（Sealed Classes）</strong></p>
<ul>
<li>Java 17引入密封类</li>
<li>提供了更好的继承控制</li>
<li>增强了类型系统的表达能力</li>
<li>支持更精确的建模</li>
</ul>
<p><strong>代码示例</strong>：</p>
<pre><code class="language-java">// Java 14+ 新特性示例
public record Point(int x, int y) {}  // 记录类型

// 模式匹配示例
if (obj instanceof String s) {
    System.out.println(s.toUpperCase());
}

// 密封类示例
public sealed interface Shape 
    permits Circle, Rectangle, Triangle {}
    
final class Circle implements Shape {
    private final double radius;
}
</code></pre>
<h2>Java 21 (2023年) - 最新LTS版本</h2>
<h3>1. 虚拟线程（Virtual Threads）</h3>
<p><strong>Project Loom</strong></p>
<ul>
<li>引入虚拟线程技术</li>
<li>轻量级线程实现</li>
<li>大幅提升并发编程能力</li>
<li>支持百万级并发连接</li>
</ul>
<p><strong>性能优势</strong></p>
<ul>
<li>减少了线程创建和切换开销</li>
<li>提升了I/O密集型应用性能</li>
<li>简化了并发编程模型</li>
<li>更好的资源利用率</li>
</ul>
<h3>2. 分代ZGC</h3>
<p><strong>Generational ZGC</strong></p>
<ul>
<li>引入分代ZGC</li>
<li>支持分代垃圾回收</li>
<li>提升了垃圾回收效率</li>
<li>减少了GC停顿时间</li>
</ul>
<h3>3. 向量API（第四轮孵化）</h3>
<p><strong>Vector API</strong></p>
<ul>
<li>提供了向量计算能力</li>
<li>支持SIMD指令优化</li>
<li>提升了数值计算性能</li>
<li>适合科学计算应用</li>
</ul>
<p><strong>虚拟线程示例</strong>：</p>
<pre><code class="language-java">// Java 21虚拟线程示例
import java.util.concurrent.*;
import java.util.stream.*;

public class VirtualThreads {
    
    public void demonstrateVirtualThreads() {
        // 创建虚拟线程
        try (ExecutorService executor = Executors.newVirtualThreadPerTaskExecutor()) {
            
            // 提交大量任务
            List&lt;Future&lt;String&gt;&gt; futures = IntStream.range(0, 1_000_000)
                .mapToObj(i -&gt; executor.submit(() -&gt; {
                    Thread.sleep(Duration.ofMillis(10));
                    return &quot;Task &quot; + i + &quot; completed&quot;;
                }))
                .toList();
                
            // 等待所有任务完成
            futures.forEach(future -&gt; {
                try {
                    future.get();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            });
        }
    }
}
</code></pre>
<h2>JVM性能调优最佳实践</h2>
<h3>1. 内存配置</h3>
<p><strong>堆内存设置</strong></p>
<pre><code class="language-bash"># 基础内存配置
-Xms4g -Xmx4g  # 初始和最大堆内存
-XX:NewRatio=2  # 新生代与老年代比例
-XX:SurvivorRatio=8  # Eden与Survivor比例
</code></pre>
<p><strong>元空间配置</strong></p>
<pre><code class="language-bash"># Metaspace配置
-XX:MetaspaceSize=256m  # 初始元空间大小
-XX:MaxMetaspaceSize=512m  # 最大元空间大小
</code></pre>
<h3>2. 垃圾回收选择</h3>
<p><strong>不同场景的GC选择</strong></p>
<pre><code class="language-bash"># 吞吐量优先 - Parallel GC
-XX:+UseParallelGC

# 低延迟优先 - G1 GC
-XX:+UseG1GC -XX:MaxGCPauseMillis=200

# 超低延迟 - ZGC
-XX:+UseZGC -Xmx8g

# 极低延迟 - Shenandoah GC
-XX:+UseShenandoahGC
</code></pre>
<h3>3. 监控和诊断</h3>
<p><strong>JVM监控参数</strong></p>
<pre><code class="language-bash"># GC日志配置
-XX:+PrintGCDetails
-XX:+PrintGCDateStamps
-XX:+PrintGCTimeStamps
-Xloggc:/path/to/gc.log

# OOM处理
-XX:+HeapDumpOnOutOfMemoryError
-XX:HeapDumpPath=/path/to/dump.hprof
</code></pre>
<h3>4. 性能优化建议</h3>
<p><strong>代码优化</strong></p>
<ul>
<li>减少对象创建和内存分配</li>
<li>使用对象池和缓存机制</li>
<li>避免内存泄漏和资源浪费</li>
<li>合理使用集合类和数据结构</li>
</ul>
<p><strong>并发优化</strong></p>
<ul>
<li>合理使用线程池和并发工具</li>
<li>避免过度同步和锁竞争</li>
<li>利用无锁数据结构和算法</li>
<li>考虑使用虚拟线程提升并发性能</li>
</ul>
<h2>总结</h2>
<p>从Java 5到Java 21，JVM经历了巨大的发展和变化。主要改进包括：</p>
<ol>
<li><strong>垃圾回收技术</strong>：从简单的Serial GC到先进的ZGC和Shenandoah，停顿时间从秒级降低到毫秒级</li>
<li><strong>内存管理</strong>：从永久代到元空间，从压缩指针到更高效的内存布局</li>
<li><strong>编译优化</strong>：JIT编译器不断优化，支持更多的编译技术和优化策略</li>
<li><strong>并发支持</strong>：从基础的synchronized到虚拟线程，并发编程能力大幅提升</li>
<li><strong>监控诊断</strong>：从基础的JMX到丰富的监控工具和诊断能力</li>
</ol>
<p>这些改进使得Java在现代应用场景中保持了强大的竞争力，无论是传统企业应用还是云原生应用，都能找到合适的JVM配置和优化方案。随着Java技术的持续发展，JVM将继续演进，为开发者提供更好的性能和更丰富的功能。</p>
</div></div></div></article></div></main></div><script src="/_next/static/chunks/webpack-c81f7fd28659d64f.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/7b42d4e858e38c6b.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"2:I[2846,[],\"\"]\n5:I[4707,[],\"\"]\n8:I[6423,[],\"\"]\nb:I[1060,[],\"\"]\n6:[\"category\",\"notes\",\"d\"]\n7:[\"slug\",\"jvm-evolution-from5-to21\",\"d\"]\nc:[]\n0:[\"$\",\"$L2\",null,{\"buildId\":\"build\",\"assetPrefix\":\"\",\"urlParts\":[\"\",\"notes\",\"jvm-evolution-from5-to21\",\"\"],\"initialTree\":[\"\",{\"children\":[[\"category\",\"notes\",\"d\"],{\"children\":[[\"slug\",\"jvm-evolution-from5-to21\",\"d\"],{\"children\":[\"__PAGE__?{\\\"category\\\":\\\"notes\\\",\\\"slug\\\":\\\"jvm-evolution-from5-to21\\\"}\",{}]}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"category\",\"notes\",\"d\"],{\"children\":[[\"slug\",\"jvm-evolution-from5-to21\",\"d\"],{\"children\":[\"__PAGE__\",{},[[\"$L3\",\"$L4\",null],null],null]},[null,[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$6\",\"children\",\"$7\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}]],null]},[null,[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$6\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}]],null]},[[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/7b42d4e858e38c6b.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],\"$L9\"],null],null],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$La\"],\"globalErrorComponent\":\"$b\",\"missingSlots\":\"$Wc\"}]\n"])</script><script>self.__next_f.push([1,"d:I[2972,[\"972\",\"static/chunks/972-81dbad6abe39d3fa.js\",\"832\",\"static/chunks/832-2b131d9fe9982edb.js\",\"621\",\"static/chunks/app/%5Bcategory%5D/%5Bslug%5D/page-eb51aa11033a73a2.js\"],\"\"]\ne:I[5546,[\"972\",\"static/chunks/972-81dbad6abe39d3fa.js\",\"832\",\"static/chunks/832-2b131d9fe9982edb.js\",\"621\",\"static/chunks/app/%5Bcategory%5D/%5Bslug%5D/page-eb51aa11033a73a2.js\"],\"default\"]\n10:I[7140,[\"972\",\"static/chunks/972-81dbad6abe39d3fa.js\",\"185\",\"static/chunks/app/layout-f3fa7e3100be56de.js\"],\"default\"]\nf:T2d7d,"])</script><script>self.__next_f.push([1,"\n# JVM的发展之路，从5到21\n\n\u003e Java虚拟机的演进历程，是Java技术持续创新和性能提升的重要见证\n\n## 引言\n\nJava虚拟机（JVM）是Java技术的核心，它为Java程序提供了跨平台的能力。从Java 5到Java 21，JVM在性能、内存管理、垃圾回收、编译优化等方面都取得了巨大的进步。本文将详细介绍JVM在这一时期的重要发展和变化。\n\n## Java 5 (Tiger, 2004年) - 里程碑式的改进\n\n### 1. 垃圾回收器改进\n\n**CMS垃圾回收器**\n- 引入了CMS（Concurrent Mark Sweep）收集器\n- 以获取最短回收停顿时间为目标\n- 标记-清除算法，支持并发标记和并发清除\n- 适用于对响应时间有要求的场景\n\n**内存模型改进**\n- 完善了Java内存模型（JMM）\n- 引入了happens-before原则\n- 提供了更好的并发编程支持\n- 增强了volatile和synchronized的语义\n\n### 2. 编译器优化\n\n**逃逸分析**\n- 引入逃逸分析技术\n- 优化对象分配和同步\n- 支持标量替换和栈上分配\n- 提升了程序执行效率\n\n**循环优化**\n- 改进了循环优化技术\n- 支持循环展开和循环不变量外提\n- 提升了数值计算的性能\n\n### 3. 监控和诊断\n\n**JMX improvements**\n- 增强了JMX监控能力\n- 提供了更丰富的运行时信息\n- 支持更细粒度的监控和管理\n\n**代码示例**：\n```java\n// Java 5中的泛型和并发编程示例\nimport java.util.concurrent.*;\nimport java.util.*;\n\npublic class Java5Features {\n    private Map\u003cString, List\u003cInteger\u003e\u003e genericMap = new HashMap\u003c\u003e();\n    \n    public void demonstrateConcurrency() {\n        // 使用线程池和并发集合\n        ExecutorService executor = Executors.newFixedThreadPool(4);\n        BlockingQueue\u003cString\u003e queue = new LinkedBlockingQueue\u003c\u003e();\n        \n        // 提交任务\n        Future\u003cString\u003e future = executor.submit(() -\u003e {\n            return \"Task completed\";\n        });\n    }\n}\n```\n\n## Java 6 (Mustang, 2006年) - 性能优化年\n\n### 1. 垃圾回收优化\n\n**Parallel Old GC**\n- 引入Parallel Old收集器\n- 支持老年代的并行回收\n- 提升了多核环境下的回收效率\n- 适合吞吐量优先的应用\n\n**内存管理改进**\n- 优化了内存分配策略\n- 改进了TLAB（Thread Local Allocation Buffer）\n- 提升了多线程内存分配性能\n\n### 2. 编译器升级\n\n**JIT编译优化**\n- 改进了即时编译器\n- 支持更多的编译优化技术\n- 提升了热点代码的执行效率\n- 增强了分层编译能力\n\n### 3. 监控工具\n\n**VisualVM**\n- 集成了多种监控工具\n- 提供了可视化的性能分析\n- 支持内存、CPU、线程等多维度监控\n- 简化了性能调优工作\n\n**配置示例**：\n```bash\n# Java 6 JVM调优参数示例\n-Xms2g -Xmx4g  # 堆内存设置\n-XX:+UseParallelGC  # 使用并行垃圾回收器\n-XX:+PrintGCDetails  # 打印GC详细信息\n-XX:+HeapDumpOnOutOfMemoryError  # OOM时生成堆转储\n```\n\n## Java 7 (Dolphin, 2011年) - 功能增强\n\n### 1. 垃圾回收器改进\n\n**G1垃圾回收器**\n- 引入G1（Garbage First）收集器\n- 基于区域的内存布局\n- 支持可预测的停顿时间\n- 适合大内存应用\n\n**JVM启动优化**\n- 改进了JVM启动性能\n- 优化了类加载过程\n- 减少了启动时间和内存占用\n\n### 2. 动态语言支持\n\n**InvokeDynamic**\n- 引入 invokedynamic 指令\n- 支持动态语言在JVM上运行\n- 提升了动态语言的执行效率\n- 为JVM生态系统扩展奠定基础\n\n### 3. 压缩指针\n\n**Compressed Oops**\n- 引入压缩普通对象指针\n- 在64位系统上节省内存\n- 提升了内存利用效率\n- 减少了GC压力\n\n**G1配置示例**：\n```bash\n# G1垃圾回收器配置\n-XX:+UseG1GC  # 启用G1收集器\n-XX:MaxGCPauseMillis=200  # 最大GC停顿时间\n-XX:G1HeapRegionSize=16m  # G1区域大小\n-XX:G1NewSizePercent=30  # 新生代比例\n```\n\n## Java 8 (Spider, 2014年) - 里程碑式更新\n\n### 1. Metaspace取代PermGen\n\n**永久代移除**\n- 移除了永久代（PermGen）\n- 引入Metaspace（元空间）\n- 使用本地内存存储类元数据\n- 解决了永久代的内存溢出问题\n\n**内存管理改进**\n- 自动调整Metaspace大小\n- 支持更灵活的内存管理\n- 减少了内存相关的配置\n\n### 2. Lambda表达式支持\n\n**函数式编程**\n- 支持Lambda表达式\n- 引入函数式接口\n- 提升了代码的简洁性和可读性\n- 为Stream API奠定基础\n\n**性能优化**\n- 优化了Lambda表达式的执行\n- 引入 invokedynamic 指令优化\n- 提升了函数式编程的性能\n\n### 3. 并发增强\n\n**CompletableFuture**\n- 引入CompletableFuture类\n- 支持异步编程的新模式\n- 提供了更强大的异步组合能力\n- 简化了并发编程\n\n**代码示例**：\n```java\n// Java 8新特性示例\nimport java.util.stream.*;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.*;\n\npublic class Java8Features {\n    \n    public void demonstrateStreams() {\n        List\u003cString\u003e list = Arrays.asList(\"a\", \"b\", \"c\", \"d\");\n        \n        // Stream API使用\n        List\u003cString\u003e result = list.stream()\n            .filter(s -\u003e s.startsWith(\"a\"))\n            .map(String::toUpperCase)\n            .collect(Collectors.toList());\n    }\n    \n    public void demonstrateAsync() {\n        // CompletableFuture异步编程\n        CompletableFuture\u003cString\u003e future = CompletableFuture\n            .supplyAsync(() -\u003e \"Hello\")\n            .thenApply(s -\u003e s + \" World\")\n            .thenAccept(System.out::println);\n    }\n}\n```\n\n## Java 9-11 - 模块化和持续优化\n\n### 1. Java 9 (2017年)\n\n**模块化系统**\n- 引入Jigsaw模块系统\n- 提供了更好的封装性\n- 减少了内存占用\n- 提升了启动性能\n\n**G1默认GC**\n- G1成为默认垃圾回收器\n- 改进了G1的性能和稳定性\n- 提供了更好的GC日志\n\n**JShell**\n- 引入Java REPL工具\n- 支持交互式编程\n- 简化了Java学习和测试\n\n### 2. Java 10 (2018年)\n\n**局部变量类型推断**\n- 引入var关键字\n- 支持局部变量类型推断\n- 提升了代码的简洁性\n- 保持了类型安全\n\n**性能优化**\n- 改进了G1垃圾回收器\n- 优化了JIT编译\n- 提升了容器环境的性能\n\n### 3. Java 11 (2018年) - LTS版本\n\n**ZGC引入**\n- 引入ZGC（Z Garbage Collector）\n- 支持TB级堆内存\n- 停顿时间控制在毫秒级\n- 适合大内存、低延迟应用\n\n**HTTP Client**\n- 标准化HTTP Client API\n- 支持HTTP/2和WebSocket\n- 提供了现代化的HTTP编程接口\n\n**性能提升**\n- 进一步优化了G1收集器\n- 改进了字符串操作性能\n- 增强了JIT编译优化\n\n**ZGC配置示例**：\n```bash\n# ZGC配置参数\n-XX:+UseZGC  # 启用ZGC收集器\n-XX:+UnlockExperimentalVMOptions  # 解锁实验性选项\n-Xms4g -Xmx4g  # 堆内存设置\n-XX:ZAllocationSpikeTolerance=5  # 分配峰值容忍度\n```\n\n## Java 12-17 - 新特性持续涌现\n\n### 1. Java 12 (2019年)\n\n**Shenandoah GC**\n- 引入Shenandoah收集器\n- 支持并发垃圾回收\n- 提供更短的停顿时间\n- 适合低延迟应用\n\n**JVM常量API**\n- 引入JVM常量API\n- 提供了更好的字节码操作能力\n- 支持动态语言实现\n\n### 2. Java 13-17的重要改进\n\n**记录类型（Records）**\n- Java 14引入记录类型\n- 简化了数据载体类的编写\n- 提供了不可变性保证\n- 减少了样板代码\n\n**模式匹配**\n- 引入模式匹配特性\n- 简化了instanceof操作\n- 增强了代码可读性\n- 逐步完善中\n\n**密封类（Sealed Classes）**\n- Java 17引入密封类\n- 提供了更好的继承控制\n- 增强了类型系统的表达能力\n- 支持更精确的建模\n\n**代码示例**：\n```java\n// Java 14+ 新特性示例\npublic record Point(int x, int y) {}  // 记录类型\n\n// 模式匹配示例\nif (obj instanceof String s) {\n    System.out.println(s.toUpperCase());\n}\n\n// 密封类示例\npublic sealed interface Shape \n    permits Circle, Rectangle, Triangle {}\n    \nfinal class Circle implements Shape {\n    private final double radius;\n}\n```\n\n## Java 21 (2023年) - 最新LTS版本\n\n### 1. 虚拟线程（Virtual Threads）\n\n**Project Loom**\n- 引入虚拟线程技术\n- 轻量级线程实现\n- 大幅提升并发编程能力\n- 支持百万级并发连接\n\n**性能优势**\n- 减少了线程创建和切换开销\n- 提升了I/O密集型应用性能\n- 简化了并发编程模型\n- 更好的资源利用率\n\n### 2. 分代ZGC\n\n**Generational ZGC**\n- 引入分代ZGC\n- 支持分代垃圾回收\n- 提升了垃圾回收效率\n- 减少了GC停顿时间\n\n### 3. 向量API（第四轮孵化）\n\n**Vector API**\n- 提供了向量计算能力\n- 支持SIMD指令优化\n- 提升了数值计算性能\n- 适合科学计算应用\n\n**虚拟线程示例**：\n```java\n// Java 21虚拟线程示例\nimport java.util.concurrent.*;\nimport java.util.stream.*;\n\npublic class VirtualThreads {\n    \n    public void demonstrateVirtualThreads() {\n        // 创建虚拟线程\n        try (ExecutorService executor = Executors.newVirtualThreadPerTaskExecutor()) {\n            \n            // 提交大量任务\n            List\u003cFuture\u003cString\u003e\u003e futures = IntStream.range(0, 1_000_000)\n                .mapToObj(i -\u003e executor.submit(() -\u003e {\n                    Thread.sleep(Duration.ofMillis(10));\n                    return \"Task \" + i + \" completed\";\n                }))\n                .toList();\n                \n            // 等待所有任务完成\n            futures.forEach(future -\u003e {\n                try {\n                    future.get();\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            });\n        }\n    }\n}\n```\n\n## JVM性能调优最佳实践\n\n### 1. 内存配置\n\n**堆内存设置**\n```bash\n# 基础内存配置\n-Xms4g -Xmx4g  # 初始和最大堆内存\n-XX:NewRatio=2  # 新生代与老年代比例\n-XX:SurvivorRatio=8  # Eden与Survivor比例\n```\n\n**元空间配置**\n```bash\n# Metaspace配置\n-XX:MetaspaceSize=256m  # 初始元空间大小\n-XX:MaxMetaspaceSize=512m  # 最大元空间大小\n```\n\n### 2. 垃圾回收选择\n\n**不同场景的GC选择**\n```bash\n# 吞吐量优先 - Parallel GC\n-XX:+UseParallelGC\n\n# 低延迟优先 - G1 GC\n-XX:+UseG1GC -XX:MaxGCPauseMillis=200\n\n# 超低延迟 - ZGC\n-XX:+UseZGC -Xmx8g\n\n# 极低延迟 - Shenandoah GC\n-XX:+UseShenandoahGC\n```\n\n### 3. 监控和诊断\n\n**JVM监控参数**\n```bash\n# GC日志配置\n-XX:+PrintGCDetails\n-XX:+PrintGCDateStamps\n-XX:+PrintGCTimeStamps\n-Xloggc:/path/to/gc.log\n\n# OOM处理\n-XX:+HeapDumpOnOutOfMemoryError\n-XX:HeapDumpPath=/path/to/dump.hprof\n```\n\n### 4. 性能优化建议\n\n**代码优化**\n- 减少对象创建和内存分配\n- 使用对象池和缓存机制\n- 避免内存泄漏和资源浪费\n- 合理使用集合类和数据结构\n\n**并发优化**\n- 合理使用线程池和并发工具\n- 避免过度同步和锁竞争\n- 利用无锁数据结构和算法\n- 考虑使用虚拟线程提升并发性能\n\n## 总结\n\n从Java 5到Java 21，JVM经历了巨大的发展和变化。主要改进包括：\n\n1. **垃圾回收技术**：从简单的Serial GC到先进的ZGC和Shenandoah，停顿时间从秒级降低到毫秒级\n2. **内存管理**：从永久代到元空间，从压缩指针到更高效的内存布局\n3. **编译优化**：JIT编译器不断优化，支持更多的编译技术和优化策略\n4. **并发支持**：从基础的synchronized到虚拟线程，并发编程能力大幅提升\n5. **监控诊断**：从基础的JMX到丰富的监控工具和诊断能力\n\n这些改进使得Java在现代应用场景中保持了强大的竞争力，无论是传统企业应用还是云原生应用，都能找到合适的JVM配置和优化方案。随着Java技术的持续发展，JVM将继续演进，为开发者提供更好的性能和更丰富的功能。"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"children\":[[\"$\",\"$Ld\",null,{\"href\":\"/notes\",\"className\":\"back-button\",\"style\":{\"display\":\"inline-block\",\"background\":\"var(--primary-color)\",\"color\":\"white\",\"border\":\"none\",\"padding\":\"10px 20px\",\"borderRadius\":\"6px\",\"cursor\":\"pointer\",\"marginBottom\":\"20px\",\"textDecoration\":\"none\"},\"children\":[\"← 返回\",\"笔记\",\"列表\"]}],[\"$\",\"article\",null,{\"className\":\"section\",\"children\":[[\"$\",\"header\",null,{\"className\":\"article-header\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"article-title\",\"children\":\"JVM的发展之路，从5到21\"}],[\"$\",\"div\",null,{\"className\":\"article-meta\",\"children\":[\"$\",\"div\",null,{\"className\":\"article-tags\",\"children\":[[\"$\",\"span\",\"JVM\",{\"className\":\"tag\",\"children\":\"JVM\"}],[\"$\",\"span\",\"Java\",{\"className\":\"tag\",\"children\":\"Java\"}],[\"$\",\"span\",\"虚拟机\",{\"className\":\"tag\",\"children\":\"虚拟机\"}],[\"$\",\"span\",\"性能优化\",{\"className\":\"tag\",\"children\":\"性能优化\"}],[\"$\",\"span\",\"垃圾回收\",{\"className\":\"tag\",\"children\":\"垃圾回收\"}]]}]}]]}],[\"$\",\"div\",null,{\"className\":\"card markdown-content\",\"children\":[\"$\",\"$Le\",null,{\"content\":\"$f\"}]}]]}]]}]\n"])</script><script>self.__next_f.push([1,"9:[\"$\",\"html\",null,{\"lang\":\"zh-CN\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"link\",null,{\"rel\":\"stylesheet\",\"href\":\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css\"}],[\"$\",\"link\",null,{\"rel\":\"stylesheet\",\"href\":\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css\"}],[\"$\",\"script\",null,{\"src\":\"https://cdn.jsdelivr.net/npm/mermaid@10.9.1/dist/mermaid.min.js\",\"async\":true}],[\"$\",\"script\",null,{\"src\":\"https://unpkg.com/markmap-autoloader@0.17.2\"}]]}],[\"$\",\"body\",null,{\"children\":[\"$\",\"div\",null,{\"className\":\"app\",\"children\":[[\"$\",\"$L10\",null,{\"siteConfig\":{\"name\":\"海元\",\"bio\":\"JAVA | AI | WEB3\",\"social\":[{\"name\":\"github\",\"icon\":\"fab fa-github\",\"url\":\"https://github.com/suogongy\"},{\"name\":\"twitter\",\"icon\":\"fab fa-twitter\",\"url\":\"https://twitter.com/suogongy\"},{\"name\":\"email\",\"icon\":\"fas fa-envelope\",\"url\":\"mailto:haiyuan1832@163.com\"}]}}],[\"$\",\"main\",null,{\"className\":\"main-content\",\"children\":[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"JVM的发展之路，从5到21 - Personal GitHub Page\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"Java虚拟机(JVM)作为Java技术的核心，从Java 5到Java 21经历了巨大的发展和变化。本文详细介绍JVM的重要演进历程、关键特性改进和性能优化。\"}]]\n3:null\n"])</script></body></html>