<!DOCTYPE html><html lang="zh-CN"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/7b42d4e858e38c6b.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-c81f7fd28659d64f.js"/><script src="/_next/static/chunks/fd9d1056-e3d373074663785d.js" async=""></script><script src="/_next/static/chunks/117-86f31d03f8df68a5.js" async=""></script><script src="/_next/static/chunks/main-app-1bdc7b9537d0c130.js" async=""></script><script src="/_next/static/chunks/972-81dbad6abe39d3fa.js" async=""></script><script src="/_next/static/chunks/832-2b131d9fe9982edb.js" async=""></script><script src="/_next/static/chunks/app/%5Bcategory%5D/%5Bslug%5D/page-eb51aa11033a73a2.js" async=""></script><script src="/_next/static/chunks/app/layout-f3fa7e3100be56de.js" async=""></script><script src="https://cdn.jsdelivr.net/npm/mermaid@10.9.1/dist/mermaid.min.js" async=""></script><title>Redis内部数据结构详解 - Personal GitHub Page</title><meta name="description" content="深入剖析Redis内部数据结构的实现原理，包括简单动态字符串、链表、字典、跳跃表、整数集合、压缩列表等核心数据结构的详细解析。"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css"/><script src="https://unpkg.com/markmap-autoloader@0.17.2"></script><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body><div class="app"><header class="header "><nav class="nav-container"><a class="nav-brand" href="/"><i class="fas fa-terminal"></i>海元</a><ul class="nav-menu "><li><a class="nav-link " href="/"><i class="fas fa-home"></i> 首页</a></li><li><a class="nav-link " href="/about/"><i class="fas fa-user"></i> 关于</a></li><li><a class="nav-link " href="/projects/"><i class="fas fa-code"></i> 项目</a></li><li><a class="nav-link " href="/notes/"><i class="fas fa-book"></i> 笔记</a></li><li><a class="nav-link " href="/articles/"><i class="fas fa-pen"></i> 随笔</a></li></ul></nav></header><main class="main-content"><div><a class="back-button" style="display:inline-block;background:var(--primary-color);color:white;border:none;padding:10px 20px;border-radius:6px;cursor:pointer;margin-bottom:20px;text-decoration:none" href="/notes/">← 返回<!-- -->笔记<!-- -->列表</a><article class="section"><header class="article-header"><h1 class="article-title">Redis内部数据结构详解</h1><div class="article-meta"><div class="article-tags"><span class="tag">Redis</span><span class="tag">数据结构</span><span class="tag">源码分析</span><span class="tag">算法</span><span class="tag">底层实现</span></div></div></header><div class="card markdown-content"><div class="markdown-content"><div><h1>Redis内部数据结构详解</h1>
<blockquote>
<p>理解Redis内部数据结构是掌握Redis性能优化的关键</p>
</blockquote>
<h2>引言</h2>
<p>Redis的高性能很大程度上得益于其精心设计的数据结构。Redis不仅提供了丰富的外部数据类型（String、List、Hash、Set、Sorted Set），其内部还使用了多种高效的数据结构来支撑这些外部类型。本文将深入分析Redis内部数据结构的实现原理。</p>
<h2>Redis数据结构概览</h2>
<h3>1. 数据结构层次</h3>
<p><strong>外部数据类型</strong>：</p>
<ul>
<li>String：字符串类型</li>
<li>List：列表类型</li>
<li>Hash：哈希表类型</li>
<li>Set：集合类型</li>
<li>Sorted Set：有序集合类型</li>
</ul>
<p><strong>内部数据结构</strong>：</p>
<ul>
<li>SDS（Simple Dynamic String）：简单动态字符串</li>
<li>LinkedList：双向链表</li>
<li>Dict：字典（哈希表）</li>
<li>SkipList：跳跃表</li>
<li>IntSet：整数集合</li>
<li>ZipList：压缩列表</li>
<li>QuickList：快速列表</li>
</ul>
<h3>2. 数据结构映射关系</h3>
<pre><code>String  -&gt; SDS
List    -&gt; LinkedList / ZipList / QuickList
Hash    -&gt; Dict / ZipList
Set     -&gt; Dict / IntSet
Sorted Set -&gt; SkipList + Dict / ZipList
</code></pre>
<h2>SDS（简单动态字符串）</h2>
<h3>1. SDS结构定义</h3>
<pre><code class="language-c">// sds.h
struct __attribute__ ((__packed__)) sdshdr8 {
    uint8_t len;        // 已使用长度
    uint8_t alloc;      // 总容量
    unsigned char flags; // 标志位，用于标识sdshdr类型
    char buf[];         // 字符数组
};

struct __attribute__ ((__packed__)) sdshdr16 {
    uint16_t len;       // 已使用长度
    uint16_t alloc;     // 总容量
    unsigned char flags; // 标志位
    char buf[];         // 字符数组
};

struct __attribute__ ((__packed__)) sdshdr32 {
    uint32_t len;       // 已使用长度
    uint32_t alloc;     // 总容量
    unsigned char flags; // 标志位
    char buf[];         // 字符数组
};

struct __attribute__ ((__packed__)) sdshdr64 {
    uint64_t len;       // 已使用长度
    uint64_t alloc;     // 总容量
    unsigned char flags; // 标志位
    char buf[];         // 字符数组
};
</code></pre>
<h3>2. SDS设计原理详解</h3>
<p><strong>为什么Redis需要自定义字符串结构？</strong></p>
<p>传统的C字符串存在诸多问题，这些问题在高性能的键值数据库中会被放大：</p>
<ol>
<li><strong>获取长度效率低下</strong>：C字符串以&#39;\0&#39;结尾，每次获取长度都需要遍历整个字符串，时间复杂度为O(n)</li>
<li><strong>缓冲区溢出风险</strong>：字符串拼接操作时，如果预先分配的空间不足，容易导致缓冲区溢出</li>
<li><strong>内存重分配频繁</strong>：每次字符串增长或缩短都可能涉及内存重新分配，影响性能</li>
<li><strong>不支持二进制数据</strong>：C字符串无法存储包含&#39;\0&#39;字符的二进制数据</li>
</ol>
<p><strong>SDS的核心设计思想</strong></p>
<p>SDS通过以下设计解决了上述问题：</p>
<ul>
<li><strong>长度信息存储</strong>：在头部维护len字段，实现O(1)时间复杂度的长度获取</li>
<li><strong>空间预分配策略</strong>：避免频繁的内存重分配，提升性能</li>
<li><strong>惰性空间释放</strong>：缩短字符串时不立即释放内存，为后续增长预留空间</li>
<li><strong>多级长度编码</strong>：根据字符串长度选择合适的头部结构，节省内存</li>
</ul>
<p><strong>内存布局优化</strong></p>
<p>SDS使用了5种不同的头部结构（sdshdr5、sdshdr8、sdshdr16、sdshdr32、sdshdr64），这种设计的巧妙之处在于：</p>
<ul>
<li><strong>小字符串优化</strong>：短字符串使用较小的头部结构，减少内存开销</li>
<li><strong>大字符串支持</strong>：长字符串使用较大的头部结构，支持更大的容量</li>
<li><strong>标志位机制</strong>：通过flags字段快速识别头部类型，提升处理效率</li>
</ul>
<h3>3. SDS特性分析</h3>
<p><strong>空间预分配策略详解</strong>：</p>
<pre><code class="language-c">// sds.c
sds sdsMakeRoomFor(sds s, size_t addlen) {
    struct sdshdr *sh, *newsh;
    size_t free = sdsavail(s);
    size_t len, newlen;

    if (free &gt;= addlen) return s;

    len = sdslen(s);
    sh = (void*)(s - (sizeof(struct sdshdr)));
    newlen = (len + addlen);

    // 空间预分配策略
    if (newlen &lt; SDS_MAX_PREALLOC)
        newlen *= 2;
    else
        newlen += SDS_MAX_PREALLOC;

    newsh = zrealloc(sh, sizeof(struct sdshdr) + newlen + 1);
    if (newsh == NULL) return NULL;

    newsh-&gt;free = newlen - len;
    return newsh-&gt;buf;
}
</code></pre>
<p><strong>预分配策略的智能之处</strong>：</p>
<p>这段代码体现了Redis在内存分配上的深思熟虑：</p>
<ol>
<li><p><strong>双重增长策略</strong>：</p>
<ul>
<li>当新长度小于1MB时，直接翻倍（<code>newlen *= 2</code>）</li>
<li>当新长度超过1MB时，额外增加1MB（<code>newlen += SDS_MAX_PREALLOC</code>）</li>
</ul>
</li>
<li><p><strong>性能平衡</strong>：</p>
<ul>
<li>小字符串翻倍增长，确保在频繁操作时仍有良好性能</li>
<li>大字符串线性增长，避免内存浪费</li>
</ul>
</li>
<li><p><strong>实际效果</strong>：</p>
<ul>
<li>N次字符串增长操作最多触发O(log N)次内存重分配</li>
<li>相比每次都重分配，性能提升显著</li>
</ul>
</li>
</ol>
<p><strong>惰性空间释放的巧妙设计</strong>：</p>
<pre><code class="language-c">sds sdstrim(sds s, const char *cset) {
    struct sdshdr *sh = (void*)(s - (sizeof(struct sdshdr)));
    char *start, *end, *sp, *ep;
    size_t len;

    sp = s;
    ep = s + sdslen(s) - 1;
    start = sp;
    end = ep;

    // 跳过前置空白字符
    while(sp &lt;= end &amp;&amp; strchr(cset, *sp)) sp++;

    // 跳过后置空白字符
    while(ep &gt; start &amp;&amp; strchr(cset, *ep)) ep--;

    len = (sp &gt; ep) ? 0 : ((ep - sp) + 1);

    // 移动字符串，但保留空间
    if (sh-&gt;buf != sp) memmove(sh-&gt;buf, sp, len);
    sh-&gt;buf[len] = &#39;\0&#39;;
    sh-&gt;free = sh-&gt;alloc - len;
    sh-&gt;len = len;

    return s;
}
</code></pre>
<p><strong>惰性释放的原理和优势</strong>：</p>
<ol>
<li><p><strong>延迟释放机制</strong>：</p>
<ul>
<li>字符串缩短时不立即归还内存给操作系统</li>
<li>而是更新free字段，记录可用空间大小</li>
<li>为后续可能的字符串增长操作预留空间</li>
</ul>
</li>
<li><p><strong>性能优化效果</strong>：</p>
<ul>
<li>避免了&quot;缩短-增长&quot;操作模式下的内存重分配</li>
<li>在Redis中，很多场景下字符串会在缩短后再次增长</li>
<li>显著减少了系统调用malloc/free的频率</li>
</ul>
</li>
<li><p><strong>内存管理策略</strong>：</p>
<ul>
<li>通过free字段精确跟踪可用空间</li>
<li>在真正需要释放内存时，可以通过专门的API进行</li>
<li>平衡了内存使用效率和性能</li>
</ul>
</li>
</ol>
<h3>3. SDS与C字符串对比</h3>
<p><strong>优势对比</strong>：</p>
<div class="table-wrapper"><table style="width: auto;">
<thead>
<tr>
<th>特性</th>
<th>C字符串</th>
<th>SDS</th>
</tr>
</thead>
<tbody><tr>
<td>获取长度</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>避免缓冲区溢出</td>
<td>容易溢出</td>
<td>自动检查扩容</td>
</tr>
<tr>
<td>减少内存重分配次数</td>
<td>每次修改都重分配</td>
<td>预分配和惰性释放</td>
</tr>
<tr>
<td>二进制安全</td>
<td>不支持</td>
<td>支持</td>
</tr>
</tbody></table></div>
<h2>Dict（字典/哈希表）</h2>
<h3>1. 字典结构定义</h3>
<pre><code class="language-c">// dict.h
typedef struct dictEntry {
    void *key;              // 键
    union {
        void *val;          // 值
        uint64_t u64;       // uint64_t值
        int64_t s64;        // int64_t值
        double d;           // double值
    } v;
    struct dictEntry *next; // 下一个节点，用于解决哈希冲突
} dictEntry;

typedef struct dictType {
    uint64_t (*hashFunction)(const void *key);  // 哈希函数
    void *(*keyDup)(void *privdata, const void *key); // 键复制函数
    void *(*valDup)(void *privdata, const void *obj); // 值复制函数
    int (*keyCompare)(void *privdata, const void *key1, const void *key2); // 键比较函数
    void (*keyDestructor)(void *privdata, void *key); // 键销毁函数
    void (*valDestructor)(void *privdata, void *obj); // 值销毁函数
} dictType;

typedef struct dictht {
    dictEntry **table;      // 哈希表数组
    unsigned long size;     // 哈希表大小
    unsigned long sizemask; // 哈希表大小掩码，用于计算索引
    unsigned long used;     // 已有节点数量
} dictht;

typedef struct dict {
    dictType *type;         // 字典类型
    void *privdata;         // 私有数据
    dictht ht[2];           // 两个哈希表，用于rehash
    long rehashidx;         // rehash进度，-1表示不在rehash
    int iterators;          // 迭代器数量
} dict;
</code></pre>
<h3>2. 哈希表设计原理</h3>
<p><strong>Redis字典的核心设计思想</strong></p>
<p>Redis字典是一个典型的哈希表实现，但其设计中有几个关键的创新点：</p>
<ol>
<li><p><strong>双重哈希表机制</strong>：</p>
<ul>
<li>维护两个哈希表ht[0]和ht[1]</li>
<li>平时只使用ht[0]，ht[1]在rehash时使用</li>
<li>这种设计支持渐进式rehash，避免一次性迁移的性能问题</li>
</ul>
</li>
<li><p><strong>链地址法解决冲突</strong>：</p>
<ul>
<li>每个哈希桶维护一个链表</li>
<li>发生冲突时，新节点插入到链表头部</li>
<li>简单高效，且支持动态扩容</li>
</ul>
</li>
<li><p><strong>动态扩容策略</strong>：</p>
<ul>
<li>当负载因子超过阈值时自动扩容</li>
<li>扩容时哈希表大小通常翻倍到最近的2的幂次</li>
<li>保证良好的哈希分布</li>
</ul>
</li>
</ol>
<p><strong>哈希冲突的处理策略</strong></p>
<pre><code class="language-c">// 插入新节点时的冲突处理逻辑
dictEntry *dictAddRaw(dict *d, void *key, dictEntry **existing) {
    int index;
    dictEntry *entry;
    dictht *ht;

    // 计算索引位置
    if ((index = _dictKeyIndex(d, key, dictHashKey(d,key), existing)) == -1)
        return NULL;

    // 选择哈希表（rehash期间可能使用ht[1]）
    ht = dictIsRehashing(d) ? &amp;d-&gt;ht[1] : &amp;d-&gt;ht[0];
    entry = zmalloc(sizeof(*entry));

    // 使用头插法处理冲突
    entry-&gt;next = ht-&gt;table[index];
    ht-&gt;table[index] = entry;
    ht-&gt;used++;

    // 设置键
    dictSetKey(d, entry, key);
    return entry;
}
</code></pre>
<h3>3. 哈希算法与冲突解决</h3>
<pre><code class="language-c">// dict.c
// MurmurHash2哈希算法
uint64_t dictGenHashFunction(const void *key, int len) {
    uint64_t seed = 5381;
    const uint64_t m = 0xc6a4a7935bd1e995;
    const int r = 47;
    uint64_t h = seed ^ (len * m);
    const uint64_t *data = (const uint64_t *)key;
    const uint64_t *end = data + (len/8);

    while(data != end) {
        uint64_t k = *data++;
        k *= m;
        k ^= k &gt;&gt; r;
        k *= m;
        h ^= k;
        h *= m;
    }

    switch(len &amp; 7) {
        case 7: h ^= ((uint64_t)data[6]) &lt;&lt; 48;
        case 6: h ^= ((uint64_t)data[5]) &lt;&lt; 40;
        case 5: h ^= ((uint64_t)data[4]) &lt;&lt; 32;
        case 4: h ^= ((uint64_t)data[3]) &lt;&lt; 24;
        case 3: h ^= ((uint64_t)data[2]) &lt;&lt; 16;
        case 2: h ^= ((uint64_t)data[1]) &lt;&lt; 8;
        case 1: h ^= ((uint64_t)data[0]);
                h *= m;
    }

    h ^= h &gt;&gt; r;
    h *= m;
    h ^= h &gt;&gt; r;
    return h;
}

// 计算索引值
static unsigned int dictKeyIndex(dict *d, const void *key) {
    unsigned int h, idx, table;
    dictEntry *he;

    // 计算哈希值
    h = dictHashKey(d, key);

    // 检查两个哈希表
    for (table = 0; table &lt;= 1; table++) {
        idx = h &amp; d-&gt;ht[table].sizemask;
        he = d-&gt;ht[table].table[idx];

        // 检查是否已存在相同key
        while(he) {
            if (dictCompareKeys(d, key, he-&gt;key))
                return -1;
            he = he-&gt;next;
        }

        // 如果不在rehash，只需要检查第一个表
        if (!dictIsRehashing(d)) break;
    }

    return idx;
}
</code></pre>
<p><strong>MurmurHash2算法的优势</strong></p>
<p>Redis选择MurmurHash2作为哈希算法是有原因的：</p>
<ol>
<li><p><strong>优秀的分布特性</strong>：</p>
<ul>
<li>能够产生均匀分布的哈希值</li>
<li>减少哈希冲突的概率</li>
<li>保证哈希表的负载均衡</li>
</ul>
</li>
<li><p><strong>高性能计算</strong>：</p>
<ul>
<li>基于位运算和乘法运算，计算速度快</li>
<li>处理8字节块，对现代CPU友好</li>
<li>比传统的MD5/SHA1等哈希算法快得多</li>
</ul>
</li>
<li><p><strong>碰撞阻力</strong>：</p>
<ul>
<li>良好的雪崩效应，输入微小变化导致输出巨大变化</li>
<li>适合作为哈希表的哈希函数</li>
</ul>
</li>
</ol>
<p><strong>索引计算和冲突处理原理</strong></p>
<ol>
<li><p><strong>索引计算</strong>：</p>
<ul>
<li>使用<code>h &amp; d-&gt;ht[table].sizemask</code>计算索引</li>
<li>sizemask是size-1，因为哈希表大小总是2的幂次</li>
<li>位运算比取模运算<code>h % size</code>更高效</li>
</ul>
</li>
<li><p><strong>rehash期间的特殊处理</strong>：</p>
<ul>
<li>同时检查两个哈希表，确保数据一致性</li>
<li>新数据插入到ht[1]，旧数据仍在ht[0]中逐步迁移</li>
</ul>
</li>
</ol>
<h3>4. 渐进式Rehash的设计精髓</h3>
<p><strong>为什么需要渐进式Rehash？</strong></p>
<p>传统的哈希表rehash操作存在性能问题：</p>
<ul>
<li>一次性迁移所有数据会导致服务阻塞</li>
<li>大数据量的哈希表rehash可能耗时几百毫秒甚至更长时间</li>
<li>这在高并发场景下是不可接受的</li>
</ul>
<p><strong>Redis渐进式Rehash的巧妙设计</strong></p>
<p>Redis通过分批迁移的方式解决了这个问题：</p>
<ol>
<li><p><strong>分而治之的思想</strong>：</p>
<ul>
<li>将rehash操作分解为多个小步骤</li>
<li>每次只迁移部分数据，避免长时间阻塞</li>
<li>在正常操作间隙逐步完成迁移</li>
</ul>
</li>
<li><p><strong>双表并存策略</strong>：</p>
<ul>
<li>rehash期间同时维护两个哈希表</li>
<li>查找操作需要检查两个表</li>
<li>新增操作只在新表中进行</li>
</ul>
</li>
<li><p><strong>渐进式迁移触发</strong>：</p>
<ul>
<li>字典操作时被动触发单步rehash</li>
<li>定时任务主动批量rehash</li>
<li>确保rehash在合理时间内完成</li>
</ul>
</li>
</ol>
<pre><code class="language-c">// 执行单步rehash
int dictRehash(dict *d, int n) {
    int empty_visits = n * 10; // 最大访问空槽位数

    if (!dictIsRehashing(d)) return 0;

    while(n-- &amp;&amp; d-&gt;ht[0].used != 0) {
        dictEntry *de, *nextde;

        // 找到下一个非空槽位
        while(d-&gt;ht[0].table[d-&gt;rehashidx] == NULL) {
            d-&gt;rehashidx++;
            if (--empty_visits == 0) return 1;
        }

        de = d-&gt;ht[0].table[d-&gt;rehashidx];

        // 迁移该槽位的所有键值对
        while(de) {
            unsigned int h;
            nextde = de-&gt;next;

            // 计算在新表中的索引
            h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[1].sizemask;

            // 插入到新表头部
            de-&gt;next = d-&gt;ht[1].table[h];
            d-&gt;ht[1].table[h] = de;

            // 更新计数器
            d-&gt;ht[0].used--;
            d-&gt;ht[1].used++;

            de = nextde;
        }

        // 释放旧表槽位
        d-&gt;ht[0].table[d-&gt;rehashidx] = NULL;
        d-&gt;rehashidx++;
    }

    // 完成rehash
    if (d-&gt;ht[0].used == 0) {
        zfree(d-&gt;ht[0].table);
        d-&gt;ht[0] = d-&gt;ht[1];
        _dictReset(&amp;d-&gt;ht[1]);
        d-&gt;rehashidx = -1;
        return 0;
    }

    return 1;
}

// 定时rehash
int dictRehashMilliseconds(dict *d, int ms) {
    long long start = timeInMilliseconds();
    int rehashes = 0;

    while(dictRehash(d, 100)) {
        rehashes += 100;
        if (timeInMilliseconds() - start &gt; ms) break;
    }

    return rehashes;
}
</code></pre>
<p><strong>渐进式Rehash的实现细节</strong></p>
<ol>
<li><p><strong>empty_visits机制</strong>：</p>
<ul>
<li>防止在稀疏哈希表中无限制地查找空槽位</li>
<li>最多访问n*10个空槽位后就返回，避免CPU浪费</li>
<li>在数据分布不均匀的情况下保护性能</li>
</ul>
</li>
<li><p><strong>rehashidx的作用</strong>：</p>
<ul>
<li>记录当前迁移到的槽位索引</li>
<li>每次迁移从上次的位置继续</li>
<li>确保迁移过程不重复、不遗漏</li>
</ul>
</li>
<li><p><strong>批量迁移策略</strong>：</p>
<ul>
<li><code>dictRehashMilliseconds</code>支持时间控制的批量迁移</li>
<li>一次最多迁移100个槽位或直到超时</li>
<li>平衡迁移效率和系统响应性</li>
</ul>
</li>
<li><p><strong>rehash完成的处理</strong>：</p>
<ul>
<li>释放旧表内存，将新表作为主表</li>
<li>重置rehash状态，恢复正常单表操作</li>
<li>确保内存使用的高效性</li>
</ul>
</li>
</ol>
<h2>SkipList（跳跃表）</h2>
<h3>1. 跳跃表结构定义</h3>
<pre><code class="language-c">// redis.h
typedef struct zskiplistNode {
    sds ele;                     // 成员对象
    double score;                // 分值
    struct zskiplistNode *backward; // 后退指针
    struct zskiplistLevel {
        struct zskiplistNode *forward; // 前进指针
        unsigned long span;      // 跨度
    } level[];                   // 层级数组
} zskiplistNode;

typedef struct zskiplist {
    struct zskiplistNode *header, *tail; // 头尾节点
    unsigned long length;         // 节点数量
    int level;                    // 最大层级
} zskiplist;
</code></pre>
<h3>2. 跳跃表的设计原理</h3>
<p><strong>跳跃表的核心思想</strong></p>
<p>跳跃表是一种基于概率的有序数据结构，其设计灵感来源于多级索引的概念：</p>
<ol>
<li><p><strong>分层结构</strong>：</p>
<ul>
<li>底层链表包含所有元素，保持有序</li>
<li>上层链表是下层链表的&quot;快速通道&quot;</li>
<li>每层元素逐级递减，形成金字塔结构</li>
</ul>
</li>
<li><p><strong>查找优化</strong>：</p>
<ul>
<li>查找时从最高层开始，快速定位到目标区域</li>
<li>然后逐层下降，最终在底层找到精确位置</li>
<li>平均时间复杂度为O(log n)</li>
</ul>
</li>
<li><p><strong>空间换时间</strong>：</p>
<ul>
<li>通过增加冗余的索引节点，换取查找性能的提升</li>
<li>相比平衡树，实现更简单，性能同样优秀</li>
</ul>
</li>
</ol>
<p><strong>跳跃表vs平衡树的选择</strong></p>
<p>Redis在有序集合中选择跳跃表而非平衡树的原因：</p>
<ol>
<li><p><strong>实现复杂度</strong>：</p>
<ul>
<li>跳跃表实现相对简单，代码易于理解和维护</li>
<li>平衡树（如红黑树）实现复杂，旋转操作繁琐</li>
</ul>
</li>
<li><p><strong>性能特点</strong>：</p>
<ul>
<li>跳跃表在平均情况下性能优秀</li>
<li>范围查询操作比平衡树更直观高效</li>
</ul>
</li>
<li><p><strong>内存局部性</strong>：</p>
<ul>
<li>跳跃表的节点在内存中分布更均匀</li>
<li>缓存命中率相对较高</li>
</ul>
</li>
<li><p><strong>并发友好</strong>：</p>
<ul>
<li>跳跃表的插入删除操作影响范围较小</li>
<li>更容易实现并发控制</li>
</ul>
</li>
</ol>
<p><strong>Redis跳跃表的特殊设计</strong></p>
<pre><code class="language-c">typedef struct zskiplistNode {
    sds ele;                     // 成员对象
    double score;                // 分值
    struct zskiplistNode *backward; // 后退指针
    struct zskiplistLevel {
        struct zskiplistNode *forward; // 前进指针
        unsigned long span;      // 跨度
    } level[];                   // 层级数组
} zskiplistNode;
</code></pre>
<p><strong>Redis跳跃表的创新点</strong>：</p>
<ol>
<li><p><strong>后退指针（backward）</strong>：</p>
<ul>
<li>支持从后向前的遍历操作</li>
<li>在ZREVRANGE等命令中很有用</li>
<li>这是Redis跳跃表的特有设计</li>
</ul>
</li>
<li><p><strong>跨度（span）字段</strong>：</p>
<ul>
<li>记录当前指针到下一个节点的距离</li>
<li>用于快速计算排名（ZRANK命令）</li>
<li>使得跳跃表不仅支持范围查询，还支持排名查询</li>
</ul>
</li>
<li><p><strong>柔性层级数组</strong>：</p>
<ul>
<li>使用柔性数组实现可变层数</li>
<li>节省内存，每个节点只分配需要的层级</li>
</ul>
</li>
</ol>
<h3>3. 跳跃表插入操作详解</h3>
<pre><code class="language-c">// t_zset.c
zskiplistNode *zslInsert(zskiplist *zsl, double score, sds ele) {
    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
    unsigned int rank[ZSKIPLIST_MAXLEVEL];
    int i, level;

    // 获取当前最大层级
    serverAssert(!zslIsInRange(zsl, &amp;range));

    // 从最高层开始查找插入位置
    x = zsl-&gt;header;
    for (i = zsl-&gt;level-1; i &gt;= 0; i--) {
        rank[i] = i == (zsl-&gt;level-1) ? 0 : rank[i+1];
        while (x-&gt;level[i].forward &amp;&amp;
                (x-&gt;level[i].forward-&gt;score &lt; score ||
                    (x-&gt;level[i].forward-&gt;score == score &amp;&amp;
                    sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; 0))) {
            rank[i] += x-&gt;level[i].span;
            x = x-&gt;level[i].forward;
        }
        update[i] = x;
    }

    // 随机生成新节点的层数
    level = zslRandomLevel();
    if (level &gt; zsl-&gt;level) {
        for (i = zsl-&gt;level; i &lt; level; i++) {
            rank[i] = 0;
            update[i] = zsl-&gt;header;
            update[i]-&gt;level[i].span = zsl-&gt;length;
        }
        zsl-&gt;level = level;
    }

    // 创建新节点
    x = zslCreateNode(level, score, ele);
    for (i = 0; i &lt; level; i++) {
        x-&gt;level[i].forward = update[i]-&gt;level[i].forward;
        update[i]-&gt;level[i].forward = x;

        x-&gt;level[i].span = update[i]-&gt;level[i].span - (rank[0] - rank[i]);
        update[i]-&gt;level[i].span = (rank[0] - rank[i]) + 1;
    }

    // 更新其他层的跨度
    for (i = level; i &lt; zsl-&gt;level; i++) {
        update[i]-&gt;level[i].span++;
    }

    x-&gt;backward = (update[0] == zsl-&gt;header) ? NULL : update[0];
    if (x-&gt;level[0].forward)
        x-&gt;level[0].forward-&gt;backward = x;
    else
        zsl-&gt;tail = x;

    zsl-&gt;length++;
    return x;
}

// 随机生成层数
int zslRandomLevel(void) {
    int level = 1;
    while ((random() &amp; 0xFFFF) &lt; (ZSKIPLIST_P * 0xFFFF))
        level += 1;
    return (level &lt; ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;
}
</code></pre>
<p><strong>插入操作的深度解析</strong></p>
<ol>
<li><p><strong>查找插入位置的策略</strong>：</p>
<ul>
<li>使用<code>update</code>数组记录每层需要更新的前驱节点</li>
<li>使用<code>rank</code>数组记录每层节点的累计排名</li>
<li>从高层到低层逐步精确定位插入点</li>
</ul>
</li>
<li><p><strong>随机层数的生成</strong>：</p>
<ul>
<li>Redis使用概率P=0.25决定是否增加层级</li>
<li>期望每个节点出现在第i层的概率为1/4^i</li>
<li>保证了跳跃表层数的合理分布</li>
</ul>
</li>
<li><p><strong>跨度（span）的计算逻辑</strong>：</p>
<ul>
<li>跨度表示当前节点到下个节点的距离</li>
<li>插入新节点需要重新计算相关跨度</li>
<li>支持快速排名查询（ZRANK命令）</li>
</ul>
</li>
<li><p><strong>后退指针的维护</strong>：</p>
<ul>
<li>新节点的backward指向前驱节点</li>
<li>更新后继节点的backward指针</li>
<li>支持反向遍历操作</li>
</ul>
</li>
</ol>
<p><strong>概率模型的数学基础</strong></p>
<p>跳跃表的性能依赖于其概率分布：</p>
<ul>
<li>第1层节点概率：P = 0.25</li>
<li>第2层节点概率：P² = 0.0625</li>
<li>第n层节点概率：P^n</li>
</ul>
<p>这种指数衰减的分布确保了：</p>
<ul>
<li>高层级节点稀少，形成高效的&quot;快速通道&quot;</li>
<li>空间复杂度控制在O(n)范围内</li>
<li>查找时间复杂度期望为O(log n)</li>
</ul>
<h3>4. 跳跃表删除操作原理</h3>
<pre><code class="language-c">void zslDeleteNode(zskiplist *zsl, zskiplistNode *x, zskiplistNode **update) {
    int i;

    // 更新每一层的指针
    for (i = 0; i &lt; zsl-&gt;level; i++) {
        if (update[i]-&gt;level[i].forward == x) {
            update[i]-&gt;level[i].span += x-&gt;level[i].span - 1;
            update[i]-&gt;level[i].forward = x-&gt;level[i].forward;
        } else {
            update[i]-&gt;level[i].span -= 1;
        }
    }

    // 更新后退指针
    if (x-&gt;level[0].forward) {
        x-&gt;level[0].forward-&gt;backward = x-&gt;backward;
    } else {
        zsl-&gt;tail = x-&gt;backward;
    }

    // 减少层级
    while(zsl-&gt;level &gt; 1 &amp;&amp; zsl-&gt;header-&gt;level[zsl-&gt;level-1].forward == NULL)
        zsl-&gt;level--;

    zsl-&gt;length--;
}

int zslDelete(zskiplist *zsl, double score, sds ele, zskiplistNode **node) {
    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
    int i;

    // 查找删除位置
    x = zsl-&gt;header;
    for (i = zsl-&gt;level-1; i &gt;= 0; i--) {
        while (x-&gt;level[i].forward &amp;&amp;
                (x-&gt;level[i].forward-&gt;score &lt; score ||
                    (x-&gt;level[i].forward-&gt;score == score &amp;&amp;
                    sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; 0))) {
            x = x-&gt;level[i].forward;
        }
        update[i] = x;
    }

    x = x-&gt;level[0].forward;
    if (x &amp;&amp; score == x-&gt;score &amp;&amp; sdscmp(x-&gt;ele,ele) == 0) {
        zslDeleteNode(zsl, x, update);
        if (!node)
            zslFreeNode(x);
        else
            *node = x;
        return 1;
    }

    return 0;
}
</code></pre>
<p><strong>删除操作的关键要点</strong></p>
<ol>
<li><p><strong>跨度的重新计算</strong>：</p>
<ul>
<li>只有包含被删除节点的层级需要调整跨度</li>
<li>其他层级只需将跨度减1</li>
<li>保持排名查询的正确性</li>
</ul>
</li>
<li><p><strong>层级收缩机制</strong>：</p>
<ul>
<li>当高层级完全为空时，自动减少跳跃表高度</li>
<li>避免无效的高层级节点浪费空间</li>
<li>保持跳跃表结构的紧凑性</li>
</ul>
</li>
<li><p><strong>双向指针维护</strong>：</p>
<ul>
<li>更新前驱节点的forward指针</li>
<li>更新后继节点的backward指针</li>
<li>维护双向链表的完整性</li>
</ul>
</li>
</ol>
<p><strong>跳跃表性能总结</strong></p>
<ul>
<li><strong>查找复杂度</strong>：O(log n) 平均，O(n) 最坏</li>
<li><strong>插入复杂度</strong>：O(log n) 平均，O(n) 最坏</li>
<li><strong>删除复杂度</strong>：O(log n) 平均，O(n) 最坏</li>
<li><strong>空间复杂度</strong>：O(n)</li>
<li><strong>范围查询</strong>：O(log n + k)，k为结果数量</li>
</ul>
<p>跳跃表在Redis中为有序集合提供了优秀的性能支持，特别是在需要范围查询和排名查询的场景中表现出色。</p>
<h2>ZipList（压缩列表）</h2>
<h3>1. 压缩列表结构</h3>
<pre><code>&lt;zlbytes&gt; &lt;zltail&gt; &lt;zllen&gt; &lt;entry&gt;... &lt;entry&gt; &lt;zlend&gt;

各字段含义：
- zlbytes: 压缩列表总字节数
- zltail: 最后一个entry的偏移量
- zllen: entry的数量
- entry: 具体的数据项
- zlend: 压缩列表结束标记，值为255
</code></pre>
<h3>2. ZipList设计思想</h3>
<p><strong>压缩列表的核心价值</strong></p>
<p>ZipList是Redis为小数据集设计的内存优化结构，其设计理念体现了&quot;极致节省内存&quot;的追求：</p>
<ol>
<li><p><strong>连续内存布局</strong>：</p>
<ul>
<li>所有数据存储在一块连续内存中</li>
<li>避免指针开销和内存碎片</li>
<li>提高缓存局部性</li>
</ul>
</li>
<li><p><strong>变长编码优化</strong>：</p>
<ul>
<li>根据数据大小选择不同的编码方式</li>
<li>小整数使用1字节，大整数使用5字节</li>
<li>字符串长度也采用变长编码</li>
</ul>
</li>
<li><p><strong>特殊场景优化</strong>：</p>
<ul>
<li>针对小Hash、小List、小Sorted Set设计</li>
<li>当数据量和单元素大小较小时使用</li>
<li>在内存使用上达到极致优化</li>
</ul>
</li>
</ol>
<p><strong>Entry结构的精妙设计</strong></p>
<pre><code>&lt;prevlen&gt; &lt;encoding&gt; &lt;len&gt; &lt;data&gt;
</code></pre>
<ol>
<li><p><strong>prevlen（前驱长度）</strong>：</p>
<ul>
<li>记录前一个entry的字节长度</li>
<li>支持从后向前的遍历操作</li>
<li>长度本身也采用变长编码（1或5字节）</li>
</ul>
</li>
<li><p><strong>encoding（编码标识）</strong>：</p>
<ul>
<li>高2位标识数据类型（字符串/整数）</li>
<li>低6位标识长度编码方式</li>
<li>通过编码减少数据存储开销</li>
</ul>
</li>
<li><p><strong>变长编码的优势</strong>：</p>
<ul>
<li>小数值用少字节，大数值用多字节</li>
<li>平均每个entry节省2-4字节</li>
<li>在小数据集中效果显著</li>
</ul>
</li>
</ol>
<h3>3. Entry编码细节</h3>
<p><strong>字符串编码方式</strong>：</p>
<pre><code>00xxxxxx: 6位长度，最大63字节
01xxxxxx xxxxxxxx: 14位长度，最大16383字节
10xxxxxx xxxxxxxx xxxxxxxx xxxxxxxx: 22位长度，最大4MB
11000000: 后续4字节表示长度，最大4GB
</code></pre>
<p><strong>整数编码方式</strong>：</p>
<pre><code>11000000: int16_t
11010000: int32_t
11100000: int64_t
11110000: 24位有符号整数
11111110: 8位有符号整数
11111111: 0
1111xxxx: 1-13位立即数
</code></pre>
<p><strong>编码选择策略</strong>：</p>
<ul>
<li>优先选择最紧凑的编码方式</li>
<li>整数优先使用立即数编码</li>
<li>字符串根据长度选择合适的编码</li>
<li>减少内存占用是首要目标</li>
</ul>
<h3>4. 压缩列表操作</h3>
<pre><code class="language-c">// zip_list.h
#define ZIP_END 255
#define ZIP_BIGLEN 254

/* encoding */
#define ZIP_STR_MASK 0xc0
#define ZIP_STR_06B (0 &lt;&lt; 6)
#define ZIP_STR_14B (1 &lt;&lt; 6)
#define ZIP_STR_32B (2 &lt;&lt; 6)

#define ZIP_INT_MASK 0x30
#define ZIP_INT_16B (0xc0 | 0 &lt;&lt; 4)
#define ZIP_INT_32B (0xc0 | 1 &lt;&lt; 4)
#define ZIP_INT_64B (0xc0 | 2 &lt;&lt; 4)
#define ZIP_INT_24B (0xc0 | 3 &lt;&lt; 4)
#define ZIP_INT_8B  (0xc0 | 4 &lt;&lt; 4)

// 创建压缩列表
unsigned char *ziplistNew(void) {
    unsigned int bytes = ZIPLIST_HEADER_SIZE + 1;
    unsigned char *zl = zmalloc(bytes);
    ZIPLIST_BYTES(zl) = bytes;
    ZIPLIST_TAIL_OFFSET(zl) = ZIPLIST_HEADER_SIZE;
    ZIPLIST_LENGTH(zl) = 0;
    zl[bytes-1] = ZIP_END;
    return zl;
}

// 插入数据
unsigned char *ziplistInsert(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen) {
    return __ziplistInsert(zl, p, s, slen);
}

// 删除数据
unsigned char *ziplistDelete(unsigned char *zl, unsigned char **p) {
    size_t offset = *p - zl;
    zl = __ziplistDelete(zl, *p, 1);
    *p = zl + offset;
    return zl;
}
</code></pre>
<p><strong>压缩列表操作的核心挑战</strong></p>
<ol>
<li><p><strong>连锁更新问题</strong>：</p>
<ul>
<li>插入或删除可能导致后续entry的prevlen字段变化</li>
<li>当某个entry长度变化超过254字节时，prevlen需要从1字节扩展到5字节</li>
<li>可能触发连锁反应，导致多个entry需要重新分配</li>
</ul>
</li>
<li><p><strong>内存重分配策略</strong>：</p>
<ul>
<li>插入时需要扩展内存空间</li>
<li>删除时需要压缩内存空间</li>
<li>频繁的重分配会影响性能</li>
</ul>
</li>
<li><p><strong>性能权衡</strong>：</p>
<ul>
<li>内存效率：极高的内存利用率</li>
<li>时间复杂度：插入删除为O(n)，且可能触发连锁更新</li>
<li>适用场景：小数据量，读多写少</li>
</ul>
</li>
</ol>
<p><strong>ZipList的适用边界</strong></p>
<ul>
<li><strong>内存优势</strong>：相比普通链表节省大量内存</li>
<li><strong>性能劣势</strong>：大数据量时性能下降明显</li>
<li><strong>使用建议</strong>：元素数量&lt;1000，单个元素&lt;64字节</li>
</ul>
<h2>IntSet（整数集合）</h2>
<h3>1. 整数集合设计原理</h3>
<p><strong>IntSet的核心价值</strong></p>
<p>IntSet是Redis为纯整数集合设计的优化结构，体现了类型特化设计的优势：</p>
<ol>
<li><p><strong>类型特化</strong>：</p>
<ul>
<li>专门处理整数数据，不支持其他类型</li>
<li>针对整数操作进行深度优化</li>
<li>避免通用数据结构的开销</li>
</ul>
</li>
<li><p><strong>自动升级机制</strong>：</p>
<ul>
<li>根据数据范围自动选择合适的整数类型</li>
<li>int16_t → int32_t → int64_t的渐进式升级</li>
<li>升级过程保证数据完整性</li>
</ul>
</li>
<li><p><strong>有序存储</strong>：</p>
<ul>
<li>数组按升序排列，支持二分查找</li>
<li>插入时需要找到合适位置并移动后续元素</li>
<li>查找效率高，插入效率相对较低</li>
</ul>
</li>
</ol>
<pre><code class="language-c">// intset.h
typedef struct intset {
    uint32_t encoding;  // 编码方式
    uint32_t length;    // 元素数量
    int8_t contents[];  // 实际存储元素
} intset;

/* encoding */
#define INTSET_ENC_INT16 (sizeof(int16_t))
#define INTSET_ENC_INT32 (sizeof(int32_t))
#define INTSET_ENC_INT64 (sizeof(int64_t))
</code></pre>
<p><strong>编码选择策略</strong></p>
<ul>
<li>int16_t：-32768 到 32767，占用2字节</li>
<li>int32_t：-2147483648 到 2147483647，占用4字节</li>
<li>int64_t：-9223372036854775808 到 9223372036854775807，占用8字节</li>
</ul>
<h3>2. IntSet升级机制详解</h3>
<pre><code class="language-c">// intset.c
intset *intsetUpgradeAndAdd(intset *is, int64_t value) {
    uint8_t curenc = intrev32ifbe(is-&gt;encoding);
    uint8_t newenc = _intsetValueEncoding(value);
    int length = intrev32ifbe(is-&gt;length);
    int prepend = value &lt; 0 ? 1 : 0;

    // 设置新的编码方式
    is-&gt;encoding = intrev32ifbe(newenc);
    is-&gt;length = intrev32ifbe(length+1);

    // 根据新编码方式扩展空间
    is = zrealloc(is, sizeof(intset)+newenc*(length+1));

    // 移动原有数据
    if (prepend) {
        memmove(is-&gt;contents+newenc, is-&gt;contents, length*newenc);
    } else {
        memmove(is-&gt;contents+newenc*prepend, is-&gt;contents, length*newenc);
    }

    // 设置新值
    if (prepend) {
        _intsetSet(is,0,value);
    } else {
        _intsetSet(is,length,value);
    }

    return is;
}

// 插入元素
intset *intsetAdd(intset *is, int64_t value, uint8_t *success) {
    uint8_t valenc = _intsetValueEncoding(value);
    uint32_t pos;

    if (success) *success = 1;

    // 如果需要升级
    if (valenc &gt; intrev32ifbe(is-&gt;encoding)) {
        return intsetUpgradeAndAdd(is, value);
    }

    // 检查是否已存在
    if (intsetSearch(is, value, &amp;pos)) {
        if (success) *success = 0;
        return is;
    }

    // 扩展空间并插入
    is = intsetResize(is, intrev32ifbe(is-&gt;length)+1);
    if (pos &lt; intrev32ifbe(is-&gt;length))
        intsetMoveTail(is, pos, pos+1);

    _intsetSet(is, pos, value);
    is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length)+1);

    return is;
}
</code></pre>
<p><strong>升级操作的精妙设计</strong></p>
<ol>
<li><p><strong>升级触发条件</strong>：</p>
<ul>
<li>新元素超出当前编码范围时自动触发</li>
<li>从int16_t升级到int32_t，或从int32_t升级到int64_t</li>
<li>升级过程一次性完成，保证数据一致性</li>
</ul>
</li>
<li><p><strong>内存重分配策略</strong>：</p>
<ul>
<li>重新分配更大的内存空间</li>
<li>将原有数据按新的编码格式重新排列</li>
<li>保持数据的有序性和完整性</li>
</ul>
</li>
<li><p><strong>插入位置优化</strong>：</p>
<ul>
<li>负数插入到数组头部</li>
<li>正数插入到数组尾部</li>
<li>利用有序性减少数据移动</li>
</ul>
</li>
</ol>
<p><strong>IntSet的性能特征</strong></p>
<ul>
<li><strong>查找性能</strong>：O(log n)，使用二分查找</li>
<li><strong>插入性能</strong>：O(n)，需要移动元素，可能触发升级</li>
<li><strong>内存效率</strong>：根据数据范围选择最优编码</li>
<li><strong>使用场景</strong>：整数集合，元素数量适中，读多写少</li>
</ul>
<p><strong>自动升级的优势与代价</strong></p>
<p><strong>优势</strong>：</p>
<ul>
<li>根据实际数据动态选择最优编码</li>
<li>避免一开始就使用最大类型的浪费</li>
<li>对用户透明，无需手动管理类型</li>
</ul>
<p><strong>代价</strong>：</p>
<ul>
<li>升级操作需要重新分配和复制所有数据</li>
<li>升级过程中的性能开销较大</li>
<li>一旦升级，不会降级，可能浪费内存</li>
</ul>
<h2>QuickList（快速列表）</h2>
<h3>1. 快速列表结构</h3>
<pre><code class="language-c">// quicklist.h
typedef struct quicklistNode {
    struct quicklistNode *prev;   // 前一个节点
    struct quicklistNode *next;   // 后一个节点
    unsigned char *zl;            // 指向压缩列表
    unsigned int sz;              // 压缩列表字节数
    unsigned int count : 16;      // 压缩列表包含的元素数量
    unsigned int encoding : 2;    // 编码方式
    unsigned int container : 2;   // 容器类型
    unsigned int recompress : 1;  // 是否重新压缩
    unsigned int attempted_compress : 1; // 尝试压缩次数
    unsigned int extra : 10;      // 预留字段
} quicklistNode;

typedef struct quicklistLZF {
    unsigned int sz;              // 压缩后长度
    char compressed[];            // 压缩数据
} quicklistLZF;

typedef struct quicklist {
    quicklistNode *head;          // 头节点
    quicklistNode *tail;          // 尾节点
    unsigned long count;          // 元素总数
    unsigned long len;            // 节点数量
    int fill : 16;                // 填充因子
    unsigned int compress : 16;   // 压缩深度
} quicklist;
</code></pre>
<h3>2. QuickList设计动机</h3>
<p><strong>QuickList的诞生背景</strong></p>
<p>QuickList是Redis 3.2版本引入的新数据结构，旨在解决传统LinkedList在大数据量场景下的性能问题：</p>
<ol>
<li><p><strong>传统LinkedList的缺陷</strong>：</p>
<ul>
<li>每个节点独立分配内存，内存碎片严重</li>
<li>指针开销大，每个节点需要额外的prev/next指针</li>
<li>缓存局部性差，节点在内存中分布分散</li>
<li>双端操作虽然O(1)，但内存访问效率低</li>
</ul>
</li>
<li><p><strong>ZipList的局限性</strong>：</p>
<ul>
<li>虽然内存效率极高，但大数据量时性能下降</li>
<li>连锁更新问题在长列表中会被放大</li>
<li>插入删除操作时间复杂度为O(n)</li>
</ul>
</li>
</ol>
<p><strong>QuickList的混合设计思想</strong></p>
<p>QuickList巧妙地结合了LinkedList和ZipList的优势：</p>
<ol>
<li><p><strong>分而治之策略</strong>：</p>
<ul>
<li>将长列表切分为多个ZipList节点</li>
<li>每个ZipList节点控制在合理大小（通常几KB）</li>
<li>避免单个ZipList过大导致的性能问题</li>
</ul>
</li>
<li><p><strong>双层结构设计</strong>：</p>
<ul>
<li>外层使用双向链表，支持高效的双端操作</li>
<li>内层使用ZipList，保持高内存利用率</li>
<li>在性能和内存使用之间找到最佳平衡点</li>
</ul>
</li>
<li><p><strong>自适应优化</strong>：</p>
<ul>
<li>支持压缩策略，对不常用节点进行LZF压缩</li>
<li>支持动态调整ZipList大小，适应不同使用模式</li>
<li>提供配置参数，根据业务特点优化</li>
</ul>
</li>
</ol>
<p><strong>QuickList的优势分析</strong></p>
<ol>
<li><p><strong>性能优势</strong>：</p>
<ul>
<li>双端操作：O(1)时间复杂度，比ZipList的O(n)更优</li>
<li>中间访问：通过跳转表优化，减少遍历开销</li>
<li>内存访问：局部性更好，缓存命中率更高</li>
</ul>
</li>
<li><p><strong>内存优势</strong>：</p>
<ul>
<li>相比纯LinkedList，减少50%以上的内存使用</li>
<li>支持压缩，进一步节省内存空间</li>
<li>避免了大量小内存分配，减少内存碎片</li>
</ul>
</li>
<li><p><strong>扩展优势</strong>：</p>
<ul>
<li>支持配置化，可根据业务场景调整</li>
<li>兼容性好，对用户透明</li>
<li>为后续优化预留了空间</li>
</ul>
</li>
</ol>
<h3>3. 快速列表操作详解</h3>
<pre><code class="language-c">// quicklist.c
quicklist *quicklistCreate(void) {
    struct quicklist *quicklist;

    quicklist = zmalloc(sizeof(*quicklist));
    quicklist-&gt;head = quicklist-&gt;tail = NULL;
    quicklist-&gt;len = 0;
    quicklist-&gt;count = 0;
    quicklist-&gt;compress = 0;
    quicklist-&gt;fill = -2;
    return quicklist;
}

int quicklistPushHead(quicklist *quicklist, void *value, size_t sz) {
    quicklistNode *orig_head = quicklist-&gt;head;

    if (likely(
            _quicklistNodeAllowInsert(quicklist-&gt;head, quicklist-&gt;fill, sz))) {
        quicklist-&gt;head-&gt;zl = ziplistPush(quicklist-&gt;head-&gt;zl, value, sz, ZIPLIST_HEAD);
        quicklist-&gt;head-&gt;count++;
    } else {
        quicklistNode *node = quicklistCreateNode();
        node-&gt;zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_HEAD);
        node-&gt;count++;
        _quicklistInsertNodeBefore(quicklist, quicklist-&gt;head, node);
    }
    quicklist-&gt;count++;
    return 1;
}
</code></pre>
<p><strong>QuickList操作的核心策略</strong></p>
<ol>
<li><p><strong>智能插入策略</strong>：</p>
<ul>
<li>优先尝试在现有ZipList节点中插入</li>
<li>当ZipList节点达到容量限制时，创建新节点</li>
<li>通过<code>fill</code>参数控制每个ZipList的最大大小</li>
</ul>
</li>
<li><p><strong>fill参数的作用</strong>：</p>
<ul>
<li>正数：限制每个ZipList的最大元素数量</li>
<li>负数：限制每个ZipList的最大字节大小</li>
<li>例如：<code>-2</code>表示每个ZipList最大8KB</li>
</ul>
</li>
<li><p><strong>压缩策略</strong>：</p>
<ul>
<li><code>compress</code>参数控制压缩深度</li>
<li>对距离两端较远的节点进行压缩</li>
<li>平衡内存使用和解压缩开销</li>
</ul>
</li>
</ol>
<p><strong>QuickList的性能优化特点</strong></p>
<ol>
<li><p><strong>分批操作优化</strong>：</p>
<ul>
<li>避免单个ZipList过大，减少连锁更新的影响</li>
<li>支持并行操作，不同ZipList节点可独立处理</li>
<li>提高内存分配和释放的效率</li>
</ul>
</li>
<li><p><strong>缓存友好设计</strong>：</p>
<ul>
<li>相关数据聚集在同一个ZipList中</li>
<li>减少内存跳跃访问，提高缓存命中率</li>
<li>适合访问局部性强的场景</li>
</ul>
</li>
<li><p><strong>动态平衡机制</strong>：</p>
<ul>
<li>根据访问模式自动调整压缩策略</li>
<li>支持节点分裂和合并，保持结构平衡</li>
<li>在内存使用和访问性能之间动态平衡</li>
</ul>
</li>
</ol>
<p><strong>QuickList vs 其他结构的对比</strong></p>
<div class="table-wrapper"><table style="width: auto;">
<thead>
<tr>
<th>特性</th>
<th>LinkedList</th>
<th>ZipList</th>
<th>QuickList</th>
</tr>
</thead>
<tbody><tr>
<td>双端操作</td>
<td>O(1)</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>内存使用</td>
<td>高</td>
<td>极低</td>
<td>中等</td>
</tr>
<tr>
<td>中间访问</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(n/m)</td>
</tr>
<tr>
<td>连锁更新</td>
<td>无</td>
<td>严重</td>
<td>轻微</td>
</tr>
<tr>
<td>适用场景</td>
<td>频繁双端操作</td>
<td>小数据集</td>
<td>通用场景</td>
</tr>
</tbody></table></div>
<p>QuickList成为了Redis List类型的默认实现，它在各种使用场景下都能提供优秀的性能表现。</p>
<h2>性能分析和优化建议</h2>
<h3>1. 数据结构复杂度分析</h3>
<div class="table-wrapper"><table style="width: auto;">
<thead>
<tr>
<th>数据结构</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>SDS</td>
<td>O(1)</td>
<td>O(n)</td>
<td>字符串操作</td>
</tr>
<tr>
<td>Dict</td>
<td>O(1)平均</td>
<td>O(n)</td>
<td>键值对存储</td>
</tr>
<tr>
<td>SkipList</td>
<td>O(log n)</td>
<td>O(n)</td>
<td>排序集合</td>
</tr>
<tr>
<td>ZipList</td>
<td>O(n)</td>
<td>O(n)</td>
<td>小数据集合</td>
</tr>
<tr>
<td>IntSet</td>
<td>O(log n)</td>
<td>O(n)</td>
<td>整数集合</td>
</tr>
<tr>
<td>QuickList</td>
<td>O(n)</td>
<td>O(n)</td>
<td>列表操作</td>
</tr>
</tbody></table></div>
<h3>2. 内存优化策略</h3>
<p><strong>选择合适的数据结构</strong>：</p>
<pre><code class="language-redis"># 小Hash使用ZipList
# 当Hash元素数量小于512且每个元素值小于64字节时，使用ZipList
hash-max-ziplist-entries 512
hash-max-ziplist-value 64

# 小List使用ZipList
# 当List元素数量小于512且每个元素值小于64字节时，使用ZipList
list-max-ziplist-size -2

# 小Set使用IntSet
# 当Set元素都是整数且数量小于512时，使用IntSet
set-max-intset-entries 512

# 小Sorted Set使用ZipList
zset-max-ziplist-entries 128
zset-max-ziplist-value 64
</code></pre>
<h3>3. 实际应用场景分析</h3>
<p><strong>场景一：用户会话管理</strong></p>
<pre><code class="language-redis"># 用户登录信息存储
HSET session:user123 user_id 123 username &quot;alice&quot; login_time 1640995200
</code></pre>
<ul>
<li><strong>数据结构</strong>：Hash（底层：ZipList → Dict）</li>
<li><strong>选择理由</strong>：字段较少时使用ZipList节省内存，字段增多时自动切换到Dict</li>
<li><strong>性能特点</strong>：O(1)的字段访问，内存效率高</li>
<li><strong>最佳实践</strong>：合理设置<code>hash-max-ziplist-entries</code>和<code>hash-max-ziplist-value</code></li>
</ul>
<p><strong>场景二：计数器和排行榜</strong></p>
<pre><code class="language-redis"># 文章点赞数
ZADD article:likes 12345 &quot;article:001&quot; 9876 &quot;article:002&quot; 6543 &quot;article:003&quot;
ZREVRANGE article:likes 0 9 WITHSCORES
</code></pre>
<ul>
<li><strong>数据结构</strong>：Sorted Set（底层：ZipList → SkipList + Dict）</li>
<li><strong>选择理由</strong>：需要排序和范围查询，SkipList提供高效支持</li>
<li><strong>性能特点</strong>：O(log n)的插入和查询，O(log n + k)的范围查询</li>
<li><strong>最佳实践</strong>：小集合使用ZipList，大集合自动切换到SkipList</li>
</ul>
<p><strong>场景三：消息队列</strong></p>
<pre><code class="language-redis"># 简单消息队列
LPUSH queue:tasks &#39;{&quot;id&quot;:1,&quot;type&quot;:&quot;email&quot;,&quot;data&quot;:&quot;test@example.com&quot;}&#39;
BRPOP queue:tasks 30
</code></pre>
<ul>
<li><strong>数据结构</strong>：List（底层：QuickList）</li>
<li><strong>选择理由</strong>：需要高效的双端操作，QuickList平衡性能和内存</li>
<li><strong>性能特点</strong>：O(1)的入队出队操作，内存使用合理</li>
<li><strong>最佳实践</strong>：调整<code>list-max-ziplist-size</code>控制每个ZipList节点大小</li>
</ul>
<p><strong>场景四：标签系统</strong></p>
<pre><code class="language-redis"># 文章标签
SADD article:123:tags &quot;redis&quot; &quot;database&quot; &quot;performance&quot;
SINTER article:123:tags article:456:tags
</code></pre>
<ul>
<li><strong>数据结构</strong>：Set（底层：IntSet → Dict）</li>
<li><strong>选择理由</strong>：整数集合使用IntSet，混合数据使用Dict</li>
<li><strong>性能特点</strong>：O(1)的添加和查找，支持集合运算</li>
<li><strong>最佳实践</strong>：纯整数标签利用IntSet的内存优势</li>
</ul>
<h3>4. 性能监控和调优</h3>
<p><strong>关键监控指标</strong></p>
<pre><code class="language-bash"># 查看内存使用情况
redis-cli info memory | grep used_memory_human

# 查看数据结构信息
redis-cli memory usage key_name

# 监控数据结构变化
redis-cli monitor | grep -E &quot;(SET|HSET|LPUSH|SADD|ZADD)&quot;

# 查看数据结构统计
redis-cli info stats | grep keyspace
</code></pre>
<p><strong>内存优化策略</strong></p>
<ol>
<li><p><strong>选择合适的数据结构</strong>：</p>
<ul>
<li>根据数据特点选择最合适的类型</li>
<li>考虑访问模式和操作频率</li>
<li>平衡内存使用和性能需求</li>
</ul>
</li>
<li><p><strong>合理配置编码阈值</strong>：</p>
<pre><code class="language-redis"># 针对小数据优化配置
hash-max-ziplist-entries 512
hash-max-ziplist-value 64
list-max-ziplist-size -2
set-max-intset-entries 512
zset-max-ziplist-entries 128
zset-max-ziplist-value 64
</code></pre>
</li>
<li><p><strong>监控内存使用模式</strong>：</p>
<ul>
<li>定期检查大key和热key</li>
<li>分析内存碎片情况</li>
<li>根据业务特点调整配置</li>
</ul>
</li>
</ol>
<h3>5. 故障诊断指南</h3>
<p><strong>常见问题及解决方案</strong></p>
<ol>
<li><p><strong>内存使用过高</strong>：</p>
<ul>
<li>检查是否存在大key</li>
<li>分析数据结构是否合理</li>
<li>考虑数据压缩或分片</li>
</ul>
</li>
<li><p><strong>性能下降</strong>：</p>
<ul>
<li>检查是否发生了数据结构编码转换</li>
<li>分析rehash是否阻塞服务</li>
<li>优化查询模式和数据分布</li>
</ul>
</li>
<li><p><strong>延迟问题</strong>：</p>
<ul>
<li>监控慢查询日志</li>
<li>检查网络和硬件状况</li>
<li>优化数据结构和访问方式</li>
</ul>
</li>
</ol>
<h2>总结</h2>
<p>Redis的内部数据结构设计体现了高性能和高效率的追求：</p>
<ol>
<li><strong>SDS</strong>：通过预分配和惰性释放机制优化字符串操作，避免传统C字符串的性能陷阱</li>
<li><strong>Dict</strong>：采用渐进式rehash和链地址法解决哈希冲突，在大数据量下保持稳定性能</li>
<li><strong>SkipList</strong>：提供O(log n)的查找性能，同时支持范围查询，是有序集合的理想选择</li>
<li><strong>ZipList</strong>：通过连续内存存储节省空间，适合小数据集合，但在大数据量时需要谨慎使用</li>
<li><strong>IntSet</strong>：针对整数集合优化，支持自动升级，在整数场景下性能卓越</li>
<li><strong>QuickList</strong>：结合链表和ZipList的优势，平衡性能和内存使用，是列表数据的最佳选择</li>
</ol>
<p><strong>实践建议</strong>：</p>
<ul>
<li>深入理解每种数据结构的特性和适用场景</li>
<li>根据业务需求选择合适的数据结构和配置</li>
<li>持续监控性能指标，及时调整优化策略</li>
<li>在设计阶段考虑数据增长趋势和访问模式</li>
</ul>
<p>理解这些内部数据结构的工作原理，有助于我们更好地使用Redis，选择合适的数据类型，进行性能调优和问题诊断。在实际应用中，应该根据具体场景选择最适合的数据结构，充分发挥Redis的性能优势，构建高效、稳定的应用系统。</p>
</div></div></div></article></div></main></div><script src="/_next/static/chunks/webpack-c81f7fd28659d64f.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/7b42d4e858e38c6b.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"2:I[2846,[],\"\"]\n5:I[4707,[],\"\"]\n8:I[6423,[],\"\"]\nb:I[1060,[],\"\"]\n6:[\"category\",\"notes\",\"d\"]\n7:[\"slug\",\"redis-internal-data-structures\",\"d\"]\nc:[]\n0:[\"$\",\"$L2\",null,{\"buildId\":\"build\",\"assetPrefix\":\"\",\"urlParts\":[\"\",\"notes\",\"redis-internal-data-structures\",\"\"],\"initialTree\":[\"\",{\"children\":[[\"category\",\"notes\",\"d\"],{\"children\":[[\"slug\",\"redis-internal-data-structures\",\"d\"],{\"children\":[\"__PAGE__?{\\\"category\\\":\\\"notes\\\",\\\"slug\\\":\\\"redis-internal-data-structures\\\"}\",{}]}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"category\",\"notes\",\"d\"],{\"children\":[[\"slug\",\"redis-internal-data-structures\",\"d\"],{\"children\":[\"__PAGE__\",{},[[\"$L3\",\"$L4\",null],null],null]},[null,[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$6\",\"children\",\"$7\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}]],null]},[null,[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$6\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}]],null]},[[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/7b42d4e858e38c6b.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],\"$L9\"],null],null],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$La\"],\"globalErrorComponent\":\"$b\",\"missingSlots\":\"$Wc\"}]\n"])</script><script>self.__next_f.push([1,"d:I[2972,[\"972\",\"static/chunks/972-81dbad6abe39d3fa.js\",\"832\",\"static/chunks/832-2b131d9fe9982edb.js\",\"621\",\"static/chunks/app/%5Bcategory%5D/%5Bslug%5D/page-eb51aa11033a73a2.js\"],\"\"]\ne:I[5546,[\"972\",\"static/chunks/972-81dbad6abe39d3fa.js\",\"832\",\"static/chunks/832-2b131d9fe9982edb.js\",\"621\",\"static/chunks/app/%5Bcategory%5D/%5Bslug%5D/page-eb51aa11033a73a2.js\"],\"default\"]\n10:I[7140,[\"972\",\"static/chunks/972-81dbad6abe39d3fa.js\",\"185\",\"static/chunks/app/layout-f3fa7e3100be56de.js\"],\"default\"]\nf:Ta6ad,"])</script><script>self.__next_f.push([1,"\n# Redis内部数据结构详解\n\n\u003e 理解Redis内部数据结构是掌握Redis性能优化的关键\n\n## 引言\n\nRedis的高性能很大程度上得益于其精心设计的数据结构。Redis不仅提供了丰富的外部数据类型（String、List、Hash、Set、Sorted Set），其内部还使用了多种高效的数据结构来支撑这些外部类型。本文将深入分析Redis内部数据结构的实现原理。\n\n## Redis数据结构概览\n\n### 1. 数据结构层次\n\n**外部数据类型**：\n- String：字符串类型\n- List：列表类型\n- Hash：哈希表类型\n- Set：集合类型\n- Sorted Set：有序集合类型\n\n**内部数据结构**：\n- SDS（Simple Dynamic String）：简单动态字符串\n- LinkedList：双向链表\n- Dict：字典（哈希表）\n- SkipList：跳跃表\n- IntSet：整数集合\n- ZipList：压缩列表\n- QuickList：快速列表\n\n### 2. 数据结构映射关系\n\n```\nString  -\u003e SDS\nList    -\u003e LinkedList / ZipList / QuickList\nHash    -\u003e Dict / ZipList\nSet     -\u003e Dict / IntSet\nSorted Set -\u003e SkipList + Dict / ZipList\n```\n\n## SDS（简单动态字符串）\n\n### 1. SDS结构定义\n\n```c\n// sds.h\nstruct __attribute__ ((__packed__)) sdshdr8 {\n    uint8_t len;        // 已使用长度\n    uint8_t alloc;      // 总容量\n    unsigned char flags; // 标志位，用于标识sdshdr类型\n    char buf[];         // 字符数组\n};\n\nstruct __attribute__ ((__packed__)) sdshdr16 {\n    uint16_t len;       // 已使用长度\n    uint16_t alloc;     // 总容量\n    unsigned char flags; // 标志位\n    char buf[];         // 字符数组\n};\n\nstruct __attribute__ ((__packed__)) sdshdr32 {\n    uint32_t len;       // 已使用长度\n    uint32_t alloc;     // 总容量\n    unsigned char flags; // 标志位\n    char buf[];         // 字符数组\n};\n\nstruct __attribute__ ((__packed__)) sdshdr64 {\n    uint64_t len;       // 已使用长度\n    uint64_t alloc;     // 总容量\n    unsigned char flags; // 标志位\n    char buf[];         // 字符数组\n};\n```\n\n### 2. SDS设计原理详解\n\n**为什么Redis需要自定义字符串结构？**\n\n传统的C字符串存在诸多问题，这些问题在高性能的键值数据库中会被放大：\n\n1. **获取长度效率低下**：C字符串以'\\0'结尾，每次获取长度都需要遍历整个字符串，时间复杂度为O(n)\n2. **缓冲区溢出风险**：字符串拼接操作时，如果预先分配的空间不足，容易导致缓冲区溢出\n3. **内存重分配频繁**：每次字符串增长或缩短都可能涉及内存重新分配，影响性能\n4. **不支持二进制数据**：C字符串无法存储包含'\\0'字符的二进制数据\n\n**SDS的核心设计思想**\n\nSDS通过以下设计解决了上述问题：\n\n- **长度信息存储**：在头部维护len字段，实现O(1)时间复杂度的长度获取\n- **空间预分配策略**：避免频繁的内存重分配，提升性能\n- **惰性空间释放**：缩短字符串时不立即释放内存，为后续增长预留空间\n- **多级长度编码**：根据字符串长度选择合适的头部结构，节省内存\n\n**内存布局优化**\n\nSDS使用了5种不同的头部结构（sdshdr5、sdshdr8、sdshdr16、sdshdr32、sdshdr64），这种设计的巧妙之处在于：\n\n- **小字符串优化**：短字符串使用较小的头部结构，减少内存开销\n- **大字符串支持**：长字符串使用较大的头部结构，支持更大的容量\n- **标志位机制**：通过flags字段快速识别头部类型，提升处理效率\n\n### 3. SDS特性分析\n\n**空间预分配策略详解**：\n```c\n// sds.c\nsds sdsMakeRoomFor(sds s, size_t addlen) {\n    struct sdshdr *sh, *newsh;\n    size_t free = sdsavail(s);\n    size_t len, newlen;\n\n    if (free \u003e= addlen) return s;\n\n    len = sdslen(s);\n    sh = (void*)(s - (sizeof(struct sdshdr)));\n    newlen = (len + addlen);\n\n    // 空间预分配策略\n    if (newlen \u003c SDS_MAX_PREALLOC)\n        newlen *= 2;\n    else\n        newlen += SDS_MAX_PREALLOC;\n\n    newsh = zrealloc(sh, sizeof(struct sdshdr) + newlen + 1);\n    if (newsh == NULL) return NULL;\n\n    newsh-\u003efree = newlen - len;\n    return newsh-\u003ebuf;\n}\n```\n\n**预分配策略的智能之处**：\n\n这段代码体现了Redis在内存分配上的深思熟虑：\n\n1. **双重增长策略**：\n   - 当新长度小于1MB时，直接翻倍（`newlen *= 2`）\n   - 当新长度超过1MB时，额外增加1MB（`newlen += SDS_MAX_PREALLOC`）\n\n2. **性能平衡**：\n   - 小字符串翻倍增长，确保在频繁操作时仍有良好性能\n   - 大字符串线性增长，避免内存浪费\n\n3. **实际效果**：\n   - N次字符串增长操作最多触发O(log N)次内存重分配\n   - 相比每次都重分配，性能提升显著\n\n**惰性空间释放的巧妙设计**：\n```c\nsds sdstrim(sds s, const char *cset) {\n    struct sdshdr *sh = (void*)(s - (sizeof(struct sdshdr)));\n    char *start, *end, *sp, *ep;\n    size_t len;\n\n    sp = s;\n    ep = s + sdslen(s) - 1;\n    start = sp;\n    end = ep;\n\n    // 跳过前置空白字符\n    while(sp \u003c= end \u0026\u0026 strchr(cset, *sp)) sp++;\n\n    // 跳过后置空白字符\n    while(ep \u003e start \u0026\u0026 strchr(cset, *ep)) ep--;\n\n    len = (sp \u003e ep) ? 0 : ((ep - sp) + 1);\n\n    // 移动字符串，但保留空间\n    if (sh-\u003ebuf != sp) memmove(sh-\u003ebuf, sp, len);\n    sh-\u003ebuf[len] = '\\0';\n    sh-\u003efree = sh-\u003ealloc - len;\n    sh-\u003elen = len;\n\n    return s;\n}\n```\n\n**惰性释放的原理和优势**：\n\n1. **延迟释放机制**：\n   - 字符串缩短时不立即归还内存给操作系统\n   - 而是更新free字段，记录可用空间大小\n   - 为后续可能的字符串增长操作预留空间\n\n2. **性能优化效果**：\n   - 避免了\"缩短-增长\"操作模式下的内存重分配\n   - 在Redis中，很多场景下字符串会在缩短后再次增长\n   - 显著减少了系统调用malloc/free的频率\n\n3. **内存管理策略**：\n   - 通过free字段精确跟踪可用空间\n   - 在真正需要释放内存时，可以通过专门的API进行\n   - 平衡了内存使用效率和性能\n\n### 3. SDS与C字符串对比\n\n**优势对比**：\n| 特性 | C字符串 | SDS |\n|------|---------|-----|\n| 获取长度 | O(n) | O(1) |\n| 避免缓冲区溢出 | 容易溢出 | 自动检查扩容 |\n| 减少内存重分配次数 | 每次修改都重分配 | 预分配和惰性释放 |\n| 二进制安全 | 不支持 | 支持 |\n\n## Dict（字典/哈希表）\n\n### 1. 字典结构定义\n\n```c\n// dict.h\ntypedef struct dictEntry {\n    void *key;              // 键\n    union {\n        void *val;          // 值\n        uint64_t u64;       // uint64_t值\n        int64_t s64;        // int64_t值\n        double d;           // double值\n    } v;\n    struct dictEntry *next; // 下一个节点，用于解决哈希冲突\n} dictEntry;\n\ntypedef struct dictType {\n    uint64_t (*hashFunction)(const void *key);  // 哈希函数\n    void *(*keyDup)(void *privdata, const void *key); // 键复制函数\n    void *(*valDup)(void *privdata, const void *obj); // 值复制函数\n    int (*keyCompare)(void *privdata, const void *key1, const void *key2); // 键比较函数\n    void (*keyDestructor)(void *privdata, void *key); // 键销毁函数\n    void (*valDestructor)(void *privdata, void *obj); // 值销毁函数\n} dictType;\n\ntypedef struct dictht {\n    dictEntry **table;      // 哈希表数组\n    unsigned long size;     // 哈希表大小\n    unsigned long sizemask; // 哈希表大小掩码，用于计算索引\n    unsigned long used;     // 已有节点数量\n} dictht;\n\ntypedef struct dict {\n    dictType *type;         // 字典类型\n    void *privdata;         // 私有数据\n    dictht ht[2];           // 两个哈希表，用于rehash\n    long rehashidx;         // rehash进度，-1表示不在rehash\n    int iterators;          // 迭代器数量\n} dict;\n```\n\n### 2. 哈希表设计原理\n\n**Redis字典的核心设计思想**\n\nRedis字典是一个典型的哈希表实现，但其设计中有几个关键的创新点：\n\n1. **双重哈希表机制**：\n   - 维护两个哈希表ht[0]和ht[1]\n   - 平时只使用ht[0]，ht[1]在rehash时使用\n   - 这种设计支持渐进式rehash，避免一次性迁移的性能问题\n\n2. **链地址法解决冲突**：\n   - 每个哈希桶维护一个链表\n   - 发生冲突时，新节点插入到链表头部\n   - 简单高效，且支持动态扩容\n\n3. **动态扩容策略**：\n   - 当负载因子超过阈值时自动扩容\n   - 扩容时哈希表大小通常翻倍到最近的2的幂次\n   - 保证良好的哈希分布\n\n**哈希冲突的处理策略**\n\n```c\n// 插入新节点时的冲突处理逻辑\ndictEntry *dictAddRaw(dict *d, void *key, dictEntry **existing) {\n    int index;\n    dictEntry *entry;\n    dictht *ht;\n\n    // 计算索引位置\n    if ((index = _dictKeyIndex(d, key, dictHashKey(d,key), existing)) == -1)\n        return NULL;\n\n    // 选择哈希表（rehash期间可能使用ht[1]）\n    ht = dictIsRehashing(d) ? \u0026d-\u003eht[1] : \u0026d-\u003eht[0];\n    entry = zmalloc(sizeof(*entry));\n\n    // 使用头插法处理冲突\n    entry-\u003enext = ht-\u003etable[index];\n    ht-\u003etable[index] = entry;\n    ht-\u003eused++;\n\n    // 设置键\n    dictSetKey(d, entry, key);\n    return entry;\n}\n```\n\n### 3. 哈希算法与冲突解决\n\n```c\n// dict.c\n// MurmurHash2哈希算法\nuint64_t dictGenHashFunction(const void *key, int len) {\n    uint64_t seed = 5381;\n    const uint64_t m = 0xc6a4a7935bd1e995;\n    const int r = 47;\n    uint64_t h = seed ^ (len * m);\n    const uint64_t *data = (const uint64_t *)key;\n    const uint64_t *end = data + (len/8);\n\n    while(data != end) {\n        uint64_t k = *data++;\n        k *= m;\n        k ^= k \u003e\u003e r;\n        k *= m;\n        h ^= k;\n        h *= m;\n    }\n\n    switch(len \u0026 7) {\n        case 7: h ^= ((uint64_t)data[6]) \u003c\u003c 48;\n        case 6: h ^= ((uint64_t)data[5]) \u003c\u003c 40;\n        case 5: h ^= ((uint64_t)data[4]) \u003c\u003c 32;\n        case 4: h ^= ((uint64_t)data[3]) \u003c\u003c 24;\n        case 3: h ^= ((uint64_t)data[2]) \u003c\u003c 16;\n        case 2: h ^= ((uint64_t)data[1]) \u003c\u003c 8;\n        case 1: h ^= ((uint64_t)data[0]);\n                h *= m;\n    }\n\n    h ^= h \u003e\u003e r;\n    h *= m;\n    h ^= h \u003e\u003e r;\n    return h;\n}\n\n// 计算索引值\nstatic unsigned int dictKeyIndex(dict *d, const void *key) {\n    unsigned int h, idx, table;\n    dictEntry *he;\n\n    // 计算哈希值\n    h = dictHashKey(d, key);\n\n    // 检查两个哈希表\n    for (table = 0; table \u003c= 1; table++) {\n        idx = h \u0026 d-\u003eht[table].sizemask;\n        he = d-\u003eht[table].table[idx];\n\n        // 检查是否已存在相同key\n        while(he) {\n            if (dictCompareKeys(d, key, he-\u003ekey))\n                return -1;\n            he = he-\u003enext;\n        }\n\n        // 如果不在rehash，只需要检查第一个表\n        if (!dictIsRehashing(d)) break;\n    }\n\n    return idx;\n}\n```\n\n**MurmurHash2算法的优势**\n\nRedis选择MurmurHash2作为哈希算法是有原因的：\n\n1. **优秀的分布特性**：\n   - 能够产生均匀分布的哈希值\n   - 减少哈希冲突的概率\n   - 保证哈希表的负载均衡\n\n2. **高性能计算**：\n   - 基于位运算和乘法运算，计算速度快\n   - 处理8字节块，对现代CPU友好\n   - 比传统的MD5/SHA1等哈希算法快得多\n\n3. **碰撞阻力**：\n   - 良好的雪崩效应，输入微小变化导致输出巨大变化\n   - 适合作为哈希表的哈希函数\n\n**索引计算和冲突处理原理**\n\n1. **索引计算**：\n   - 使用`h \u0026 d-\u003eht[table].sizemask`计算索引\n   - sizemask是size-1，因为哈希表大小总是2的幂次\n   - 位运算比取模运算`h % size`更高效\n\n2. **rehash期间的特殊处理**：\n   - 同时检查两个哈希表，确保数据一致性\n   - 新数据插入到ht[1]，旧数据仍在ht[0]中逐步迁移\n\n### 4. 渐进式Rehash的设计精髓\n\n**为什么需要渐进式Rehash？**\n\n传统的哈希表rehash操作存在性能问题：\n- 一次性迁移所有数据会导致服务阻塞\n- 大数据量的哈希表rehash可能耗时几百毫秒甚至更长时间\n- 这在高并发场景下是不可接受的\n\n**Redis渐进式Rehash的巧妙设计**\n\nRedis通过分批迁移的方式解决了这个问题：\n\n1. **分而治之的思想**：\n   - 将rehash操作分解为多个小步骤\n   - 每次只迁移部分数据，避免长时间阻塞\n   - 在正常操作间隙逐步完成迁移\n\n2. **双表并存策略**：\n   - rehash期间同时维护两个哈希表\n   - 查找操作需要检查两个表\n   - 新增操作只在新表中进行\n\n3. **渐进式迁移触发**：\n   - 字典操作时被动触发单步rehash\n   - 定时任务主动批量rehash\n   - 确保rehash在合理时间内完成\n\n```c\n// 执行单步rehash\nint dictRehash(dict *d, int n) {\n    int empty_visits = n * 10; // 最大访问空槽位数\n\n    if (!dictIsRehashing(d)) return 0;\n\n    while(n-- \u0026\u0026 d-\u003eht[0].used != 0) {\n        dictEntry *de, *nextde;\n\n        // 找到下一个非空槽位\n        while(d-\u003eht[0].table[d-\u003erehashidx] == NULL) {\n            d-\u003erehashidx++;\n            if (--empty_visits == 0) return 1;\n        }\n\n        de = d-\u003eht[0].table[d-\u003erehashidx];\n\n        // 迁移该槽位的所有键值对\n        while(de) {\n            unsigned int h;\n            nextde = de-\u003enext;\n\n            // 计算在新表中的索引\n            h = dictHashKey(d, de-\u003ekey) \u0026 d-\u003eht[1].sizemask;\n\n            // 插入到新表头部\n            de-\u003enext = d-\u003eht[1].table[h];\n            d-\u003eht[1].table[h] = de;\n\n            // 更新计数器\n            d-\u003eht[0].used--;\n            d-\u003eht[1].used++;\n\n            de = nextde;\n        }\n\n        // 释放旧表槽位\n        d-\u003eht[0].table[d-\u003erehashidx] = NULL;\n        d-\u003erehashidx++;\n    }\n\n    // 完成rehash\n    if (d-\u003eht[0].used == 0) {\n        zfree(d-\u003eht[0].table);\n        d-\u003eht[0] = d-\u003eht[1];\n        _dictReset(\u0026d-\u003eht[1]);\n        d-\u003erehashidx = -1;\n        return 0;\n    }\n\n    return 1;\n}\n\n// 定时rehash\nint dictRehashMilliseconds(dict *d, int ms) {\n    long long start = timeInMilliseconds();\n    int rehashes = 0;\n\n    while(dictRehash(d, 100)) {\n        rehashes += 100;\n        if (timeInMilliseconds() - start \u003e ms) break;\n    }\n\n    return rehashes;\n}\n```\n\n**渐进式Rehash的实现细节**\n\n1. **empty_visits机制**：\n   - 防止在稀疏哈希表中无限制地查找空槽位\n   - 最多访问n*10个空槽位后就返回，避免CPU浪费\n   - 在数据分布不均匀的情况下保护性能\n\n2. **rehashidx的作用**：\n   - 记录当前迁移到的槽位索引\n   - 每次迁移从上次的位置继续\n   - 确保迁移过程不重复、不遗漏\n\n3. **批量迁移策略**：\n   - `dictRehashMilliseconds`支持时间控制的批量迁移\n   - 一次最多迁移100个槽位或直到超时\n   - 平衡迁移效率和系统响应性\n\n4. **rehash完成的处理**：\n   - 释放旧表内存，将新表作为主表\n   - 重置rehash状态，恢复正常单表操作\n   - 确保内存使用的高效性\n\n## SkipList（跳跃表）\n\n### 1. 跳跃表结构定义\n\n```c\n// redis.h\ntypedef struct zskiplistNode {\n    sds ele;                     // 成员对象\n    double score;                // 分值\n    struct zskiplistNode *backward; // 后退指针\n    struct zskiplistLevel {\n        struct zskiplistNode *forward; // 前进指针\n        unsigned long span;      // 跨度\n    } level[];                   // 层级数组\n} zskiplistNode;\n\ntypedef struct zskiplist {\n    struct zskiplistNode *header, *tail; // 头尾节点\n    unsigned long length;         // 节点数量\n    int level;                    // 最大层级\n} zskiplist;\n```\n\n### 2. 跳跃表的设计原理\n\n**跳跃表的核心思想**\n\n跳跃表是一种基于概率的有序数据结构，其设计灵感来源于多级索引的概念：\n\n1. **分层结构**：\n   - 底层链表包含所有元素，保持有序\n   - 上层链表是下层链表的\"快速通道\"\n   - 每层元素逐级递减，形成金字塔结构\n\n2. **查找优化**：\n   - 查找时从最高层开始，快速定位到目标区域\n   - 然后逐层下降，最终在底层找到精确位置\n   - 平均时间复杂度为O(log n)\n\n3. **空间换时间**：\n   - 通过增加冗余的索引节点，换取查找性能的提升\n   - 相比平衡树，实现更简单，性能同样优秀\n\n**跳跃表vs平衡树的选择**\n\nRedis在有序集合中选择跳跃表而非平衡树的原因：\n\n1. **实现复杂度**：\n   - 跳跃表实现相对简单，代码易于理解和维护\n   - 平衡树（如红黑树）实现复杂，旋转操作繁琐\n\n2. **性能特点**：\n   - 跳跃表在平均情况下性能优秀\n   - 范围查询操作比平衡树更直观高效\n\n3. **内存局部性**：\n   - 跳跃表的节点在内存中分布更均匀\n   - 缓存命中率相对较高\n\n4. **并发友好**：\n   - 跳跃表的插入删除操作影响范围较小\n   - 更容易实现并发控制\n\n**Redis跳跃表的特殊设计**\n\n```c\ntypedef struct zskiplistNode {\n    sds ele;                     // 成员对象\n    double score;                // 分值\n    struct zskiplistNode *backward; // 后退指针\n    struct zskiplistLevel {\n        struct zskiplistNode *forward; // 前进指针\n        unsigned long span;      // 跨度\n    } level[];                   // 层级数组\n} zskiplistNode;\n```\n\n**Redis跳跃表的创新点**：\n\n1. **后退指针（backward）**：\n   - 支持从后向前的遍历操作\n   - 在ZREVRANGE等命令中很有用\n   - 这是Redis跳跃表的特有设计\n\n2. **跨度（span）字段**：\n   - 记录当前指针到下一个节点的距离\n   - 用于快速计算排名（ZRANK命令）\n   - 使得跳跃表不仅支持范围查询，还支持排名查询\n\n3. **柔性层级数组**：\n   - 使用柔性数组实现可变层数\n   - 节省内存，每个节点只分配需要的层级\n\n### 3. 跳跃表插入操作详解\n\n```c\n// t_zset.c\nzskiplistNode *zslInsert(zskiplist *zsl, double score, sds ele) {\n    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;\n    unsigned int rank[ZSKIPLIST_MAXLEVEL];\n    int i, level;\n\n    // 获取当前最大层级\n    serverAssert(!zslIsInRange(zsl, \u0026range));\n\n    // 从最高层开始查找插入位置\n    x = zsl-\u003eheader;\n    for (i = zsl-\u003elevel-1; i \u003e= 0; i--) {\n        rank[i] = i == (zsl-\u003elevel-1) ? 0 : rank[i+1];\n        while (x-\u003elevel[i].forward \u0026\u0026\n                (x-\u003elevel[i].forward-\u003escore \u003c score ||\n                    (x-\u003elevel[i].forward-\u003escore == score \u0026\u0026\n                    sdscmp(x-\u003elevel[i].forward-\u003eele,ele) \u003c 0))) {\n            rank[i] += x-\u003elevel[i].span;\n            x = x-\u003elevel[i].forward;\n        }\n        update[i] = x;\n    }\n\n    // 随机生成新节点的层数\n    level = zslRandomLevel();\n    if (level \u003e zsl-\u003elevel) {\n        for (i = zsl-\u003elevel; i \u003c level; i++) {\n            rank[i] = 0;\n            update[i] = zsl-\u003eheader;\n            update[i]-\u003elevel[i].span = zsl-\u003elength;\n        }\n        zsl-\u003elevel = level;\n    }\n\n    // 创建新节点\n    x = zslCreateNode(level, score, ele);\n    for (i = 0; i \u003c level; i++) {\n        x-\u003elevel[i].forward = update[i]-\u003elevel[i].forward;\n        update[i]-\u003elevel[i].forward = x;\n\n        x-\u003elevel[i].span = update[i]-\u003elevel[i].span - (rank[0] - rank[i]);\n        update[i]-\u003elevel[i].span = (rank[0] - rank[i]) + 1;\n    }\n\n    // 更新其他层的跨度\n    for (i = level; i \u003c zsl-\u003elevel; i++) {\n        update[i]-\u003elevel[i].span++;\n    }\n\n    x-\u003ebackward = (update[0] == zsl-\u003eheader) ? NULL : update[0];\n    if (x-\u003elevel[0].forward)\n        x-\u003elevel[0].forward-\u003ebackward = x;\n    else\n        zsl-\u003etail = x;\n\n    zsl-\u003elength++;\n    return x;\n}\n\n// 随机生成层数\nint zslRandomLevel(void) {\n    int level = 1;\n    while ((random() \u0026 0xFFFF) \u003c (ZSKIPLIST_P * 0xFFFF))\n        level += 1;\n    return (level \u003c ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;\n}\n```\n\n**插入操作的深度解析**\n\n1. **查找插入位置的策略**：\n   - 使用`update`数组记录每层需要更新的前驱节点\n   - 使用`rank`数组记录每层节点的累计排名\n   - 从高层到低层逐步精确定位插入点\n\n2. **随机层数的生成**：\n   - Redis使用概率P=0.25决定是否增加层级\n   - 期望每个节点出现在第i层的概率为1/4^i\n   - 保证了跳跃表层数的合理分布\n\n3. **跨度（span）的计算逻辑**：\n   - 跨度表示当前节点到下个节点的距离\n   - 插入新节点需要重新计算相关跨度\n   - 支持快速排名查询（ZRANK命令）\n\n4. **后退指针的维护**：\n   - 新节点的backward指向前驱节点\n   - 更新后继节点的backward指针\n   - 支持反向遍历操作\n\n**概率模型的数学基础**\n\n跳跃表的性能依赖于其概率分布：\n- 第1层节点概率：P = 0.25\n- 第2层节点概率：P² = 0.0625\n- 第n层节点概率：P^n\n\n这种指数衰减的分布确保了：\n- 高层级节点稀少，形成高效的\"快速通道\"\n- 空间复杂度控制在O(n)范围内\n- 查找时间复杂度期望为O(log n)\n\n### 4. 跳跃表删除操作原理\n\n```c\nvoid zslDeleteNode(zskiplist *zsl, zskiplistNode *x, zskiplistNode **update) {\n    int i;\n\n    // 更新每一层的指针\n    for (i = 0; i \u003c zsl-\u003elevel; i++) {\n        if (update[i]-\u003elevel[i].forward == x) {\n            update[i]-\u003elevel[i].span += x-\u003elevel[i].span - 1;\n            update[i]-\u003elevel[i].forward = x-\u003elevel[i].forward;\n        } else {\n            update[i]-\u003elevel[i].span -= 1;\n        }\n    }\n\n    // 更新后退指针\n    if (x-\u003elevel[0].forward) {\n        x-\u003elevel[0].forward-\u003ebackward = x-\u003ebackward;\n    } else {\n        zsl-\u003etail = x-\u003ebackward;\n    }\n\n    // 减少层级\n    while(zsl-\u003elevel \u003e 1 \u0026\u0026 zsl-\u003eheader-\u003elevel[zsl-\u003elevel-1].forward == NULL)\n        zsl-\u003elevel--;\n\n    zsl-\u003elength--;\n}\n\nint zslDelete(zskiplist *zsl, double score, sds ele, zskiplistNode **node) {\n    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;\n    int i;\n\n    // 查找删除位置\n    x = zsl-\u003eheader;\n    for (i = zsl-\u003elevel-1; i \u003e= 0; i--) {\n        while (x-\u003elevel[i].forward \u0026\u0026\n                (x-\u003elevel[i].forward-\u003escore \u003c score ||\n                    (x-\u003elevel[i].forward-\u003escore == score \u0026\u0026\n                    sdscmp(x-\u003elevel[i].forward-\u003eele,ele) \u003c 0))) {\n            x = x-\u003elevel[i].forward;\n        }\n        update[i] = x;\n    }\n\n    x = x-\u003elevel[0].forward;\n    if (x \u0026\u0026 score == x-\u003escore \u0026\u0026 sdscmp(x-\u003eele,ele) == 0) {\n        zslDeleteNode(zsl, x, update);\n        if (!node)\n            zslFreeNode(x);\n        else\n            *node = x;\n        return 1;\n    }\n\n    return 0;\n}\n```\n\n**删除操作的关键要点**\n\n1. **跨度的重新计算**：\n   - 只有包含被删除节点的层级需要调整跨度\n   - 其他层级只需将跨度减1\n   - 保持排名查询的正确性\n\n2. **层级收缩机制**：\n   - 当高层级完全为空时，自动减少跳跃表高度\n   - 避免无效的高层级节点浪费空间\n   - 保持跳跃表结构的紧凑性\n\n3. **双向指针维护**：\n   - 更新前驱节点的forward指针\n   - 更新后继节点的backward指针\n   - 维护双向链表的完整性\n\n**跳跃表性能总结**\n\n- **查找复杂度**：O(log n) 平均，O(n) 最坏\n- **插入复杂度**：O(log n) 平均，O(n) 最坏\n- **删除复杂度**：O(log n) 平均，O(n) 最坏\n- **空间复杂度**：O(n)\n- **范围查询**：O(log n + k)，k为结果数量\n\n跳跃表在Redis中为有序集合提供了优秀的性能支持，特别是在需要范围查询和排名查询的场景中表现出色。\n\n## ZipList（压缩列表）\n\n### 1. 压缩列表结构\n\n```\n\u003czlbytes\u003e \u003czltail\u003e \u003czllen\u003e \u003centry\u003e... \u003centry\u003e \u003czlend\u003e\n\n各字段含义：\n- zlbytes: 压缩列表总字节数\n- zltail: 最后一个entry的偏移量\n- zllen: entry的数量\n- entry: 具体的数据项\n- zlend: 压缩列表结束标记，值为255\n```\n\n### 2. ZipList设计思想\n\n**压缩列表的核心价值**\n\nZipList是Redis为小数据集设计的内存优化结构，其设计理念体现了\"极致节省内存\"的追求：\n\n1. **连续内存布局**：\n   - 所有数据存储在一块连续内存中\n   - 避免指针开销和内存碎片\n   - 提高缓存局部性\n\n2. **变长编码优化**：\n   - 根据数据大小选择不同的编码方式\n   - 小整数使用1字节，大整数使用5字节\n   - 字符串长度也采用变长编码\n\n3. **特殊场景优化**：\n   - 针对小Hash、小List、小Sorted Set设计\n   - 当数据量和单元素大小较小时使用\n   - 在内存使用上达到极致优化\n\n**Entry结构的精妙设计**\n\n```\n\u003cprevlen\u003e \u003cencoding\u003e \u003clen\u003e \u003cdata\u003e\n```\n\n1. **prevlen（前驱长度）**：\n   - 记录前一个entry的字节长度\n   - 支持从后向前的遍历操作\n   - 长度本身也采用变长编码（1或5字节）\n\n2. **encoding（编码标识）**：\n   - 高2位标识数据类型（字符串/整数）\n   - 低6位标识长度编码方式\n   - 通过编码减少数据存储开销\n\n3. **变长编码的优势**：\n   - 小数值用少字节，大数值用多字节\n   - 平均每个entry节省2-4字节\n   - 在小数据集中效果显著\n\n### 3. Entry编码细节\n\n**字符串编码方式**：\n```\n00xxxxxx: 6位长度，最大63字节\n01xxxxxx xxxxxxxx: 14位长度，最大16383字节\n10xxxxxx xxxxxxxx xxxxxxxx xxxxxxxx: 22位长度，最大4MB\n11000000: 后续4字节表示长度，最大4GB\n```\n\n**整数编码方式**：\n```\n11000000: int16_t\n11010000: int32_t\n11100000: int64_t\n11110000: 24位有符号整数\n11111110: 8位有符号整数\n11111111: 0\n1111xxxx: 1-13位立即数\n```\n\n**编码选择策略**：\n- 优先选择最紧凑的编码方式\n- 整数优先使用立即数编码\n- 字符串根据长度选择合适的编码\n- 减少内存占用是首要目标\n\n### 4. 压缩列表操作\n\n```c\n// zip_list.h\n#define ZIP_END 255\n#define ZIP_BIGLEN 254\n\n/* encoding */\n#define ZIP_STR_MASK 0xc0\n#define ZIP_STR_06B (0 \u003c\u003c 6)\n#define ZIP_STR_14B (1 \u003c\u003c 6)\n#define ZIP_STR_32B (2 \u003c\u003c 6)\n\n#define ZIP_INT_MASK 0x30\n#define ZIP_INT_16B (0xc0 | 0 \u003c\u003c 4)\n#define ZIP_INT_32B (0xc0 | 1 \u003c\u003c 4)\n#define ZIP_INT_64B (0xc0 | 2 \u003c\u003c 4)\n#define ZIP_INT_24B (0xc0 | 3 \u003c\u003c 4)\n#define ZIP_INT_8B  (0xc0 | 4 \u003c\u003c 4)\n\n// 创建压缩列表\nunsigned char *ziplistNew(void) {\n    unsigned int bytes = ZIPLIST_HEADER_SIZE + 1;\n    unsigned char *zl = zmalloc(bytes);\n    ZIPLIST_BYTES(zl) = bytes;\n    ZIPLIST_TAIL_OFFSET(zl) = ZIPLIST_HEADER_SIZE;\n    ZIPLIST_LENGTH(zl) = 0;\n    zl[bytes-1] = ZIP_END;\n    return zl;\n}\n\n// 插入数据\nunsigned char *ziplistInsert(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen) {\n    return __ziplistInsert(zl, p, s, slen);\n}\n\n// 删除数据\nunsigned char *ziplistDelete(unsigned char *zl, unsigned char **p) {\n    size_t offset = *p - zl;\n    zl = __ziplistDelete(zl, *p, 1);\n    *p = zl + offset;\n    return zl;\n}\n```\n\n**压缩列表操作的核心挑战**\n\n1. **连锁更新问题**：\n   - 插入或删除可能导致后续entry的prevlen字段变化\n   - 当某个entry长度变化超过254字节时，prevlen需要从1字节扩展到5字节\n   - 可能触发连锁反应，导致多个entry需要重新分配\n\n2. **内存重分配策略**：\n   - 插入时需要扩展内存空间\n   - 删除时需要压缩内存空间\n   - 频繁的重分配会影响性能\n\n3. **性能权衡**：\n   - 内存效率：极高的内存利用率\n   - 时间复杂度：插入删除为O(n)，且可能触发连锁更新\n   - 适用场景：小数据量，读多写少\n\n**ZipList的适用边界**\n\n- **内存优势**：相比普通链表节省大量内存\n- **性能劣势**：大数据量时性能下降明显\n- **使用建议**：元素数量\u003c1000，单个元素\u003c64字节\n\n## IntSet（整数集合）\n\n### 1. 整数集合设计原理\n\n**IntSet的核心价值**\n\nIntSet是Redis为纯整数集合设计的优化结构，体现了类型特化设计的优势：\n\n1. **类型特化**：\n   - 专门处理整数数据，不支持其他类型\n   - 针对整数操作进行深度优化\n   - 避免通用数据结构的开销\n\n2. **自动升级机制**：\n   - 根据数据范围自动选择合适的整数类型\n   - int16_t → int32_t → int64_t的渐进式升级\n   - 升级过程保证数据完整性\n\n3. **有序存储**：\n   - 数组按升序排列，支持二分查找\n   - 插入时需要找到合适位置并移动后续元素\n   - 查找效率高，插入效率相对较低\n\n```c\n// intset.h\ntypedef struct intset {\n    uint32_t encoding;  // 编码方式\n    uint32_t length;    // 元素数量\n    int8_t contents[];  // 实际存储元素\n} intset;\n\n/* encoding */\n#define INTSET_ENC_INT16 (sizeof(int16_t))\n#define INTSET_ENC_INT32 (sizeof(int32_t))\n#define INTSET_ENC_INT64 (sizeof(int64_t))\n```\n\n**编码选择策略**\n- int16_t：-32768 到 32767，占用2字节\n- int32_t：-2147483648 到 2147483647，占用4字节\n- int64_t：-9223372036854775808 到 9223372036854775807，占用8字节\n\n### 2. IntSet升级机制详解\n\n```c\n// intset.c\nintset *intsetUpgradeAndAdd(intset *is, int64_t value) {\n    uint8_t curenc = intrev32ifbe(is-\u003eencoding);\n    uint8_t newenc = _intsetValueEncoding(value);\n    int length = intrev32ifbe(is-\u003elength);\n    int prepend = value \u003c 0 ? 1 : 0;\n\n    // 设置新的编码方式\n    is-\u003eencoding = intrev32ifbe(newenc);\n    is-\u003elength = intrev32ifbe(length+1);\n\n    // 根据新编码方式扩展空间\n    is = zrealloc(is, sizeof(intset)+newenc*(length+1));\n\n    // 移动原有数据\n    if (prepend) {\n        memmove(is-\u003econtents+newenc, is-\u003econtents, length*newenc);\n    } else {\n        memmove(is-\u003econtents+newenc*prepend, is-\u003econtents, length*newenc);\n    }\n\n    // 设置新值\n    if (prepend) {\n        _intsetSet(is,0,value);\n    } else {\n        _intsetSet(is,length,value);\n    }\n\n    return is;\n}\n\n// 插入元素\nintset *intsetAdd(intset *is, int64_t value, uint8_t *success) {\n    uint8_t valenc = _intsetValueEncoding(value);\n    uint32_t pos;\n\n    if (success) *success = 1;\n\n    // 如果需要升级\n    if (valenc \u003e intrev32ifbe(is-\u003eencoding)) {\n        return intsetUpgradeAndAdd(is, value);\n    }\n\n    // 检查是否已存在\n    if (intsetSearch(is, value, \u0026pos)) {\n        if (success) *success = 0;\n        return is;\n    }\n\n    // 扩展空间并插入\n    is = intsetResize(is, intrev32ifbe(is-\u003elength)+1);\n    if (pos \u003c intrev32ifbe(is-\u003elength))\n        intsetMoveTail(is, pos, pos+1);\n\n    _intsetSet(is, pos, value);\n    is-\u003elength = intrev32ifbe(intrev32ifbe(is-\u003elength)+1);\n\n    return is;\n}\n```\n\n**升级操作的精妙设计**\n\n1. **升级触发条件**：\n   - 新元素超出当前编码范围时自动触发\n   - 从int16_t升级到int32_t，或从int32_t升级到int64_t\n   - 升级过程一次性完成，保证数据一致性\n\n2. **内存重分配策略**：\n   - 重新分配更大的内存空间\n   - 将原有数据按新的编码格式重新排列\n   - 保持数据的有序性和完整性\n\n3. **插入位置优化**：\n   - 负数插入到数组头部\n   - 正数插入到数组尾部\n   - 利用有序性减少数据移动\n\n**IntSet的性能特征**\n\n- **查找性能**：O(log n)，使用二分查找\n- **插入性能**：O(n)，需要移动元素，可能触发升级\n- **内存效率**：根据数据范围选择最优编码\n- **使用场景**：整数集合，元素数量适中，读多写少\n\n**自动升级的优势与代价**\n\n**优势**：\n- 根据实际数据动态选择最优编码\n- 避免一开始就使用最大类型的浪费\n- 对用户透明，无需手动管理类型\n\n**代价**：\n- 升级操作需要重新分配和复制所有数据\n- 升级过程中的性能开销较大\n- 一旦升级，不会降级，可能浪费内存\n\n## QuickList（快速列表）\n\n### 1. 快速列表结构\n\n```c\n// quicklist.h\ntypedef struct quicklistNode {\n    struct quicklistNode *prev;   // 前一个节点\n    struct quicklistNode *next;   // 后一个节点\n    unsigned char *zl;            // 指向压缩列表\n    unsigned int sz;              // 压缩列表字节数\n    unsigned int count : 16;      // 压缩列表包含的元素数量\n    unsigned int encoding : 2;    // 编码方式\n    unsigned int container : 2;   // 容器类型\n    unsigned int recompress : 1;  // 是否重新压缩\n    unsigned int attempted_compress : 1; // 尝试压缩次数\n    unsigned int extra : 10;      // 预留字段\n} quicklistNode;\n\ntypedef struct quicklistLZF {\n    unsigned int sz;              // 压缩后长度\n    char compressed[];            // 压缩数据\n} quicklistLZF;\n\ntypedef struct quicklist {\n    quicklistNode *head;          // 头节点\n    quicklistNode *tail;          // 尾节点\n    unsigned long count;          // 元素总数\n    unsigned long len;            // 节点数量\n    int fill : 16;                // 填充因子\n    unsigned int compress : 16;   // 压缩深度\n} quicklist;\n```\n\n### 2. QuickList设计动机\n\n**QuickList的诞生背景**\n\nQuickList是Redis 3.2版本引入的新数据结构，旨在解决传统LinkedList在大数据量场景下的性能问题：\n\n1. **传统LinkedList的缺陷**：\n   - 每个节点独立分配内存，内存碎片严重\n   - 指针开销大，每个节点需要额外的prev/next指针\n   - 缓存局部性差，节点在内存中分布分散\n   - 双端操作虽然O(1)，但内存访问效率低\n\n2. **ZipList的局限性**：\n   - 虽然内存效率极高，但大数据量时性能下降\n   - 连锁更新问题在长列表中会被放大\n   - 插入删除操作时间复杂度为O(n)\n\n**QuickList的混合设计思想**\n\nQuickList巧妙地结合了LinkedList和ZipList的优势：\n\n1. **分而治之策略**：\n   - 将长列表切分为多个ZipList节点\n   - 每个ZipList节点控制在合理大小（通常几KB）\n   - 避免单个ZipList过大导致的性能问题\n\n2. **双层结构设计**：\n   - 外层使用双向链表，支持高效的双端操作\n   - 内层使用ZipList，保持高内存利用率\n   - 在性能和内存使用之间找到最佳平衡点\n\n3. **自适应优化**：\n   - 支持压缩策略，对不常用节点进行LZF压缩\n   - 支持动态调整ZipList大小，适应不同使用模式\n   - 提供配置参数，根据业务特点优化\n\n**QuickList的优势分析**\n\n1. **性能优势**：\n   - 双端操作：O(1)时间复杂度，比ZipList的O(n)更优\n   - 中间访问：通过跳转表优化，减少遍历开销\n   - 内存访问：局部性更好，缓存命中率更高\n\n2. **内存优势**：\n   - 相比纯LinkedList，减少50%以上的内存使用\n   - 支持压缩，进一步节省内存空间\n   - 避免了大量小内存分配，减少内存碎片\n\n3. **扩展优势**：\n   - 支持配置化，可根据业务场景调整\n   - 兼容性好，对用户透明\n   - 为后续优化预留了空间\n\n### 3. 快速列表操作详解\n\n```c\n// quicklist.c\nquicklist *quicklistCreate(void) {\n    struct quicklist *quicklist;\n\n    quicklist = zmalloc(sizeof(*quicklist));\n    quicklist-\u003ehead = quicklist-\u003etail = NULL;\n    quicklist-\u003elen = 0;\n    quicklist-\u003ecount = 0;\n    quicklist-\u003ecompress = 0;\n    quicklist-\u003efill = -2;\n    return quicklist;\n}\n\nint quicklistPushHead(quicklist *quicklist, void *value, size_t sz) {\n    quicklistNode *orig_head = quicklist-\u003ehead;\n\n    if (likely(\n            _quicklistNodeAllowInsert(quicklist-\u003ehead, quicklist-\u003efill, sz))) {\n        quicklist-\u003ehead-\u003ezl = ziplistPush(quicklist-\u003ehead-\u003ezl, value, sz, ZIPLIST_HEAD);\n        quicklist-\u003ehead-\u003ecount++;\n    } else {\n        quicklistNode *node = quicklistCreateNode();\n        node-\u003ezl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_HEAD);\n        node-\u003ecount++;\n        _quicklistInsertNodeBefore(quicklist, quicklist-\u003ehead, node);\n    }\n    quicklist-\u003ecount++;\n    return 1;\n}\n```\n\n**QuickList操作的核心策略**\n\n1. **智能插入策略**：\n   - 优先尝试在现有ZipList节点中插入\n   - 当ZipList节点达到容量限制时，创建新节点\n   - 通过`fill`参数控制每个ZipList的最大大小\n\n2. **fill参数的作用**：\n   - 正数：限制每个ZipList的最大元素数量\n   - 负数：限制每个ZipList的最大字节大小\n   - 例如：`-2`表示每个ZipList最大8KB\n\n3. **压缩策略**：\n   - `compress`参数控制压缩深度\n   - 对距离两端较远的节点进行压缩\n   - 平衡内存使用和解压缩开销\n\n**QuickList的性能优化特点**\n\n1. **分批操作优化**：\n   - 避免单个ZipList过大，减少连锁更新的影响\n   - 支持并行操作，不同ZipList节点可独立处理\n   - 提高内存分配和释放的效率\n\n2. **缓存友好设计**：\n   - 相关数据聚集在同一个ZipList中\n   - 减少内存跳跃访问，提高缓存命中率\n   - 适合访问局部性强的场景\n\n3. **动态平衡机制**：\n   - 根据访问模式自动调整压缩策略\n   - 支持节点分裂和合并，保持结构平衡\n   - 在内存使用和访问性能之间动态平衡\n\n**QuickList vs 其他结构的对比**\n\n| 特性 | LinkedList | ZipList | QuickList |\n|------|------------|---------|-----------|\n| 双端操作 | O(1) | O(n) | O(1) |\n| 内存使用 | 高 | 极低 | 中等 |\n| 中间访问 | O(n) | O(n) | O(n/m) |\n| 连锁更新 | 无 | 严重 | 轻微 |\n| 适用场景 | 频繁双端操作 | 小数据集 | 通用场景 |\n\nQuickList成为了Redis List类型的默认实现，它在各种使用场景下都能提供优秀的性能表现。\n\n## 性能分析和优化建议\n\n### 1. 数据结构复杂度分析\n\n| 数据结构 | 时间复杂度 | 空间复杂度 | 适用场景 |\n|----------|------------|------------|----------|\n| SDS | O(1) | O(n) | 字符串操作 |\n| Dict | O(1)平均 | O(n) | 键值对存储 |\n| SkipList | O(log n) | O(n) | 排序集合 |\n| ZipList | O(n) | O(n) | 小数据集合 |\n| IntSet | O(log n) | O(n) | 整数集合 |\n| QuickList | O(n) | O(n) | 列表操作 |\n\n### 2. 内存优化策略\n\n**选择合适的数据结构**：\n```redis\n# 小Hash使用ZipList\n# 当Hash元素数量小于512且每个元素值小于64字节时，使用ZipList\nhash-max-ziplist-entries 512\nhash-max-ziplist-value 64\n\n# 小List使用ZipList\n# 当List元素数量小于512且每个元素值小于64字节时，使用ZipList\nlist-max-ziplist-size -2\n\n# 小Set使用IntSet\n# 当Set元素都是整数且数量小于512时，使用IntSet\nset-max-intset-entries 512\n\n# 小Sorted Set使用ZipList\nzset-max-ziplist-entries 128\nzset-max-ziplist-value 64\n```\n\n### 3. 实际应用场景分析\n\n**场景一：用户会话管理**\n```redis\n# 用户登录信息存储\nHSET session:user123 user_id 123 username \"alice\" login_time 1640995200\n```\n- **数据结构**：Hash（底层：ZipList → Dict）\n- **选择理由**：字段较少时使用ZipList节省内存，字段增多时自动切换到Dict\n- **性能特点**：O(1)的字段访问，内存效率高\n- **最佳实践**：合理设置`hash-max-ziplist-entries`和`hash-max-ziplist-value`\n\n**场景二：计数器和排行榜**\n```redis\n# 文章点赞数\nZADD article:likes 12345 \"article:001\" 9876 \"article:002\" 6543 \"article:003\"\nZREVRANGE article:likes 0 9 WITHSCORES\n```\n- **数据结构**：Sorted Set（底层：ZipList → SkipList + Dict）\n- **选择理由**：需要排序和范围查询，SkipList提供高效支持\n- **性能特点**：O(log n)的插入和查询，O(log n + k)的范围查询\n- **最佳实践**：小集合使用ZipList，大集合自动切换到SkipList\n\n**场景三：消息队列**\n```redis\n# 简单消息队列\nLPUSH queue:tasks '{\"id\":1,\"type\":\"email\",\"data\":\"test@example.com\"}'\nBRPOP queue:tasks 30\n```\n- **数据结构**：List（底层：QuickList）\n- **选择理由**：需要高效的双端操作，QuickList平衡性能和内存\n- **性能特点**：O(1)的入队出队操作，内存使用合理\n- **最佳实践**：调整`list-max-ziplist-size`控制每个ZipList节点大小\n\n**场景四：标签系统**\n```redis\n# 文章标签\nSADD article:123:tags \"redis\" \"database\" \"performance\"\nSINTER article:123:tags article:456:tags\n```\n- **数据结构**：Set（底层：IntSet → Dict）\n- **选择理由**：整数集合使用IntSet，混合数据使用Dict\n- **性能特点**：O(1)的添加和查找，支持集合运算\n- **最佳实践**：纯整数标签利用IntSet的内存优势\n\n### 4. 性能监控和调优\n\n**关键监控指标**\n```bash\n# 查看内存使用情况\nredis-cli info memory | grep used_memory_human\n\n# 查看数据结构信息\nredis-cli memory usage key_name\n\n# 监控数据结构变化\nredis-cli monitor | grep -E \"(SET|HSET|LPUSH|SADD|ZADD)\"\n\n# 查看数据结构统计\nredis-cli info stats | grep keyspace\n```\n\n**内存优化策略**\n\n1. **选择合适的数据结构**：\n   - 根据数据特点选择最合适的类型\n   - 考虑访问模式和操作频率\n   - 平衡内存使用和性能需求\n\n2. **合理配置编码阈值**：\n   ```redis\n   # 针对小数据优化配置\n   hash-max-ziplist-entries 512\n   hash-max-ziplist-value 64\n   list-max-ziplist-size -2\n   set-max-intset-entries 512\n   zset-max-ziplist-entries 128\n   zset-max-ziplist-value 64\n   ```\n\n3. **监控内存使用模式**：\n   - 定期检查大key和热key\n   - 分析内存碎片情况\n   - 根据业务特点调整配置\n\n### 5. 故障诊断指南\n\n**常见问题及解决方案**\n\n1. **内存使用过高**：\n   - 检查是否存在大key\n   - 分析数据结构是否合理\n   - 考虑数据压缩或分片\n\n2. **性能下降**：\n   - 检查是否发生了数据结构编码转换\n   - 分析rehash是否阻塞服务\n   - 优化查询模式和数据分布\n\n3. **延迟问题**：\n   - 监控慢查询日志\n   - 检查网络和硬件状况\n   - 优化数据结构和访问方式\n\n## 总结\n\nRedis的内部数据结构设计体现了高性能和高效率的追求：\n\n1. **SDS**：通过预分配和惰性释放机制优化字符串操作，避免传统C字符串的性能陷阱\n2. **Dict**：采用渐进式rehash和链地址法解决哈希冲突，在大数据量下保持稳定性能\n3. **SkipList**：提供O(log n)的查找性能，同时支持范围查询，是有序集合的理想选择\n4. **ZipList**：通过连续内存存储节省空间，适合小数据集合，但在大数据量时需要谨慎使用\n5. **IntSet**：针对整数集合优化，支持自动升级，在整数场景下性能卓越\n6. **QuickList**：结合链表和ZipList的优势，平衡性能和内存使用，是列表数据的最佳选择\n\n**实践建议**：\n- 深入理解每种数据结构的特性和适用场景\n- 根据业务需求选择合适的数据结构和配置\n- 持续监控性能指标，及时调整优化策略\n- 在设计阶段考虑数据增长趋势和访问模式\n\n理解这些内部数据结构的工作原理，有助于我们更好地使用Redis，选择合适的数据类型，进行性能调优和问题诊断。在实际应用中，应该根据具体场景选择最适合的数据结构，充分发挥Redis的性能优势，构建高效、稳定的应用系统。"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"children\":[[\"$\",\"$Ld\",null,{\"href\":\"/notes\",\"className\":\"back-button\",\"style\":{\"display\":\"inline-block\",\"background\":\"var(--primary-color)\",\"color\":\"white\",\"border\":\"none\",\"padding\":\"10px 20px\",\"borderRadius\":\"6px\",\"cursor\":\"pointer\",\"marginBottom\":\"20px\",\"textDecoration\":\"none\"},\"children\":[\"← 返回\",\"笔记\",\"列表\"]}],[\"$\",\"article\",null,{\"className\":\"section\",\"children\":[[\"$\",\"header\",null,{\"className\":\"article-header\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"article-title\",\"children\":\"Redis内部数据结构详解\"}],[\"$\",\"div\",null,{\"className\":\"article-meta\",\"children\":[\"$\",\"div\",null,{\"className\":\"article-tags\",\"children\":[[\"$\",\"span\",\"Redis\",{\"className\":\"tag\",\"children\":\"Redis\"}],[\"$\",\"span\",\"数据结构\",{\"className\":\"tag\",\"children\":\"数据结构\"}],[\"$\",\"span\",\"源码分析\",{\"className\":\"tag\",\"children\":\"源码分析\"}],[\"$\",\"span\",\"算法\",{\"className\":\"tag\",\"children\":\"算法\"}],[\"$\",\"span\",\"底层实现\",{\"className\":\"tag\",\"children\":\"底层实现\"}]]}]}]]}],[\"$\",\"div\",null,{\"className\":\"card markdown-content\",\"children\":[\"$\",\"$Le\",null,{\"content\":\"$f\"}]}]]}]]}]\n"])</script><script>self.__next_f.push([1,"9:[\"$\",\"html\",null,{\"lang\":\"zh-CN\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"link\",null,{\"rel\":\"stylesheet\",\"href\":\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css\"}],[\"$\",\"link\",null,{\"rel\":\"stylesheet\",\"href\":\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css\"}],[\"$\",\"script\",null,{\"src\":\"https://cdn.jsdelivr.net/npm/mermaid@10.9.1/dist/mermaid.min.js\",\"async\":true}],[\"$\",\"script\",null,{\"src\":\"https://unpkg.com/markmap-autoloader@0.17.2\"}]]}],[\"$\",\"body\",null,{\"children\":[\"$\",\"div\",null,{\"className\":\"app\",\"children\":[[\"$\",\"$L10\",null,{\"siteConfig\":{\"name\":\"海元\",\"bio\":\"JAVA | AI | WEB3\",\"social\":[{\"name\":\"github\",\"icon\":\"fab fa-github\",\"url\":\"https://github.com/suogongy\"},{\"name\":\"twitter\",\"icon\":\"fab fa-twitter\",\"url\":\"https://twitter.com/suogongy\"},{\"name\":\"email\",\"icon\":\"fas fa-envelope\",\"url\":\"mailto:haiyuan1832@163.com\"}]}}],[\"$\",\"main\",null,{\"className\":\"main-content\",\"children\":[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"Redis内部数据结构详解 - Personal GitHub Page\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"深入剖析Redis内部数据结构的实现原理，包括简单动态字符串、链表、字典、跳跃表、整数集合、压缩列表等核心数据结构的详细解析。\"}]]\n3:null\n"])</script></body></html>