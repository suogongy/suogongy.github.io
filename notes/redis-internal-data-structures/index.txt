3:I[4707,[],""]
6:I[6423,[],""]
4:["category","notes","d"]
5:["slug","redis-internal-data-structures","d"]
0:["build",[[["",{"children":[["category","notes","d"],{"children":[["slug","redis-internal-data-structures","d"],{"children":["__PAGE__?{\"category\":\"notes\",\"slug\":\"redis-internal-data-structures\"}",{}]}]}]},"$undefined","$undefined",true],["",{"children":[["category","notes","d"],{"children":[["slug","redis-internal-data-structures","d"],{"children":["__PAGE__",{},[["$L1","$L2",null],null],null]},[null,["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","$4","children","$5","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L6",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined"}]],null]},[null,["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","$4","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L6",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined"}]],null]},[[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/7805da002e48e736.css","precedence":"next","crossOrigin":"$undefined"}]],"$L7"],null],null],["$L8",null]]]]
9:I[2972,["972","static/chunks/972-81dbad6abe39d3fa.js","832","static/chunks/832-7ea2624e20755f9f.js","621","static/chunks/app/%5Bcategory%5D/%5Bslug%5D/page-e466df95e55c7602.js"],""]
a:I[2024,["972","static/chunks/972-81dbad6abe39d3fa.js","832","static/chunks/832-7ea2624e20755f9f.js","621","static/chunks/app/%5Bcategory%5D/%5Bslug%5D/page-e466df95e55c7602.js"],"default"]
c:I[7140,["972","static/chunks/972-81dbad6abe39d3fa.js","185","static/chunks/app/layout-f3fa7e3100be56de.js"],"default"]
b:Ta6ad,
# Redis内部数据结构详解

> 理解Redis内部数据结构是掌握Redis性能优化的关键

## 引言

Redis的高性能很大程度上得益于其精心设计的数据结构。Redis不仅提供了丰富的外部数据类型（String、List、Hash、Set、Sorted Set），其内部还使用了多种高效的数据结构来支撑这些外部类型。本文将深入分析Redis内部数据结构的实现原理。

## Redis数据结构概览

### 1. 数据结构层次

**外部数据类型**：
- String：字符串类型
- List：列表类型
- Hash：哈希表类型
- Set：集合类型
- Sorted Set：有序集合类型

**内部数据结构**：
- SDS（Simple Dynamic String）：简单动态字符串
- LinkedList：双向链表
- Dict：字典（哈希表）
- SkipList：跳跃表
- IntSet：整数集合
- ZipList：压缩列表
- QuickList：快速列表

### 2. 数据结构映射关系

```
String  -> SDS
List    -> LinkedList / ZipList / QuickList
Hash    -> Dict / ZipList
Set     -> Dict / IntSet
Sorted Set -> SkipList + Dict / ZipList
```

## SDS（简单动态字符串）

### 1. SDS结构定义

```c
// sds.h
struct __attribute__ ((__packed__)) sdshdr8 {
    uint8_t len;        // 已使用长度
    uint8_t alloc;      // 总容量
    unsigned char flags; // 标志位，用于标识sdshdr类型
    char buf[];         // 字符数组
};

struct __attribute__ ((__packed__)) sdshdr16 {
    uint16_t len;       // 已使用长度
    uint16_t alloc;     // 总容量
    unsigned char flags; // 标志位
    char buf[];         // 字符数组
};

struct __attribute__ ((__packed__)) sdshdr32 {
    uint32_t len;       // 已使用长度
    uint32_t alloc;     // 总容量
    unsigned char flags; // 标志位
    char buf[];         // 字符数组
};

struct __attribute__ ((__packed__)) sdshdr64 {
    uint64_t len;       // 已使用长度
    uint64_t alloc;     // 总容量
    unsigned char flags; // 标志位
    char buf[];         // 字符数组
};
```

### 2. SDS设计原理详解

**为什么Redis需要自定义字符串结构？**

传统的C字符串存在诸多问题，这些问题在高性能的键值数据库中会被放大：

1. **获取长度效率低下**：C字符串以'\0'结尾，每次获取长度都需要遍历整个字符串，时间复杂度为O(n)
2. **缓冲区溢出风险**：字符串拼接操作时，如果预先分配的空间不足，容易导致缓冲区溢出
3. **内存重分配频繁**：每次字符串增长或缩短都可能涉及内存重新分配，影响性能
4. **不支持二进制数据**：C字符串无法存储包含'\0'字符的二进制数据

**SDS的核心设计思想**

SDS通过以下设计解决了上述问题：

- **长度信息存储**：在头部维护len字段，实现O(1)时间复杂度的长度获取
- **空间预分配策略**：避免频繁的内存重分配，提升性能
- **惰性空间释放**：缩短字符串时不立即释放内存，为后续增长预留空间
- **多级长度编码**：根据字符串长度选择合适的头部结构，节省内存

**内存布局优化**

SDS使用了5种不同的头部结构（sdshdr5、sdshdr8、sdshdr16、sdshdr32、sdshdr64），这种设计的巧妙之处在于：

- **小字符串优化**：短字符串使用较小的头部结构，减少内存开销
- **大字符串支持**：长字符串使用较大的头部结构，支持更大的容量
- **标志位机制**：通过flags字段快速识别头部类型，提升处理效率

### 3. SDS特性分析

**空间预分配策略详解**：
```c
// sds.c
sds sdsMakeRoomFor(sds s, size_t addlen) {
    struct sdshdr *sh, *newsh;
    size_t free = sdsavail(s);
    size_t len, newlen;

    if (free >= addlen) return s;

    len = sdslen(s);
    sh = (void*)(s - (sizeof(struct sdshdr)));
    newlen = (len + addlen);

    // 空间预分配策略
    if (newlen < SDS_MAX_PREALLOC)
        newlen *= 2;
    else
        newlen += SDS_MAX_PREALLOC;

    newsh = zrealloc(sh, sizeof(struct sdshdr) + newlen + 1);
    if (newsh == NULL) return NULL;

    newsh->free = newlen - len;
    return newsh->buf;
}
```

**预分配策略的智能之处**：

这段代码体现了Redis在内存分配上的深思熟虑：

1. **双重增长策略**：
   - 当新长度小于1MB时，直接翻倍（`newlen *= 2`）
   - 当新长度超过1MB时，额外增加1MB（`newlen += SDS_MAX_PREALLOC`）

2. **性能平衡**：
   - 小字符串翻倍增长，确保在频繁操作时仍有良好性能
   - 大字符串线性增长，避免内存浪费

3. **实际效果**：
   - N次字符串增长操作最多触发O(log N)次内存重分配
   - 相比每次都重分配，性能提升显著

**惰性空间释放的巧妙设计**：
```c
sds sdstrim(sds s, const char *cset) {
    struct sdshdr *sh = (void*)(s - (sizeof(struct sdshdr)));
    char *start, *end, *sp, *ep;
    size_t len;

    sp = s;
    ep = s + sdslen(s) - 1;
    start = sp;
    end = ep;

    // 跳过前置空白字符
    while(sp <= end && strchr(cset, *sp)) sp++;

    // 跳过后置空白字符
    while(ep > start && strchr(cset, *ep)) ep--;

    len = (sp > ep) ? 0 : ((ep - sp) + 1);

    // 移动字符串，但保留空间
    if (sh->buf != sp) memmove(sh->buf, sp, len);
    sh->buf[len] = '\0';
    sh->free = sh->alloc - len;
    sh->len = len;

    return s;
}
```

**惰性释放的原理和优势**：

1. **延迟释放机制**：
   - 字符串缩短时不立即归还内存给操作系统
   - 而是更新free字段，记录可用空间大小
   - 为后续可能的字符串增长操作预留空间

2. **性能优化效果**：
   - 避免了"缩短-增长"操作模式下的内存重分配
   - 在Redis中，很多场景下字符串会在缩短后再次增长
   - 显著减少了系统调用malloc/free的频率

3. **内存管理策略**：
   - 通过free字段精确跟踪可用空间
   - 在真正需要释放内存时，可以通过专门的API进行
   - 平衡了内存使用效率和性能

### 3. SDS与C字符串对比

**优势对比**：
| 特性 | C字符串 | SDS |
|------|---------|-----|
| 获取长度 | O(n) | O(1) |
| 避免缓冲区溢出 | 容易溢出 | 自动检查扩容 |
| 减少内存重分配次数 | 每次修改都重分配 | 预分配和惰性释放 |
| 二进制安全 | 不支持 | 支持 |

## Dict（字典/哈希表）

### 1. 字典结构定义

```c
// dict.h
typedef struct dictEntry {
    void *key;              // 键
    union {
        void *val;          // 值
        uint64_t u64;       // uint64_t值
        int64_t s64;        // int64_t值
        double d;           // double值
    } v;
    struct dictEntry *next; // 下一个节点，用于解决哈希冲突
} dictEntry;

typedef struct dictType {
    uint64_t (*hashFunction)(const void *key);  // 哈希函数
    void *(*keyDup)(void *privdata, const void *key); // 键复制函数
    void *(*valDup)(void *privdata, const void *obj); // 值复制函数
    int (*keyCompare)(void *privdata, const void *key1, const void *key2); // 键比较函数
    void (*keyDestructor)(void *privdata, void *key); // 键销毁函数
    void (*valDestructor)(void *privdata, void *obj); // 值销毁函数
} dictType;

typedef struct dictht {
    dictEntry **table;      // 哈希表数组
    unsigned long size;     // 哈希表大小
    unsigned long sizemask; // 哈希表大小掩码，用于计算索引
    unsigned long used;     // 已有节点数量
} dictht;

typedef struct dict {
    dictType *type;         // 字典类型
    void *privdata;         // 私有数据
    dictht ht[2];           // 两个哈希表，用于rehash
    long rehashidx;         // rehash进度，-1表示不在rehash
    int iterators;          // 迭代器数量
} dict;
```

### 2. 哈希表设计原理

**Redis字典的核心设计思想**

Redis字典是一个典型的哈希表实现，但其设计中有几个关键的创新点：

1. **双重哈希表机制**：
   - 维护两个哈希表ht[0]和ht[1]
   - 平时只使用ht[0]，ht[1]在rehash时使用
   - 这种设计支持渐进式rehash，避免一次性迁移的性能问题

2. **链地址法解决冲突**：
   - 每个哈希桶维护一个链表
   - 发生冲突时，新节点插入到链表头部
   - 简单高效，且支持动态扩容

3. **动态扩容策略**：
   - 当负载因子超过阈值时自动扩容
   - 扩容时哈希表大小通常翻倍到最近的2的幂次
   - 保证良好的哈希分布

**哈希冲突的处理策略**

```c
// 插入新节点时的冲突处理逻辑
dictEntry *dictAddRaw(dict *d, void *key, dictEntry **existing) {
    int index;
    dictEntry *entry;
    dictht *ht;

    // 计算索引位置
    if ((index = _dictKeyIndex(d, key, dictHashKey(d,key), existing)) == -1)
        return NULL;

    // 选择哈希表（rehash期间可能使用ht[1]）
    ht = dictIsRehashing(d) ? &d->ht[1] : &d->ht[0];
    entry = zmalloc(sizeof(*entry));

    // 使用头插法处理冲突
    entry->next = ht->table[index];
    ht->table[index] = entry;
    ht->used++;

    // 设置键
    dictSetKey(d, entry, key);
    return entry;
}
```

### 3. 哈希算法与冲突解决

```c
// dict.c
// MurmurHash2哈希算法
uint64_t dictGenHashFunction(const void *key, int len) {
    uint64_t seed = 5381;
    const uint64_t m = 0xc6a4a7935bd1e995;
    const int r = 47;
    uint64_t h = seed ^ (len * m);
    const uint64_t *data = (const uint64_t *)key;
    const uint64_t *end = data + (len/8);

    while(data != end) {
        uint64_t k = *data++;
        k *= m;
        k ^= k >> r;
        k *= m;
        h ^= k;
        h *= m;
    }

    switch(len & 7) {
        case 7: h ^= ((uint64_t)data[6]) << 48;
        case 6: h ^= ((uint64_t)data[5]) << 40;
        case 5: h ^= ((uint64_t)data[4]) << 32;
        case 4: h ^= ((uint64_t)data[3]) << 24;
        case 3: h ^= ((uint64_t)data[2]) << 16;
        case 2: h ^= ((uint64_t)data[1]) << 8;
        case 1: h ^= ((uint64_t)data[0]);
                h *= m;
    }

    h ^= h >> r;
    h *= m;
    h ^= h >> r;
    return h;
}

// 计算索引值
static unsigned int dictKeyIndex(dict *d, const void *key) {
    unsigned int h, idx, table;
    dictEntry *he;

    // 计算哈希值
    h = dictHashKey(d, key);

    // 检查两个哈希表
    for (table = 0; table <= 1; table++) {
        idx = h & d->ht[table].sizemask;
        he = d->ht[table].table[idx];

        // 检查是否已存在相同key
        while(he) {
            if (dictCompareKeys(d, key, he->key))
                return -1;
            he = he->next;
        }

        // 如果不在rehash，只需要检查第一个表
        if (!dictIsRehashing(d)) break;
    }

    return idx;
}
```

**MurmurHash2算法的优势**

Redis选择MurmurHash2作为哈希算法是有原因的：

1. **优秀的分布特性**：
   - 能够产生均匀分布的哈希值
   - 减少哈希冲突的概率
   - 保证哈希表的负载均衡

2. **高性能计算**：
   - 基于位运算和乘法运算，计算速度快
   - 处理8字节块，对现代CPU友好
   - 比传统的MD5/SHA1等哈希算法快得多

3. **碰撞阻力**：
   - 良好的雪崩效应，输入微小变化导致输出巨大变化
   - 适合作为哈希表的哈希函数

**索引计算和冲突处理原理**

1. **索引计算**：
   - 使用`h & d->ht[table].sizemask`计算索引
   - sizemask是size-1，因为哈希表大小总是2的幂次
   - 位运算比取模运算`h % size`更高效

2. **rehash期间的特殊处理**：
   - 同时检查两个哈希表，确保数据一致性
   - 新数据插入到ht[1]，旧数据仍在ht[0]中逐步迁移

### 4. 渐进式Rehash的设计精髓

**为什么需要渐进式Rehash？**

传统的哈希表rehash操作存在性能问题：
- 一次性迁移所有数据会导致服务阻塞
- 大数据量的哈希表rehash可能耗时几百毫秒甚至更长时间
- 这在高并发场景下是不可接受的

**Redis渐进式Rehash的巧妙设计**

Redis通过分批迁移的方式解决了这个问题：

1. **分而治之的思想**：
   - 将rehash操作分解为多个小步骤
   - 每次只迁移部分数据，避免长时间阻塞
   - 在正常操作间隙逐步完成迁移

2. **双表并存策略**：
   - rehash期间同时维护两个哈希表
   - 查找操作需要检查两个表
   - 新增操作只在新表中进行

3. **渐进式迁移触发**：
   - 字典操作时被动触发单步rehash
   - 定时任务主动批量rehash
   - 确保rehash在合理时间内完成

```c
// 执行单步rehash
int dictRehash(dict *d, int n) {
    int empty_visits = n * 10; // 最大访问空槽位数

    if (!dictIsRehashing(d)) return 0;

    while(n-- && d->ht[0].used != 0) {
        dictEntry *de, *nextde;

        // 找到下一个非空槽位
        while(d->ht[0].table[d->rehashidx] == NULL) {
            d->rehashidx++;
            if (--empty_visits == 0) return 1;
        }

        de = d->ht[0].table[d->rehashidx];

        // 迁移该槽位的所有键值对
        while(de) {
            unsigned int h;
            nextde = de->next;

            // 计算在新表中的索引
            h = dictHashKey(d, de->key) & d->ht[1].sizemask;

            // 插入到新表头部
            de->next = d->ht[1].table[h];
            d->ht[1].table[h] = de;

            // 更新计数器
            d->ht[0].used--;
            d->ht[1].used++;

            de = nextde;
        }

        // 释放旧表槽位
        d->ht[0].table[d->rehashidx] = NULL;
        d->rehashidx++;
    }

    // 完成rehash
    if (d->ht[0].used == 0) {
        zfree(d->ht[0].table);
        d->ht[0] = d->ht[1];
        _dictReset(&d->ht[1]);
        d->rehashidx = -1;
        return 0;
    }

    return 1;
}

// 定时rehash
int dictRehashMilliseconds(dict *d, int ms) {
    long long start = timeInMilliseconds();
    int rehashes = 0;

    while(dictRehash(d, 100)) {
        rehashes += 100;
        if (timeInMilliseconds() - start > ms) break;
    }

    return rehashes;
}
```

**渐进式Rehash的实现细节**

1. **empty_visits机制**：
   - 防止在稀疏哈希表中无限制地查找空槽位
   - 最多访问n*10个空槽位后就返回，避免CPU浪费
   - 在数据分布不均匀的情况下保护性能

2. **rehashidx的作用**：
   - 记录当前迁移到的槽位索引
   - 每次迁移从上次的位置继续
   - 确保迁移过程不重复、不遗漏

3. **批量迁移策略**：
   - `dictRehashMilliseconds`支持时间控制的批量迁移
   - 一次最多迁移100个槽位或直到超时
   - 平衡迁移效率和系统响应性

4. **rehash完成的处理**：
   - 释放旧表内存，将新表作为主表
   - 重置rehash状态，恢复正常单表操作
   - 确保内存使用的高效性

## SkipList（跳跃表）

### 1. 跳跃表结构定义

```c
// redis.h
typedef struct zskiplistNode {
    sds ele;                     // 成员对象
    double score;                // 分值
    struct zskiplistNode *backward; // 后退指针
    struct zskiplistLevel {
        struct zskiplistNode *forward; // 前进指针
        unsigned long span;      // 跨度
    } level[];                   // 层级数组
} zskiplistNode;

typedef struct zskiplist {
    struct zskiplistNode *header, *tail; // 头尾节点
    unsigned long length;         // 节点数量
    int level;                    // 最大层级
} zskiplist;
```

### 2. 跳跃表的设计原理

**跳跃表的核心思想**

跳跃表是一种基于概率的有序数据结构，其设计灵感来源于多级索引的概念：

1. **分层结构**：
   - 底层链表包含所有元素，保持有序
   - 上层链表是下层链表的"快速通道"
   - 每层元素逐级递减，形成金字塔结构

2. **查找优化**：
   - 查找时从最高层开始，快速定位到目标区域
   - 然后逐层下降，最终在底层找到精确位置
   - 平均时间复杂度为O(log n)

3. **空间换时间**：
   - 通过增加冗余的索引节点，换取查找性能的提升
   - 相比平衡树，实现更简单，性能同样优秀

**跳跃表vs平衡树的选择**

Redis在有序集合中选择跳跃表而非平衡树的原因：

1. **实现复杂度**：
   - 跳跃表实现相对简单，代码易于理解和维护
   - 平衡树（如红黑树）实现复杂，旋转操作繁琐

2. **性能特点**：
   - 跳跃表在平均情况下性能优秀
   - 范围查询操作比平衡树更直观高效

3. **内存局部性**：
   - 跳跃表的节点在内存中分布更均匀
   - 缓存命中率相对较高

4. **并发友好**：
   - 跳跃表的插入删除操作影响范围较小
   - 更容易实现并发控制

**Redis跳跃表的特殊设计**

```c
typedef struct zskiplistNode {
    sds ele;                     // 成员对象
    double score;                // 分值
    struct zskiplistNode *backward; // 后退指针
    struct zskiplistLevel {
        struct zskiplistNode *forward; // 前进指针
        unsigned long span;      // 跨度
    } level[];                   // 层级数组
} zskiplistNode;
```

**Redis跳跃表的创新点**：

1. **后退指针（backward）**：
   - 支持从后向前的遍历操作
   - 在ZREVRANGE等命令中很有用
   - 这是Redis跳跃表的特有设计

2. **跨度（span）字段**：
   - 记录当前指针到下一个节点的距离
   - 用于快速计算排名（ZRANK命令）
   - 使得跳跃表不仅支持范围查询，还支持排名查询

3. **柔性层级数组**：
   - 使用柔性数组实现可变层数
   - 节省内存，每个节点只分配需要的层级

### 3. 跳跃表插入操作详解

```c
// t_zset.c
zskiplistNode *zslInsert(zskiplist *zsl, double score, sds ele) {
    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
    unsigned int rank[ZSKIPLIST_MAXLEVEL];
    int i, level;

    // 获取当前最大层级
    serverAssert(!zslIsInRange(zsl, &range));

    // 从最高层开始查找插入位置
    x = zsl->header;
    for (i = zsl->level-1; i >= 0; i--) {
        rank[i] = i == (zsl->level-1) ? 0 : rank[i+1];
        while (x->level[i].forward &&
                (x->level[i].forward->score < score ||
                    (x->level[i].forward->score == score &&
                    sdscmp(x->level[i].forward->ele,ele) < 0))) {
            rank[i] += x->level[i].span;
            x = x->level[i].forward;
        }
        update[i] = x;
    }

    // 随机生成新节点的层数
    level = zslRandomLevel();
    if (level > zsl->level) {
        for (i = zsl->level; i < level; i++) {
            rank[i] = 0;
            update[i] = zsl->header;
            update[i]->level[i].span = zsl->length;
        }
        zsl->level = level;
    }

    // 创建新节点
    x = zslCreateNode(level, score, ele);
    for (i = 0; i < level; i++) {
        x->level[i].forward = update[i]->level[i].forward;
        update[i]->level[i].forward = x;

        x->level[i].span = update[i]->level[i].span - (rank[0] - rank[i]);
        update[i]->level[i].span = (rank[0] - rank[i]) + 1;
    }

    // 更新其他层的跨度
    for (i = level; i < zsl->level; i++) {
        update[i]->level[i].span++;
    }

    x->backward = (update[0] == zsl->header) ? NULL : update[0];
    if (x->level[0].forward)
        x->level[0].forward->backward = x;
    else
        zsl->tail = x;

    zsl->length++;
    return x;
}

// 随机生成层数
int zslRandomLevel(void) {
    int level = 1;
    while ((random() & 0xFFFF) < (ZSKIPLIST_P * 0xFFFF))
        level += 1;
    return (level < ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;
}
```

**插入操作的深度解析**

1. **查找插入位置的策略**：
   - 使用`update`数组记录每层需要更新的前驱节点
   - 使用`rank`数组记录每层节点的累计排名
   - 从高层到低层逐步精确定位插入点

2. **随机层数的生成**：
   - Redis使用概率P=0.25决定是否增加层级
   - 期望每个节点出现在第i层的概率为1/4^i
   - 保证了跳跃表层数的合理分布

3. **跨度（span）的计算逻辑**：
   - 跨度表示当前节点到下个节点的距离
   - 插入新节点需要重新计算相关跨度
   - 支持快速排名查询（ZRANK命令）

4. **后退指针的维护**：
   - 新节点的backward指向前驱节点
   - 更新后继节点的backward指针
   - 支持反向遍历操作

**概率模型的数学基础**

跳跃表的性能依赖于其概率分布：
- 第1层节点概率：P = 0.25
- 第2层节点概率：P² = 0.0625
- 第n层节点概率：P^n

这种指数衰减的分布确保了：
- 高层级节点稀少，形成高效的"快速通道"
- 空间复杂度控制在O(n)范围内
- 查找时间复杂度期望为O(log n)

### 4. 跳跃表删除操作原理

```c
void zslDeleteNode(zskiplist *zsl, zskiplistNode *x, zskiplistNode **update) {
    int i;

    // 更新每一层的指针
    for (i = 0; i < zsl->level; i++) {
        if (update[i]->level[i].forward == x) {
            update[i]->level[i].span += x->level[i].span - 1;
            update[i]->level[i].forward = x->level[i].forward;
        } else {
            update[i]->level[i].span -= 1;
        }
    }

    // 更新后退指针
    if (x->level[0].forward) {
        x->level[0].forward->backward = x->backward;
    } else {
        zsl->tail = x->backward;
    }

    // 减少层级
    while(zsl->level > 1 && zsl->header->level[zsl->level-1].forward == NULL)
        zsl->level--;

    zsl->length--;
}

int zslDelete(zskiplist *zsl, double score, sds ele, zskiplistNode **node) {
    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
    int i;

    // 查找删除位置
    x = zsl->header;
    for (i = zsl->level-1; i >= 0; i--) {
        while (x->level[i].forward &&
                (x->level[i].forward->score < score ||
                    (x->level[i].forward->score == score &&
                    sdscmp(x->level[i].forward->ele,ele) < 0))) {
            x = x->level[i].forward;
        }
        update[i] = x;
    }

    x = x->level[0].forward;
    if (x && score == x->score && sdscmp(x->ele,ele) == 0) {
        zslDeleteNode(zsl, x, update);
        if (!node)
            zslFreeNode(x);
        else
            *node = x;
        return 1;
    }

    return 0;
}
```

**删除操作的关键要点**

1. **跨度的重新计算**：
   - 只有包含被删除节点的层级需要调整跨度
   - 其他层级只需将跨度减1
   - 保持排名查询的正确性

2. **层级收缩机制**：
   - 当高层级完全为空时，自动减少跳跃表高度
   - 避免无效的高层级节点浪费空间
   - 保持跳跃表结构的紧凑性

3. **双向指针维护**：
   - 更新前驱节点的forward指针
   - 更新后继节点的backward指针
   - 维护双向链表的完整性

**跳跃表性能总结**

- **查找复杂度**：O(log n) 平均，O(n) 最坏
- **插入复杂度**：O(log n) 平均，O(n) 最坏
- **删除复杂度**：O(log n) 平均，O(n) 最坏
- **空间复杂度**：O(n)
- **范围查询**：O(log n + k)，k为结果数量

跳跃表在Redis中为有序集合提供了优秀的性能支持，特别是在需要范围查询和排名查询的场景中表现出色。

## ZipList（压缩列表）

### 1. 压缩列表结构

```
<zlbytes> <zltail> <zllen> <entry>... <entry> <zlend>

各字段含义：
- zlbytes: 压缩列表总字节数
- zltail: 最后一个entry的偏移量
- zllen: entry的数量
- entry: 具体的数据项
- zlend: 压缩列表结束标记，值为255
```

### 2. ZipList设计思想

**压缩列表的核心价值**

ZipList是Redis为小数据集设计的内存优化结构，其设计理念体现了"极致节省内存"的追求：

1. **连续内存布局**：
   - 所有数据存储在一块连续内存中
   - 避免指针开销和内存碎片
   - 提高缓存局部性

2. **变长编码优化**：
   - 根据数据大小选择不同的编码方式
   - 小整数使用1字节，大整数使用5字节
   - 字符串长度也采用变长编码

3. **特殊场景优化**：
   - 针对小Hash、小List、小Sorted Set设计
   - 当数据量和单元素大小较小时使用
   - 在内存使用上达到极致优化

**Entry结构的精妙设计**

```
<prevlen> <encoding> <len> <data>
```

1. **prevlen（前驱长度）**：
   - 记录前一个entry的字节长度
   - 支持从后向前的遍历操作
   - 长度本身也采用变长编码（1或5字节）

2. **encoding（编码标识）**：
   - 高2位标识数据类型（字符串/整数）
   - 低6位标识长度编码方式
   - 通过编码减少数据存储开销

3. **变长编码的优势**：
   - 小数值用少字节，大数值用多字节
   - 平均每个entry节省2-4字节
   - 在小数据集中效果显著

### 3. Entry编码细节

**字符串编码方式**：
```
00xxxxxx: 6位长度，最大63字节
01xxxxxx xxxxxxxx: 14位长度，最大16383字节
10xxxxxx xxxxxxxx xxxxxxxx xxxxxxxx: 22位长度，最大4MB
11000000: 后续4字节表示长度，最大4GB
```

**整数编码方式**：
```
11000000: int16_t
11010000: int32_t
11100000: int64_t
11110000: 24位有符号整数
11111110: 8位有符号整数
11111111: 0
1111xxxx: 1-13位立即数
```

**编码选择策略**：
- 优先选择最紧凑的编码方式
- 整数优先使用立即数编码
- 字符串根据长度选择合适的编码
- 减少内存占用是首要目标

### 4. 压缩列表操作

```c
// zip_list.h
#define ZIP_END 255
#define ZIP_BIGLEN 254

/* encoding */
#define ZIP_STR_MASK 0xc0
#define ZIP_STR_06B (0 << 6)
#define ZIP_STR_14B (1 << 6)
#define ZIP_STR_32B (2 << 6)

#define ZIP_INT_MASK 0x30
#define ZIP_INT_16B (0xc0 | 0 << 4)
#define ZIP_INT_32B (0xc0 | 1 << 4)
#define ZIP_INT_64B (0xc0 | 2 << 4)
#define ZIP_INT_24B (0xc0 | 3 << 4)
#define ZIP_INT_8B  (0xc0 | 4 << 4)

// 创建压缩列表
unsigned char *ziplistNew(void) {
    unsigned int bytes = ZIPLIST_HEADER_SIZE + 1;
    unsigned char *zl = zmalloc(bytes);
    ZIPLIST_BYTES(zl) = bytes;
    ZIPLIST_TAIL_OFFSET(zl) = ZIPLIST_HEADER_SIZE;
    ZIPLIST_LENGTH(zl) = 0;
    zl[bytes-1] = ZIP_END;
    return zl;
}

// 插入数据
unsigned char *ziplistInsert(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen) {
    return __ziplistInsert(zl, p, s, slen);
}

// 删除数据
unsigned char *ziplistDelete(unsigned char *zl, unsigned char **p) {
    size_t offset = *p - zl;
    zl = __ziplistDelete(zl, *p, 1);
    *p = zl + offset;
    return zl;
}
```

**压缩列表操作的核心挑战**

1. **连锁更新问题**：
   - 插入或删除可能导致后续entry的prevlen字段变化
   - 当某个entry长度变化超过254字节时，prevlen需要从1字节扩展到5字节
   - 可能触发连锁反应，导致多个entry需要重新分配

2. **内存重分配策略**：
   - 插入时需要扩展内存空间
   - 删除时需要压缩内存空间
   - 频繁的重分配会影响性能

3. **性能权衡**：
   - 内存效率：极高的内存利用率
   - 时间复杂度：插入删除为O(n)，且可能触发连锁更新
   - 适用场景：小数据量，读多写少

**ZipList的适用边界**

- **内存优势**：相比普通链表节省大量内存
- **性能劣势**：大数据量时性能下降明显
- **使用建议**：元素数量<1000，单个元素<64字节

## IntSet（整数集合）

### 1. 整数集合设计原理

**IntSet的核心价值**

IntSet是Redis为纯整数集合设计的优化结构，体现了类型特化设计的优势：

1. **类型特化**：
   - 专门处理整数数据，不支持其他类型
   - 针对整数操作进行深度优化
   - 避免通用数据结构的开销

2. **自动升级机制**：
   - 根据数据范围自动选择合适的整数类型
   - int16_t → int32_t → int64_t的渐进式升级
   - 升级过程保证数据完整性

3. **有序存储**：
   - 数组按升序排列，支持二分查找
   - 插入时需要找到合适位置并移动后续元素
   - 查找效率高，插入效率相对较低

```c
// intset.h
typedef struct intset {
    uint32_t encoding;  // 编码方式
    uint32_t length;    // 元素数量
    int8_t contents[];  // 实际存储元素
} intset;

/* encoding */
#define INTSET_ENC_INT16 (sizeof(int16_t))
#define INTSET_ENC_INT32 (sizeof(int32_t))
#define INTSET_ENC_INT64 (sizeof(int64_t))
```

**编码选择策略**
- int16_t：-32768 到 32767，占用2字节
- int32_t：-2147483648 到 2147483647，占用4字节
- int64_t：-9223372036854775808 到 9223372036854775807，占用8字节

### 2. IntSet升级机制详解

```c
// intset.c
intset *intsetUpgradeAndAdd(intset *is, int64_t value) {
    uint8_t curenc = intrev32ifbe(is->encoding);
    uint8_t newenc = _intsetValueEncoding(value);
    int length = intrev32ifbe(is->length);
    int prepend = value < 0 ? 1 : 0;

    // 设置新的编码方式
    is->encoding = intrev32ifbe(newenc);
    is->length = intrev32ifbe(length+1);

    // 根据新编码方式扩展空间
    is = zrealloc(is, sizeof(intset)+newenc*(length+1));

    // 移动原有数据
    if (prepend) {
        memmove(is->contents+newenc, is->contents, length*newenc);
    } else {
        memmove(is->contents+newenc*prepend, is->contents, length*newenc);
    }

    // 设置新值
    if (prepend) {
        _intsetSet(is,0,value);
    } else {
        _intsetSet(is,length,value);
    }

    return is;
}

// 插入元素
intset *intsetAdd(intset *is, int64_t value, uint8_t *success) {
    uint8_t valenc = _intsetValueEncoding(value);
    uint32_t pos;

    if (success) *success = 1;

    // 如果需要升级
    if (valenc > intrev32ifbe(is->encoding)) {
        return intsetUpgradeAndAdd(is, value);
    }

    // 检查是否已存在
    if (intsetSearch(is, value, &pos)) {
        if (success) *success = 0;
        return is;
    }

    // 扩展空间并插入
    is = intsetResize(is, intrev32ifbe(is->length)+1);
    if (pos < intrev32ifbe(is->length))
        intsetMoveTail(is, pos, pos+1);

    _intsetSet(is, pos, value);
    is->length = intrev32ifbe(intrev32ifbe(is->length)+1);

    return is;
}
```

**升级操作的精妙设计**

1. **升级触发条件**：
   - 新元素超出当前编码范围时自动触发
   - 从int16_t升级到int32_t，或从int32_t升级到int64_t
   - 升级过程一次性完成，保证数据一致性

2. **内存重分配策略**：
   - 重新分配更大的内存空间
   - 将原有数据按新的编码格式重新排列
   - 保持数据的有序性和完整性

3. **插入位置优化**：
   - 负数插入到数组头部
   - 正数插入到数组尾部
   - 利用有序性减少数据移动

**IntSet的性能特征**

- **查找性能**：O(log n)，使用二分查找
- **插入性能**：O(n)，需要移动元素，可能触发升级
- **内存效率**：根据数据范围选择最优编码
- **使用场景**：整数集合，元素数量适中，读多写少

**自动升级的优势与代价**

**优势**：
- 根据实际数据动态选择最优编码
- 避免一开始就使用最大类型的浪费
- 对用户透明，无需手动管理类型

**代价**：
- 升级操作需要重新分配和复制所有数据
- 升级过程中的性能开销较大
- 一旦升级，不会降级，可能浪费内存

## QuickList（快速列表）

### 1. 快速列表结构

```c
// quicklist.h
typedef struct quicklistNode {
    struct quicklistNode *prev;   // 前一个节点
    struct quicklistNode *next;   // 后一个节点
    unsigned char *zl;            // 指向压缩列表
    unsigned int sz;              // 压缩列表字节数
    unsigned int count : 16;      // 压缩列表包含的元素数量
    unsigned int encoding : 2;    // 编码方式
    unsigned int container : 2;   // 容器类型
    unsigned int recompress : 1;  // 是否重新压缩
    unsigned int attempted_compress : 1; // 尝试压缩次数
    unsigned int extra : 10;      // 预留字段
} quicklistNode;

typedef struct quicklistLZF {
    unsigned int sz;              // 压缩后长度
    char compressed[];            // 压缩数据
} quicklistLZF;

typedef struct quicklist {
    quicklistNode *head;          // 头节点
    quicklistNode *tail;          // 尾节点
    unsigned long count;          // 元素总数
    unsigned long len;            // 节点数量
    int fill : 16;                // 填充因子
    unsigned int compress : 16;   // 压缩深度
} quicklist;
```

### 2. QuickList设计动机

**QuickList的诞生背景**

QuickList是Redis 3.2版本引入的新数据结构，旨在解决传统LinkedList在大数据量场景下的性能问题：

1. **传统LinkedList的缺陷**：
   - 每个节点独立分配内存，内存碎片严重
   - 指针开销大，每个节点需要额外的prev/next指针
   - 缓存局部性差，节点在内存中分布分散
   - 双端操作虽然O(1)，但内存访问效率低

2. **ZipList的局限性**：
   - 虽然内存效率极高，但大数据量时性能下降
   - 连锁更新问题在长列表中会被放大
   - 插入删除操作时间复杂度为O(n)

**QuickList的混合设计思想**

QuickList巧妙地结合了LinkedList和ZipList的优势：

1. **分而治之策略**：
   - 将长列表切分为多个ZipList节点
   - 每个ZipList节点控制在合理大小（通常几KB）
   - 避免单个ZipList过大导致的性能问题

2. **双层结构设计**：
   - 外层使用双向链表，支持高效的双端操作
   - 内层使用ZipList，保持高内存利用率
   - 在性能和内存使用之间找到最佳平衡点

3. **自适应优化**：
   - 支持压缩策略，对不常用节点进行LZF压缩
   - 支持动态调整ZipList大小，适应不同使用模式
   - 提供配置参数，根据业务特点优化

**QuickList的优势分析**

1. **性能优势**：
   - 双端操作：O(1)时间复杂度，比ZipList的O(n)更优
   - 中间访问：通过跳转表优化，减少遍历开销
   - 内存访问：局部性更好，缓存命中率更高

2. **内存优势**：
   - 相比纯LinkedList，减少50%以上的内存使用
   - 支持压缩，进一步节省内存空间
   - 避免了大量小内存分配，减少内存碎片

3. **扩展优势**：
   - 支持配置化，可根据业务场景调整
   - 兼容性好，对用户透明
   - 为后续优化预留了空间

### 3. 快速列表操作详解

```c
// quicklist.c
quicklist *quicklistCreate(void) {
    struct quicklist *quicklist;

    quicklist = zmalloc(sizeof(*quicklist));
    quicklist->head = quicklist->tail = NULL;
    quicklist->len = 0;
    quicklist->count = 0;
    quicklist->compress = 0;
    quicklist->fill = -2;
    return quicklist;
}

int quicklistPushHead(quicklist *quicklist, void *value, size_t sz) {
    quicklistNode *orig_head = quicklist->head;

    if (likely(
            _quicklistNodeAllowInsert(quicklist->head, quicklist->fill, sz))) {
        quicklist->head->zl = ziplistPush(quicklist->head->zl, value, sz, ZIPLIST_HEAD);
        quicklist->head->count++;
    } else {
        quicklistNode *node = quicklistCreateNode();
        node->zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_HEAD);
        node->count++;
        _quicklistInsertNodeBefore(quicklist, quicklist->head, node);
    }
    quicklist->count++;
    return 1;
}
```

**QuickList操作的核心策略**

1. **智能插入策略**：
   - 优先尝试在现有ZipList节点中插入
   - 当ZipList节点达到容量限制时，创建新节点
   - 通过`fill`参数控制每个ZipList的最大大小

2. **fill参数的作用**：
   - 正数：限制每个ZipList的最大元素数量
   - 负数：限制每个ZipList的最大字节大小
   - 例如：`-2`表示每个ZipList最大8KB

3. **压缩策略**：
   - `compress`参数控制压缩深度
   - 对距离两端较远的节点进行压缩
   - 平衡内存使用和解压缩开销

**QuickList的性能优化特点**

1. **分批操作优化**：
   - 避免单个ZipList过大，减少连锁更新的影响
   - 支持并行操作，不同ZipList节点可独立处理
   - 提高内存分配和释放的效率

2. **缓存友好设计**：
   - 相关数据聚集在同一个ZipList中
   - 减少内存跳跃访问，提高缓存命中率
   - 适合访问局部性强的场景

3. **动态平衡机制**：
   - 根据访问模式自动调整压缩策略
   - 支持节点分裂和合并，保持结构平衡
   - 在内存使用和访问性能之间动态平衡

**QuickList vs 其他结构的对比**

| 特性 | LinkedList | ZipList | QuickList |
|------|------------|---------|-----------|
| 双端操作 | O(1) | O(n) | O(1) |
| 内存使用 | 高 | 极低 | 中等 |
| 中间访问 | O(n) | O(n) | O(n/m) |
| 连锁更新 | 无 | 严重 | 轻微 |
| 适用场景 | 频繁双端操作 | 小数据集 | 通用场景 |

QuickList成为了Redis List类型的默认实现，它在各种使用场景下都能提供优秀的性能表现。

## 性能分析和优化建议

### 1. 数据结构复杂度分析

| 数据结构 | 时间复杂度 | 空间复杂度 | 适用场景 |
|----------|------------|------------|----------|
| SDS | O(1) | O(n) | 字符串操作 |
| Dict | O(1)平均 | O(n) | 键值对存储 |
| SkipList | O(log n) | O(n) | 排序集合 |
| ZipList | O(n) | O(n) | 小数据集合 |
| IntSet | O(log n) | O(n) | 整数集合 |
| QuickList | O(n) | O(n) | 列表操作 |

### 2. 内存优化策略

**选择合适的数据结构**：
```redis
# 小Hash使用ZipList
# 当Hash元素数量小于512且每个元素值小于64字节时，使用ZipList
hash-max-ziplist-entries 512
hash-max-ziplist-value 64

# 小List使用ZipList
# 当List元素数量小于512且每个元素值小于64字节时，使用ZipList
list-max-ziplist-size -2

# 小Set使用IntSet
# 当Set元素都是整数且数量小于512时，使用IntSet
set-max-intset-entries 512

# 小Sorted Set使用ZipList
zset-max-ziplist-entries 128
zset-max-ziplist-value 64
```

### 3. 实际应用场景分析

**场景一：用户会话管理**
```redis
# 用户登录信息存储
HSET session:user123 user_id 123 username "alice" login_time 1640995200
```
- **数据结构**：Hash（底层：ZipList → Dict）
- **选择理由**：字段较少时使用ZipList节省内存，字段增多时自动切换到Dict
- **性能特点**：O(1)的字段访问，内存效率高
- **最佳实践**：合理设置`hash-max-ziplist-entries`和`hash-max-ziplist-value`

**场景二：计数器和排行榜**
```redis
# 文章点赞数
ZADD article:likes 12345 "article:001" 9876 "article:002" 6543 "article:003"
ZREVRANGE article:likes 0 9 WITHSCORES
```
- **数据结构**：Sorted Set（底层：ZipList → SkipList + Dict）
- **选择理由**：需要排序和范围查询，SkipList提供高效支持
- **性能特点**：O(log n)的插入和查询，O(log n + k)的范围查询
- **最佳实践**：小集合使用ZipList，大集合自动切换到SkipList

**场景三：消息队列**
```redis
# 简单消息队列
LPUSH queue:tasks '{"id":1,"type":"email","data":"test@example.com"}'
BRPOP queue:tasks 30
```
- **数据结构**：List（底层：QuickList）
- **选择理由**：需要高效的双端操作，QuickList平衡性能和内存
- **性能特点**：O(1)的入队出队操作，内存使用合理
- **最佳实践**：调整`list-max-ziplist-size`控制每个ZipList节点大小

**场景四：标签系统**
```redis
# 文章标签
SADD article:123:tags "redis" "database" "performance"
SINTER article:123:tags article:456:tags
```
- **数据结构**：Set（底层：IntSet → Dict）
- **选择理由**：整数集合使用IntSet，混合数据使用Dict
- **性能特点**：O(1)的添加和查找，支持集合运算
- **最佳实践**：纯整数标签利用IntSet的内存优势

### 4. 性能监控和调优

**关键监控指标**
```bash
# 查看内存使用情况
redis-cli info memory | grep used_memory_human

# 查看数据结构信息
redis-cli memory usage key_name

# 监控数据结构变化
redis-cli monitor | grep -E "(SET|HSET|LPUSH|SADD|ZADD)"

# 查看数据结构统计
redis-cli info stats | grep keyspace
```

**内存优化策略**

1. **选择合适的数据结构**：
   - 根据数据特点选择最合适的类型
   - 考虑访问模式和操作频率
   - 平衡内存使用和性能需求

2. **合理配置编码阈值**：
   ```redis
   # 针对小数据优化配置
   hash-max-ziplist-entries 512
   hash-max-ziplist-value 64
   list-max-ziplist-size -2
   set-max-intset-entries 512
   zset-max-ziplist-entries 128
   zset-max-ziplist-value 64
   ```

3. **监控内存使用模式**：
   - 定期检查大key和热key
   - 分析内存碎片情况
   - 根据业务特点调整配置

### 5. 故障诊断指南

**常见问题及解决方案**

1. **内存使用过高**：
   - 检查是否存在大key
   - 分析数据结构是否合理
   - 考虑数据压缩或分片

2. **性能下降**：
   - 检查是否发生了数据结构编码转换
   - 分析rehash是否阻塞服务
   - 优化查询模式和数据分布

3. **延迟问题**：
   - 监控慢查询日志
   - 检查网络和硬件状况
   - 优化数据结构和访问方式

## 总结

Redis的内部数据结构设计体现了高性能和高效率的追求：

1. **SDS**：通过预分配和惰性释放机制优化字符串操作，避免传统C字符串的性能陷阱
2. **Dict**：采用渐进式rehash和链地址法解决哈希冲突，在大数据量下保持稳定性能
3. **SkipList**：提供O(log n)的查找性能，同时支持范围查询，是有序集合的理想选择
4. **ZipList**：通过连续内存存储节省空间，适合小数据集合，但在大数据量时需要谨慎使用
5. **IntSet**：针对整数集合优化，支持自动升级，在整数场景下性能卓越
6. **QuickList**：结合链表和ZipList的优势，平衡性能和内存使用，是列表数据的最佳选择

**实践建议**：
- 深入理解每种数据结构的特性和适用场景
- 根据业务需求选择合适的数据结构和配置
- 持续监控性能指标，及时调整优化策略
- 在设计阶段考虑数据增长趋势和访问模式

理解这些内部数据结构的工作原理，有助于我们更好地使用Redis，选择合适的数据类型，进行性能调优和问题诊断。在实际应用中，应该根据具体场景选择最适合的数据结构，充分发挥Redis的性能优势，构建高效、稳定的应用系统。2:["$","div",null,{"children":[["$","$L9",null,{"href":"/notes","className":"back-button","style":{"display":"inline-block","background":"var(--primary-color)","color":"white","border":"none","padding":"10px 20px","borderRadius":"6px","cursor":"pointer","marginBottom":"20px","textDecoration":"none"},"children":["← 返回","笔记","列表"]}],["$","article",null,{"className":"section","children":[["$","header",null,{"className":"article-header","children":[["$","h1",null,{"className":"article-title","children":"Redis内部数据结构详解"}],["$","div",null,{"className":"article-meta","children":["$","div",null,{"className":"article-tags","children":[["$","span","Redis",{"className":"tag","children":"Redis"}],["$","span","数据结构",{"className":"tag","children":"数据结构"}],["$","span","源码分析",{"className":"tag","children":"源码分析"}],["$","span","算法",{"className":"tag","children":"算法"}],["$","span","底层实现",{"className":"tag","children":"底层实现"}]]}]}]]}],["$","div",null,{"className":"card markdown-content","children":["$","$La",null,{"content":"$b"}]}]]}]]}]
7:["$","html",null,{"lang":"zh-CN","children":[["$","head",null,{"children":[["$","link",null,{"rel":"stylesheet","href":"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"}],["$","link",null,{"rel":"stylesheet","href":"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css"}],["$","script",null,{"src":"https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"}]]}],["$","body",null,{"children":["$","div",null,{"className":"app","children":[["$","$Lc",null,{"siteConfig":{"name":"海元","bio":"JAVA | AI | WEB3","social":[{"name":"github","icon":"fab fa-github","url":"https://github.com/suogongy"},{"name":"twitter","icon":"fab fa-twitter","url":"https://twitter.com/suogongy"},{"name":"email","icon":"fas fa-envelope","url":"mailto:haiyuan1832@163.com"}]}}],["$","main",null,{"className":"main-content","children":["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L6",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":"404"}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],"notFoundStyles":[]}]}]]}]}]]}]
8:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"Redis内部数据结构详解 - Personal GitHub Page"}],["$","meta","3",{"name":"description","content":"深入剖析Redis内部数据结构的实现原理，包括简单动态字符串、链表、字典、跳跃表、整数集合、压缩列表等核心数据结构的详细解析。"}]]
1:null
