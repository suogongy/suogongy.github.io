<!DOCTYPE html><html lang="zh-CN"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/eb4a34bff42c1814.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-c81f7fd28659d64f.js"/><script src="/_next/static/chunks/fd9d1056-e3d373074663785d.js" async=""></script><script src="/_next/static/chunks/117-86f31d03f8df68a5.js" async=""></script><script src="/_next/static/chunks/main-app-1bdc7b9537d0c130.js" async=""></script><script src="/_next/static/chunks/972-81dbad6abe39d3fa.js" async=""></script><script src="/_next/static/chunks/832-7ea2624e20755f9f.js" async=""></script><script src="/_next/static/chunks/app/%5Bcategory%5D/%5Bslug%5D/page-e466df95e55c7602.js" async=""></script><script src="/_next/static/chunks/app/layout-3ed2f387fb22aa2c.js" async=""></script><title>系统安全性保障 - Personal GitHub Page</title><meta name="description" content="全面介绍系统安全架构设计、安全防护措施、安全漏洞防护和安全监控体系建设，帮助构建安全可靠的系统。"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css"/><script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body><div class="app"><header class="header "><nav class="nav-container"><a class="nav-brand" href="/"><i class="fas fa-terminal"></i>Rudy Yang</a><ul class="nav-menu"><li><a class="nav-link " href="/"><i class="fas fa-home"></i> 首页</a></li><li><a class="nav-link " href="/about/"><i class="fas fa-user"></i> 关于</a></li><li><a class="nav-link " href="/projects/"><i class="fas fa-code"></i> 项目</a></li><li><a class="nav-link " href="/notes/"><i class="fas fa-book"></i> 笔记</a></li><li><a class="nav-link " href="/articles/"><i class="fas fa-pen"></i> 随笔</a></li></ul></nav></header><main class="main-content"><div><a class="back-button" style="display:inline-block;background:var(--primary-color);color:white;border:none;padding:10px 20px;border-radius:6px;cursor:pointer;margin-bottom:20px;text-decoration:none" href="/notes/">← 返回<!-- -->笔记<!-- -->列表</a><article class="section"><header class="article-header"><h1 class="article-title">系统安全性保障</h1><div class="article-meta"><div class="article-tags"><span class="tag">系统安全</span><span class="tag">安全架构</span><span class="tag">防护措施</span><span class="tag">安全监控</span><span class="tag">漏洞防护</span></div></div></header><div class="card markdown-content"><div class="markdown-content"><div><h1>系统安全性保障</h1>
<blockquote>
<p>安全是系统的生命线，完善的安全防护体系是保障系统稳定运行的基石</p>
</blockquote>
<h2>安全架构概述</h2>
<h3>1. 安全体系架构</h3>
<pre><code>安全防护体系：
├── 网络安全
│   ├── 防火墙
│   ├── DDoS防护
│   ├── WAF
│   └── VPN
├── 应用安全
│   ├── 身份认证
│   ├── 权限控制
│   ├── 数据加密
│   └── 安全编码
├── 数据安全
│   ├── 数据加密
│   ├── 数据脱敏
│   ├── 数据备份
│   └── 访问控制
└── 运维安全
    ├── 安全审计
    ├── 漏洞扫描
    ├── 入侵检测
    └── 应急响应
</code></pre>
<h3>2. 安全设计原则</h3>
<pre><code>安全设计原则：
├── 纵深防御
│   ├── 多层防护
│   ├── 分段隔离
│   └── 冗余备份
├── 最小权限
│   ├── 最小权限原则
│   ├── 职责分离
│   └── 权限管控
├── 零信任
│   ├── 永不信任
│   ├── 始终验证
│   └── 最小访问
└── 默认安全
    ├── 安全配置
    ├── 安全默认
    └── 安全加固
</code></pre>
<h2>身份认证与授权</h2>
<h3>1. 认证机制</h3>
<p><strong>JWT认证实现</strong></p>
<pre><code class="language-java">@Component
public class JwtAuthenticationService {
    
    @Value(&quot;${jwt.secret}&quot;)
    private String jwtSecret;
    
    @Value(&quot;${jwt.expiration}&quot;)
    private int jwtExpiration;
    
    // 生成JWT Token
    public String generateToken(UserDetails userDetails) {
        Map&lt;String, Object&gt; claims = new HashMap&lt;&gt;();
        claims.put(&quot;roles&quot;, userDetails.getAuthorities());
        claims.put(&quot;username&quot;, userDetails.getUsername());
        
        return createToken(claims, userDetails.getUsername());
    }
    
    private String createToken(Map&lt;String, Object&gt; claims, String subject) {
        return Jwts.builder()
            .setClaims(claims)
            .setSubject(subject)
            .setIssuedAt(new Date(System.currentTimeMillis()))
            .setExpiration(new Date(System.currentTimeMillis() + jwtExpiration * 1000))
            .signWith(SignatureAlgorithm.HS256, jwtSecret)
            .compact();
    }
    
    // 验证Token
    public Boolean validateToken(String token, UserDetails userDetails) {
        final String username = getUsernameFromToken(token);
        return (username.equals(userDetails.getUsername()) &amp;&amp; 
                !isTokenExpired(token));
    }
    
    // 从Token中获取用户名
    public String getUsernameFromToken(String token) {
        return getClaimFromToken(token, Claims::getSubject);
    }
    
    // 从Token中获取指定声明
    public &lt;T&gt; T getClaimFromToken(String token, Function&lt;Claims, T&gt; claimsResolver) {
        final Claims claims = getAllClaimsFromToken(token);
        return claimsResolver.apply(claims);
    }
    
    // 从Token中获取所有声明
    private Claims getAllClaimsFromToken(String token) {
        return Jwts.parser().setSigningKey(jwtSecret).parseClaimsJws(token).getBody();
    }
    
    // 检查Token是否过期
    private Boolean isTokenExpired(String token) {
        final Date expiration = getExpirationDateFromToken(token);
        return expiration.before(new Date());
    }
    
    private Date getExpirationDateFromToken(String token) {
        return getClaimFromToken(token, Claims::getExpiration);
    }
}
</code></pre>
<p><strong>OAuth2认证</strong></p>
<pre><code class="language-java">@Configuration
@EnableAuthorizationServer
public class AuthorizationServerConfig extends AuthorizationServerConfigurerAdapter {
    
    @Autowired
    private AuthenticationManager authenticationManager;
    
    @Autowired
    private UserDetailsService userDetailsService;
    
    @Override
    public void configure(AuthorizationServerEndpointsConfigurer endpoints) {
        endpoints
            .authenticationManager(authenticationManager)
            .userDetailsService(userDetailsService)
            .accessTokenConverter(accessTokenConverter());
    }
    
    @Bean
    public JwtAccessTokenConverter accessTokenConverter() {
        JwtAccessTokenConverter converter = new JwtAccessTokenConverter();
        converter.setSigningKey(&quot;jwt-secret-key&quot;);
        return converter;
    }
    
    @Override
    public void configure(ClientDetailsServiceConfigurer clients) throws Exception {
        clients.inMemory()
            .withClient(&quot;client-id&quot;)
            .secret(&quot;client-secret&quot;)
            .authorizedGrantTypes(&quot;password&quot;, &quot;refresh_token&quot;)
            .scopes(&quot;read&quot;, &quot;write&quot;)
            .accessTokenValiditySeconds(3600)
            .refreshTokenValiditySeconds(18000);
    }
}
</code></pre>
<h3>2. 权限控制</h3>
<p><strong>RBAC权限控制</strong></p>
<pre><code class="language-java">// 角色实体
@Entity
public class Role {
    @Id
    private Long id;
    private String name;
    private String description;
    
    @ManyToMany(fetch = FetchType.EAGER)
    @JoinTable(
        name = &quot;role_permission&quot;,
        joinColumns = @JoinColumn(name = &quot;role_id&quot;),
        inverseJoinColumns = @JoinColumn(name = &quot;permission_id&quot;)
    )
    private Set&lt;Permission&gt; permissions;
}

// 权限实体
@Entity
public class Permission {
    @Id
    private Long id;
    private String name;
    private String resource;
    private String action;
}

// 权限检查注解
@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@PreAuthorize(&quot;hasPermission(#id, &#39;USER&#39;, &#39;READ&#39;)&quot;)
public @interface RequirePermission {
    String resource();
    String action();
}

// 权限检查切面
@Aspect
@Component
public class PermissionAspect {
    
    @Autowired
    private PermissionService permissionService;
    
    @Before(&quot;@annotation(requirePermission)&quot;)
    public void checkPermission(JoinPoint joinPoint, RequirePermission requirePermission) {
        // 获取当前用户
        User currentUser = SecurityContextHolder.getContext()
            .getAuthentication().getPrincipal();
        
        // 获取资源ID
        Long resourceId = getResourceId(joinPoint);
        
        // 检查权限
        boolean hasPermission = permissionService.hasPermission(
            currentUser.getId(), 
            resourceId, 
            requirePermission.resource(), 
            requirePermission.action()
        );
        
        if (!hasPermission) {
            throw new AccessDeniedException(&quot;权限不足&quot;);
        }
    }
    
    private Long getResourceId(JoinPoint joinPoint) {
        // 从方法参数中提取资源ID
        Object[] args = joinPoint.getArgs();
        for (Object arg : args) {
            if (arg instanceof Long) {
                return (Long) arg;
            }
        }
        return null;
    }
}
</code></pre>
<h2>数据安全防护</h2>
<h3>1. 数据加密</h3>
<p><strong>对称加密</strong></p>
<pre><code class="language-java">@Component
public class EncryptionService {
    
    private static final String ALGORITHM = &quot;AES&quot;;
    private static final String TRANSFORMATION = &quot;AES/CBC/PKCS5Padding&quot;;
    
    @Value(&quot;${encryption.key}&quot;)
    private String encryptionKey;
    
    // 加密
    public String encrypt(String data) throws Exception {
        SecretKeySpec secretKey = new SecretKeySpec(
            encryptionKey.getBytes(), ALGORITHM);
        IvParameterSpec ivParameterSpec = new IvParameterSpec(
            encryptionKey.getBytes());
        
        Cipher cipher = Cipher.getInstance(TRANSFORMATION);
        cipher.init(Cipher.ENCRYPT_MODE, secretKey, ivParameterSpec);
        
        byte[] encrypted = cipher.doFinal(data.getBytes());
        return Base64.getEncoder().encodeToString(encrypted);
    }
    
    // 解密
    public String decrypt(String encryptedData) throws Exception {
        SecretKeySpec secretKey = new SecretKeySpec(
            encryptionKey.getBytes(), ALGORITHM);
        IvParameterSpec ivParameterSpec = new IvParameterSpec(
            encryptionKey.getBytes());
        
        Cipher cipher = Cipher.getInstance(TRANSFORMATION);
        cipher.init(Cipher.DECRYPT_MODE, secretKey, ivParameterSpec);
        
        byte[] decoded = Base64.getDecoder().decode(encryptedData);
        byte[] decrypted = cipher.doFinal(decoded);
        
        return new String(decrypted);
    }
}
</code></pre>
<p><strong>非对称加密</strong></p>
<pre><code class="language-java">@Component
public class RSAEncryptionService {
    
    private static final String ALGORITHM = &quot;RSA&quot;;
    
    // 生成密钥对
    public KeyPair generateKeyPair() throws Exception {
        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(ALGORITHM);
        keyPairGenerator.initialize(2048);
        return keyPairGenerator.generateKeyPair();
    }
    
    // 公钥加密
    public String encrypt(String data, PublicKey publicKey) throws Exception {
        Cipher cipher = Cipher.getInstance(ALGORITHM);
        cipher.init(Cipher.ENCRYPT_MODE, publicKey);
        
        byte[] encrypted = cipher.doFinal(data.getBytes());
        return Base64.getEncoder().encodeToString(encrypted);
    }
    
    // 私钥解密
    public String decrypt(String encryptedData, PrivateKey privateKey) throws Exception {
        Cipher cipher = Cipher.getInstance(ALGORITHM);
        cipher.init(Cipher.DECRYPT_MODE, privateKey);
        
        byte[] decoded = Base64.getDecoder().decode(encryptedData);
        byte[] decrypted = cipher.doFinal(decoded);
        
        return new String(decrypted);
    }
    
    // 数字签名
    public String sign(String data, PrivateKey privateKey) throws Exception {
        Signature signature = Signature.getInstance(&quot;SHA256withRSA&quot;);
        signature.initSign(privateKey);
        signature.update(data.getBytes());
        
        byte[] signBytes = signature.sign();
        return Base64.getEncoder().encodeToString(signBytes);
    }
    
    // 验证签名
    public boolean verify(String data, String sign, PublicKey publicKey) throws Exception {
        Signature signature = Signature.getInstance(&quot;SHA256withRSA&quot;);
        signature.initVerify(publicKey);
        signature.update(data.getBytes());
        
        byte[] signBytes = Base64.getDecoder().decode(sign);
        return signature.verify(signBytes);
    }
}
</code></pre>
<h3>2. 数据脱敏</h3>
<p><strong>敏感数据脱敏</strong></p>
<pre><code class="language-java">@Component
public class DataMaskingService {
    
    // 手机号脱敏
    public String maskPhone(String phone) {
        if (phone == null || phone.length() &lt; 11) {
            return phone;
        }
        return phone.substring(0, 3) + &quot;****&quot; + phone.substring(7);
    }
    
    // 邮箱脱敏
    public String maskEmail(String email) {
        if (email == null) {
            return null;
        }
        
        int atIndex = email.indexOf(&quot;@&quot;);
        if (atIndex &lt;= 1) {
            return email;
        }
        
        String username = email.substring(0, atIndex);
        String domain = email.substring(atIndex);
        
        if (username.length() &lt;= 2) {
            return username.charAt(0) + &quot;***&quot; + domain;
        }
        
        return username.charAt(0) + &quot;***&quot; + 
               username.charAt(username.length() - 1) + domain;
    }
    
    // 身份证脱敏
    public String maskIdCard(String idCard) {
        if (idCard == null || idCard.length() &lt; 8) {
            return idCard;
        }
        return idCard.substring(0, 4) + &quot;**********&quot; + 
               idCard.substring(idCard.length() - 4);
    }
    
    // 银行卡脱敏
    public String maskBankCard(String bankCard) {
        if (bankCard == null || bankCard.length() &lt; 8) {
            return bankCard;
        }
        return bankCard.substring(0, 4) + &quot; **** **** &quot; + 
               bankCard.substring(bankCard.length() - 4);
    }
}

// 脱敏注解
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface DataMasking {
    MaskType type() default MaskType.NONE;
}

// 脱敏类型
public enum MaskType {
    PHONE, EMAIL, ID_CARD, BANK_CARD, NAME
}

// 脱敏切面
@Aspect
@Component
public class DataMaskingAspect {
    
    @Autowired
    private DataMaskingService maskingService;
    
    @Around(&quot;@annotation(org.springframework.web.bind.annotation.GetMapping)&quot;)
    public Object maskResponseData(ProceedingJoinPoint joinPoint) throws Throwable {
        Object result = joinPoint.proceed();
        
        if (result instanceof ResponseEntity) {
            ResponseEntity&lt;?&gt; response = (ResponseEntity&lt;?&gt;) result;
            Object body = response.getBody();
            
            if (body != null) {
                Object maskedBody = maskObject(body);
                return new ResponseEntity&lt;&gt;(maskedBody, response.getHeaders(), 
                    response.getStatusCode());
            }
        }
        
        return result;
    }
    
    private Object maskObject(Object obj) {
        if (obj == null) {
            return null;
        }
        
        Class&lt;?&gt; clazz = obj.getClass();
        
        for (Field field : clazz.getDeclaredFields()) {
            DataMasking annotation = field.getAnnotation(DataMasking.class);
            if (annotation != null &amp;&amp; annotation.type() != MaskType.NONE) {
                field.setAccessible(true);
                try {
                    Object value = field.get(obj);
                    if (value instanceof String) {
                        String maskedValue = maskValue((String) value, annotation.type());
                        field.set(obj, maskedValue);
                    }
                } catch (IllegalAccessException e) {
                    // 日志记录
                }
            }
        }
        
        return obj;
    }
    
    private String maskValue(String value, MaskType type) {
        switch (type) {
            case PHONE:
                return maskingService.maskPhone(value);
            case EMAIL:
                return maskingService.maskEmail(value);
            case ID_CARD:
                return maskingService.maskIdCard(value);
            case BANK_CARD:
                return maskingService.maskBankCard(value);
            default:
                return value;
        }
    }
}
</code></pre>
<h2>网络安全防护</h2>
<h3>1. Web应用防火墙</h3>
<p><strong>WAF规则配置</strong></p>
<pre><code class="language-java">@Component
public class WebApplicationFirewall {
    
    // SQL注入检测
    public boolean detectSqlInjection(String input) {
        String[] sqlPatterns = {
            &quot;(&#39;|(\\-\\-)|(;)|(\\||\\|)|(\\*|\\*))&quot;,
            &quot;(exec(\\s|\\+)+(s|x)p\\w+)&quot;,
            &quot;insert(\\s|\\+)into&quot;,
            &quot;delete(\\s|\\+)from&quot;,
            &quot;select(\\s|\\+).*from&quot;,
            &quot;update(\\s|\\+).*set&quot;,
            &quot;union(\\s|\\+)select&quot;
        };
        
        for (String pattern : sqlPatterns) {
            if (input.toLowerCase().matches(&quot;.*&quot; + pattern + &quot;.*&quot;)) {
                return true;
            }
        }
        
        return false;
    }
    
    // XSS攻击检测
    public boolean detectXss(String input) {
        String[] xssPatterns = {
            &quot;&lt;script&quot;,
            &quot;&lt;/script&gt;&quot;,
            &quot;&lt;iframe&quot;,
            &quot;javascript:&quot;,
            &quot;vbscript:&quot;,
            &quot;onload=&quot;,
            &quot;onerror=&quot;,
            &quot;onclick=&quot;
        };
        
        for (String pattern : xssPatterns) {
            if (input.toLowerCase().contains(pattern)) {
                return true;
            }
        }
        
        return false;
    }
    
    // CSRF防护
    public String generateCsrfToken(HttpServletRequest request) {
        String token = UUID.randomUUID().toString();
        request.getSession().setAttribute(&quot;csrf_token&quot;, token);
        return token;
    }
    
    public boolean validateCsrfToken(HttpServletRequest request, String token) {
        String sessionToken = (String) request.getSession().getAttribute(&quot;csrf_token&quot;);
        return sessionToken != null &amp;&amp; sessionToken.equals(token);
    }
}

// WAF过滤器
@Component
public class SecurityFilter implements Filter {
    
    @Autowired
    private WebApplicationFirewall waf;
    
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, 
                        FilterChain chain) throws IOException, ServletException {
        
        HttpServletRequest httpRequest = (HttpServletRequest) request;
        HttpServletResponse httpResponse = (HttpServletResponse) response;
        
        // 检查SQL注入
        String queryString = httpRequest.getQueryString();
        if (queryString != null &amp;&amp; waf.detectSqlInjection(queryString)) {
            httpResponse.sendError(HttpServletResponse.SC_BAD_REQUEST, &quot;SQL注入攻击&quot;);
            return;
        }
        
        // 检查XSS攻击
        String userAgent = httpRequest.getHeader(&quot;User-Agent&quot;);
        if (userAgent != null &amp;&amp; waf.detectXss(userAgent)) {
            httpResponse.sendError(HttpServletResponse.SC_BAD_REQUEST, &quot;XSS攻击&quot;);
            return;
        }
        
        chain.doFilter(request, response);
    }
}
</code></pre>
<h3>2. DDoS防护</h3>
<p><strong>限流防护</strong></p>
<pre><code class="language-java">@Component
public class RateLimitingService {
    
    private final Map&lt;String, Bucket&gt; buckets = new ConcurrentHashMap&lt;&gt;();
    
    // 令牌桶限流
    public boolean allowRequest(String clientId, int capacity, double refillRate) {
        Bucket bucket = buckets.computeIfAbsent(clientId, id -&gt; {
            Refill refill = Refill.intervently(capacity, Duration.ofSeconds((int) (capacity / refillRate)));
            return Bucket.builder()
                .addLimit(Bandwidth.classic(capacity, refill))
                .build();
        });
        
        return bucket.tryConsume(1);
    }
    
    // IP级别限流
    @Component
    public class IpRateLimitingFilter implements Filter {
        
        @Autowired
        private RateLimitingService rateLimitingService;
        
        @Override
        public void doFilter(ServletRequest request, ServletResponse response, 
                            FilterChain chain) throws IOException, ServletException {
            
            HttpServletRequest httpRequest = (HttpServletRequest) request;
            HttpServletResponse httpResponse = (HttpServletResponse) response;
            
            String clientIp = getClientIp(httpRequest);
            
            // 每个IP每分钟最多100个请求
            if (!rateLimitingService.allowRequest(clientIp, 100, 100/60.0)) {
                httpResponse.sendError(HttpServletResponse.SC_TOO_MANY_REQUESTS, &quot;请求过于频繁&quot;);
                return;
            }
            
            chain.doFilter(request, response);
        }
        
        private String getClientIp(HttpServletRequest request) {
            String xForwardedFor = request.getHeader(&quot;X-Forwarded-For&quot;);
            if (xForwardedFor != null &amp;&amp; !xForwardedFor.isEmpty()) {
                return xForwardedFor.split(&quot;,&quot;)[0].trim();
            }
            
            return request.getRemoteAddr();
        }
    }
}
</code></pre>
<h2>安全监控与审计</h2>
<h3>1. 安全日志</h3>
<p><strong>安全事件记录</strong></p>
<pre><code class="language-java">@Component
public class SecurityAuditService {
    
    @Autowired
    private AuditLogRepository auditLogRepository;
    
    // 记录登录事件
    public void recordLogin(String username, String ip, boolean success) {
        AuditLog log = new AuditLog();
        log.setEventType(&quot;LOGIN&quot;);
        log.setUsername(username);
        log.setIpAddress(ip);
        log.setSuccess(success);
        log.setEventTime(new Date());
        log.setDescription(success ? &quot;登录成功&quot; : &quot;登录失败&quot;);
        
        auditLogRepository.save(log);
        
        // 异步发送到日志系统
        asyncSendToLogSystem(log);
    }
    
    // 记录权限变更事件
    public void recordPermissionChange(String operator, String targetUser, 
                                    String resource, String action) {
        AuditLog log = new AuditLog();
        log.setEventType(&quot;PERMISSION_CHANGE&quot;);
        log.setUsername(operator);
        log.setTargetUser(targetUser);
        log.setResource(resource);
        log.setAction(action);
        log.setEventTime(new Date());
        log.setDescription(&quot;权限变更: &quot; + targetUser + &quot; &quot; + action + &quot; &quot; + resource);
        
        auditLogRepository.save(log);
        asyncSendToLogSystem(log);
    }
    
    // 记录数据访问事件
    public void recordDataAccess(String username, String resource, 
                               String action, boolean success) {
        AuditLog log = new AuditLog();
        log.setEventType(&quot;DATA_ACCESS&quot;);
        log.setUsername(username);
        log.setResource(resource);
        log.setAction(action);
        log.setSuccess(success);
        log.setEventTime(new Date());
        log.setDescription(&quot;数据访问: &quot; + username + &quot; &quot; + action + &quot; &quot; + resource);
        
        auditLogRepository.save(log);
        asyncSendToLogSystem(log);
    }
    
    private void asyncSendToLogSystem(AuditLog log) {
        // 异步发送到ELK、Splunk等日志系统
        CompletableFuture.runAsync(() -&gt; {
            try {
                // 发送逻辑
                logSystemClient.send(log);
            } catch (Exception e) {
                // 错误处理
            }
        });
    }
}
</code></pre>
<h3>2. 入侵检测</h3>
<p><strong>异常行为检测</strong></p>
<pre><code class="language-java">@Component
public class IntrusionDetectionService {
    
    @Autowired
    private SecurityAuditService auditService;
    
    // 检测异常登录
    public void detectAnomalousLogin(String username, String ip) {
        // 检查是否为新IP登录
        if (isNewIpForUser(username, ip)) {
            auditService.recordSecurityEvent(&quot;NEW_IP_LOGIN&quot;, username, ip);
        }
        
        // 检查是否为异地登录
        if (isRemoteLogin(username, ip)) {
            auditService.recordSecurityEvent(&quot;REMOTE_LOGIN&quot;, username, ip);
        }
        
        // 检查登录频率异常
        if (isHighFrequencyLogin(username, ip)) {
            auditService.recordSecurityEvent(&quot;HIGH_FREQUENCY_LOGIN&quot;, username, ip);
        }
    }
    
    // 检测异常数据访问
    public void detectAnomalousDataAccess(String username, String resource) {
        // 检查是否为非工作时间访问
        if (isAfterHoursAccess()) {
            auditService.recordSecurityEvent(&quot;AFTER_HOURS_ACCESS&quot;, username, resource);
        }
        
        // 检查是否为大批量数据访问
        if (isBulkDataAccess(username, resource)) {
            auditService.recordSecurityEvent(&quot;BULK_DATA_ACCESS&quot;, username, resource);
        }
        
        // 检查是否为敏感数据访问
        if (isSensitiveDataAccess(resource)) {
            auditService.recordSecurityEvent(&quot;SENSITIVE_DATA_ACCESS&quot;, username, resource);
        }
    }
    
    private boolean isNewIpForUser(String username, String ip) {
        // 检查用户历史登录IP
        List&lt;String&gt; historicalIps = getHistoricalIps(username);
        return !historicalIps.contains(ip);
    }
    
    private boolean isRemoteLogin(String username, String ip) {
        // 检查IP地理位置
        String location = getLocationByIp(ip);
        String usualLocation = getUserUsualLocation(username);
        return !location.equals(usualLocation);
    }
    
    private boolean isHighFrequencyLogin(String username, String ip) {
        // 检查最近5分钟内登录次数
        int recentLogins = getRecentLoginCount(username, ip, 5);
        return recentLogins &gt; 10;
    }
    
    private boolean isAfterHoursAccess() {
        int hour = LocalTime.now().getHour();
        return hour &lt; 9 || hour &gt; 18;
    }
    
    private boolean isBulkDataAccess(String username, String resource) {
        // 检查最近1小时内的访问次数
        int recentAccess = getRecentAccessCount(username, resource, 60);
        return recentAccess &gt; 1000;
    }
    
    private boolean isSensitiveDataAccess(String resource) {
        // 检查是否为敏感资源
        return resource.contains(&quot;admin&quot;) || 
               resource.contains(&quot;config&quot;) || 
               resource.contains(&quot;password&quot;);
    }
}
</code></pre>
<h2>漏洞管理</h2>
<h3>1. 漏洞扫描</h3>
<p><strong>自动化漏洞扫描</strong></p>
<pre><code class="language-java">@Component
public class VulnerabilityScanner {
    
    // SQL注入漏洞扫描
    public List&lt;Vulnerability&gt; scanSqlInjection(String target) {
        List&lt;Vulnerability&gt; vulnerabilities = new ArrayList&lt;&gt;();
        
        String[] payloads = {
            &quot;&#39; OR &#39;1&#39;=&#39;1&quot;,
            &quot;&#39; UNION SELECT NULL--&quot;,
            &quot;&#39;; DROP TABLE users--&quot;
        };
        
        for (String payload : payloads) {
            try {
                String testUrl = target + &quot;?id=&quot; + URLEncoder.encode(payload, &quot;UTF-8&quot;);
                HttpResponse response = httpClient.execute(new HttpGet(testUrl));
                
                if (response.getEntity() != null &amp;&amp; 
                    response.getEntity().getContentLength() &gt; 0) {
                    
                    Vulnerability vuln = new Vulnerability();
                    vuln.setType(&quot;SQL_INJECTION&quot;);
                    vuln.setSeverity(&quot;HIGH&quot;);
                    vuln.setDescription(&quot;发现SQL注入漏洞&quot;);
                    vuln.setPayload(payload);
                    vulnerabilities.add(vuln);
                }
            } catch (Exception e) {
                // 忽略异常
            }
        }
        
        return vulnerabilities;
    }
    
    // XSS漏洞扫描
    public List&lt;Vulnerability&gt; scanXss(String target) {
        List&lt;Vulnerability&gt; vulnerabilities = new ArrayList&lt;&gt;();
        
        String[] payloads = {
            &quot;&lt;script&gt;alert(&#39;XSS&#39;)&lt;/script&gt;&quot;,
            &quot;&lt;img src=x onerror=alert(&#39;XSS&#39;)&gt;&quot;,
            &quot;javascript:alert(&#39;XSS&#39;)&quot;
        };
        
        for (String payload : payloads) {
            try {
                String testUrl = target + &quot;?search=&quot; + URLEncoder.encode(payload, &quot;UTF-8&quot;);
                HttpResponse response = httpClient.execute(new HttpGet(testUrl));
                
                String content = EntityUtils.toString(response.getEntity());
                if (content.contains(payload)) {
                    Vulnerability vuln = new Vulnerability();
                    vuln.setType(&quot;XSS&quot;);
                    vuln.setSeverity(&quot;MEDIUM&quot;);
                    vuln.setDescription(&quot;发现XSS漏洞&quot;);
                    vuln.setPayload(payload);
                    vulnerabilities.add(vuln);
                }
            } catch (Exception e) {
                // 忽略异常
            }
        }
        
        return vulnerabilities;
    }
}
</code></pre>
<h3>2. 漏洞修复</h3>
<p><strong>安全编码规范</strong></p>
<pre><code class="language-java">@Component
public class SecureCodingService {
    
    // 安全的SQL查询
    public User getUserById(Long id) {
        // 使用参数化查询防止SQL注入
        String sql = &quot;SELECT * FROM users WHERE id = ?&quot;;
        return jdbcTemplate.queryForObject(sql, new Object[]{id}, new UserRowMapper());
    }
    
    // 安全的输入验证
    public boolean validateInput(String input, String pattern) {
        if (input == null) {
            return false;
        }
        
        // 使用白名单验证
        return input.matches(pattern);
    }
    
    // 安全的文件上传
    public String uploadFile(MultipartFile file) throws IOException {
        // 验证文件类型
        String contentType = file.getContentType();
        if (!isAllowedContentType(contentType)) {
            throw new SecurityException(&quot;不支持的文件类型&quot;);
        }
        
        // 验证文件大小
        if (file.getSize() &gt; 10 * 1024 * 1024) { // 10MB
            throw new SecurityException(&quot;文件过大&quot;);
        }
        
        // 生成安全的文件名
        String originalFilename = file.getOriginalFilename();
        String safeFilename = generateSafeFilename(originalFilename);
        
        // 保存文件
        String filePath = &quot;/uploads/&quot; + safeFilename;
        Files.copy(file.getInputStream(), Paths.get(filePath));
        
        return filePath;
    }
    
    private boolean isAllowedContentType(String contentType) {
        List&lt;String&gt; allowedTypes = Arrays.asList(
            &quot;image/jpeg&quot;,
            &quot;image/png&quot;,
            &quot;application/pdf&quot;,
            &quot;text/plain&quot;
        );
        return allowedTypes.contains(contentType);
    }
    
    private String generateSafeFilename(String originalFilename) {
        String extension = originalFilename.substring(originalFilename.lastIndexOf(&quot;.&quot;));
        return UUID.randomUUID().toString() + extension;
    }
}
</code></pre>
<h2>总结</h2>
<p>系统安全性保障是一个持续的过程，需要：</p>
<ol>
<li><strong>纵深防御</strong>：建立多层次的防护体系</li>
<li><strong>最小权限</strong>：遵循最小权限原则</li>
<li><strong>持续监控</strong>：建立完善的安全监控体系</li>
<li><strong>定期评估</strong>：定期进行安全评估和漏洞扫描</li>
<li><strong>应急响应</strong>：建立完善的应急响应机制</li>
</ol>
<p>通过这些措施，可以构建安全可靠的系统，有效防范各种安全威胁。</p>
</div></div></div></article></div></main></div><script src="/_next/static/chunks/webpack-c81f7fd28659d64f.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/eb4a34bff42c1814.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"2:I[2846,[],\"\"]\n5:I[4707,[],\"\"]\n8:I[6423,[],\"\"]\nb:I[1060,[],\"\"]\n6:[\"category\",\"notes\",\"d\"]\n7:[\"slug\",\"system-security-guarantee\",\"d\"]\nc:[]\n0:[\"$\",\"$L2\",null,{\"buildId\":\"build\",\"assetPrefix\":\"\",\"urlParts\":[\"\",\"notes\",\"system-security-guarantee\",\"\"],\"initialTree\":[\"\",{\"children\":[[\"category\",\"notes\",\"d\"],{\"children\":[[\"slug\",\"system-security-guarantee\",\"d\"],{\"children\":[\"__PAGE__?{\\\"category\\\":\\\"notes\\\",\\\"slug\\\":\\\"system-security-guarantee\\\"}\",{}]}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"category\",\"notes\",\"d\"],{\"children\":[[\"slug\",\"system-security-guarantee\",\"d\"],{\"children\":[\"__PAGE__\",{},[[\"$L3\",\"$L4\",null],null],null]},[null,[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$6\",\"children\",\"$7\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}]],null]},[null,[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$6\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}]],null]},[[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/eb4a34bff42c1814.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],\"$L9\"],null],null],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$La\"],\"globalErrorComponent\":\"$b\",\"missingSlots\":\"$Wc\"}]\n"])</script><script>self.__next_f.push([1,"d:I[2972,[\"972\",\"static/chunks/972-81dbad6abe39d3fa.js\",\"832\",\"static/chunks/832-7ea2624e20755f9f.js\",\"621\",\"static/chunks/app/%5Bcategory%5D/%5Bslug%5D/page-e466df95e55c7602.js\"],\"\"]\ne:I[2024,[\"972\",\"static/chunks/972-81dbad6abe39d3fa.js\",\"832\",\"static/chunks/832-7ea2624e20755f9f.js\",\"621\",\"static/chunks/app/%5Bcategory%5D/%5Bslug%5D/page-e466df95e55c7602.js\"],\"default\"]\n10:I[7140,[\"972\",\"static/chunks/972-81dbad6abe39d3fa.js\",\"185\",\"static/chunks/app/layout-3ed2f387fb22aa2c.js\"],\"default\"]\nf:T7131,"])</script><script>self.__next_f.push([1,"\n# 系统安全性保障\n\n\u003e 安全是系统的生命线，完善的安全防护体系是保障系统稳定运行的基石\n\n## 安全架构概述\n\n### 1. 安全体系架构\n\n```\n安全防护体系：\n├── 网络安全\n│   ├── 防火墙\n│   ├── DDoS防护\n│   ├── WAF\n│   └── VPN\n├── 应用安全\n│   ├── 身份认证\n│   ├── 权限控制\n│   ├── 数据加密\n│   └── 安全编码\n├── 数据安全\n│   ├── 数据加密\n│   ├── 数据脱敏\n│   ├── 数据备份\n│   └── 访问控制\n└── 运维安全\n    ├── 安全审计\n    ├── 漏洞扫描\n    ├── 入侵检测\n    └── 应急响应\n```\n\n### 2. 安全设计原则\n\n```\n安全设计原则：\n├── 纵深防御\n│   ├── 多层防护\n│   ├── 分段隔离\n│   └── 冗余备份\n├── 最小权限\n│   ├── 最小权限原则\n│   ├── 职责分离\n│   └── 权限管控\n├── 零信任\n│   ├── 永不信任\n│   ├── 始终验证\n│   └── 最小访问\n└── 默认安全\n    ├── 安全配置\n    ├── 安全默认\n    └── 安全加固\n```\n\n## 身份认证与授权\n\n### 1. 认证机制\n\n**JWT认证实现**\n```java\n@Component\npublic class JwtAuthenticationService {\n    \n    @Value(\"${jwt.secret}\")\n    private String jwtSecret;\n    \n    @Value(\"${jwt.expiration}\")\n    private int jwtExpiration;\n    \n    // 生成JWT Token\n    public String generateToken(UserDetails userDetails) {\n        Map\u003cString, Object\u003e claims = new HashMap\u003c\u003e();\n        claims.put(\"roles\", userDetails.getAuthorities());\n        claims.put(\"username\", userDetails.getUsername());\n        \n        return createToken(claims, userDetails.getUsername());\n    }\n    \n    private String createToken(Map\u003cString, Object\u003e claims, String subject) {\n        return Jwts.builder()\n            .setClaims(claims)\n            .setSubject(subject)\n            .setIssuedAt(new Date(System.currentTimeMillis()))\n            .setExpiration(new Date(System.currentTimeMillis() + jwtExpiration * 1000))\n            .signWith(SignatureAlgorithm.HS256, jwtSecret)\n            .compact();\n    }\n    \n    // 验证Token\n    public Boolean validateToken(String token, UserDetails userDetails) {\n        final String username = getUsernameFromToken(token);\n        return (username.equals(userDetails.getUsername()) \u0026\u0026 \n                !isTokenExpired(token));\n    }\n    \n    // 从Token中获取用户名\n    public String getUsernameFromToken(String token) {\n        return getClaimFromToken(token, Claims::getSubject);\n    }\n    \n    // 从Token中获取指定声明\n    public \u003cT\u003e T getClaimFromToken(String token, Function\u003cClaims, T\u003e claimsResolver) {\n        final Claims claims = getAllClaimsFromToken(token);\n        return claimsResolver.apply(claims);\n    }\n    \n    // 从Token中获取所有声明\n    private Claims getAllClaimsFromToken(String token) {\n        return Jwts.parser().setSigningKey(jwtSecret).parseClaimsJws(token).getBody();\n    }\n    \n    // 检查Token是否过期\n    private Boolean isTokenExpired(String token) {\n        final Date expiration = getExpirationDateFromToken(token);\n        return expiration.before(new Date());\n    }\n    \n    private Date getExpirationDateFromToken(String token) {\n        return getClaimFromToken(token, Claims::getExpiration);\n    }\n}\n```\n\n**OAuth2认证**\n```java\n@Configuration\n@EnableAuthorizationServer\npublic class AuthorizationServerConfig extends AuthorizationServerConfigurerAdapter {\n    \n    @Autowired\n    private AuthenticationManager authenticationManager;\n    \n    @Autowired\n    private UserDetailsService userDetailsService;\n    \n    @Override\n    public void configure(AuthorizationServerEndpointsConfigurer endpoints) {\n        endpoints\n            .authenticationManager(authenticationManager)\n            .userDetailsService(userDetailsService)\n            .accessTokenConverter(accessTokenConverter());\n    }\n    \n    @Bean\n    public JwtAccessTokenConverter accessTokenConverter() {\n        JwtAccessTokenConverter converter = new JwtAccessTokenConverter();\n        converter.setSigningKey(\"jwt-secret-key\");\n        return converter;\n    }\n    \n    @Override\n    public void configure(ClientDetailsServiceConfigurer clients) throws Exception {\n        clients.inMemory()\n            .withClient(\"client-id\")\n            .secret(\"client-secret\")\n            .authorizedGrantTypes(\"password\", \"refresh_token\")\n            .scopes(\"read\", \"write\")\n            .accessTokenValiditySeconds(3600)\n            .refreshTokenValiditySeconds(18000);\n    }\n}\n```\n\n### 2. 权限控制\n\n**RBAC权限控制**\n```java\n// 角色实体\n@Entity\npublic class Role {\n    @Id\n    private Long id;\n    private String name;\n    private String description;\n    \n    @ManyToMany(fetch = FetchType.EAGER)\n    @JoinTable(\n        name = \"role_permission\",\n        joinColumns = @JoinColumn(name = \"role_id\"),\n        inverseJoinColumns = @JoinColumn(name = \"permission_id\")\n    )\n    private Set\u003cPermission\u003e permissions;\n}\n\n// 权限实体\n@Entity\npublic class Permission {\n    @Id\n    private Long id;\n    private String name;\n    private String resource;\n    private String action;\n}\n\n// 权限检查注解\n@Target({ElementType.METHOD, ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@PreAuthorize(\"hasPermission(#id, 'USER', 'READ')\")\npublic @interface RequirePermission {\n    String resource();\n    String action();\n}\n\n// 权限检查切面\n@Aspect\n@Component\npublic class PermissionAspect {\n    \n    @Autowired\n    private PermissionService permissionService;\n    \n    @Before(\"@annotation(requirePermission)\")\n    public void checkPermission(JoinPoint joinPoint, RequirePermission requirePermission) {\n        // 获取当前用户\n        User currentUser = SecurityContextHolder.getContext()\n            .getAuthentication().getPrincipal();\n        \n        // 获取资源ID\n        Long resourceId = getResourceId(joinPoint);\n        \n        // 检查权限\n        boolean hasPermission = permissionService.hasPermission(\n            currentUser.getId(), \n            resourceId, \n            requirePermission.resource(), \n            requirePermission.action()\n        );\n        \n        if (!hasPermission) {\n            throw new AccessDeniedException(\"权限不足\");\n        }\n    }\n    \n    private Long getResourceId(JoinPoint joinPoint) {\n        // 从方法参数中提取资源ID\n        Object[] args = joinPoint.getArgs();\n        for (Object arg : args) {\n            if (arg instanceof Long) {\n                return (Long) arg;\n            }\n        }\n        return null;\n    }\n}\n```\n\n## 数据安全防护\n\n### 1. 数据加密\n\n**对称加密**\n```java\n@Component\npublic class EncryptionService {\n    \n    private static final String ALGORITHM = \"AES\";\n    private static final String TRANSFORMATION = \"AES/CBC/PKCS5Padding\";\n    \n    @Value(\"${encryption.key}\")\n    private String encryptionKey;\n    \n    // 加密\n    public String encrypt(String data) throws Exception {\n        SecretKeySpec secretKey = new SecretKeySpec(\n            encryptionKey.getBytes(), ALGORITHM);\n        IvParameterSpec ivParameterSpec = new IvParameterSpec(\n            encryptionKey.getBytes());\n        \n        Cipher cipher = Cipher.getInstance(TRANSFORMATION);\n        cipher.init(Cipher.ENCRYPT_MODE, secretKey, ivParameterSpec);\n        \n        byte[] encrypted = cipher.doFinal(data.getBytes());\n        return Base64.getEncoder().encodeToString(encrypted);\n    }\n    \n    // 解密\n    public String decrypt(String encryptedData) throws Exception {\n        SecretKeySpec secretKey = new SecretKeySpec(\n            encryptionKey.getBytes(), ALGORITHM);\n        IvParameterSpec ivParameterSpec = new IvParameterSpec(\n            encryptionKey.getBytes());\n        \n        Cipher cipher = Cipher.getInstance(TRANSFORMATION);\n        cipher.init(Cipher.DECRYPT_MODE, secretKey, ivParameterSpec);\n        \n        byte[] decoded = Base64.getDecoder().decode(encryptedData);\n        byte[] decrypted = cipher.doFinal(decoded);\n        \n        return new String(decrypted);\n    }\n}\n```\n\n**非对称加密**\n```java\n@Component\npublic class RSAEncryptionService {\n    \n    private static final String ALGORITHM = \"RSA\";\n    \n    // 生成密钥对\n    public KeyPair generateKeyPair() throws Exception {\n        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(ALGORITHM);\n        keyPairGenerator.initialize(2048);\n        return keyPairGenerator.generateKeyPair();\n    }\n    \n    // 公钥加密\n    public String encrypt(String data, PublicKey publicKey) throws Exception {\n        Cipher cipher = Cipher.getInstance(ALGORITHM);\n        cipher.init(Cipher.ENCRYPT_MODE, publicKey);\n        \n        byte[] encrypted = cipher.doFinal(data.getBytes());\n        return Base64.getEncoder().encodeToString(encrypted);\n    }\n    \n    // 私钥解密\n    public String decrypt(String encryptedData, PrivateKey privateKey) throws Exception {\n        Cipher cipher = Cipher.getInstance(ALGORITHM);\n        cipher.init(Cipher.DECRYPT_MODE, privateKey);\n        \n        byte[] decoded = Base64.getDecoder().decode(encryptedData);\n        byte[] decrypted = cipher.doFinal(decoded);\n        \n        return new String(decrypted);\n    }\n    \n    // 数字签名\n    public String sign(String data, PrivateKey privateKey) throws Exception {\n        Signature signature = Signature.getInstance(\"SHA256withRSA\");\n        signature.initSign(privateKey);\n        signature.update(data.getBytes());\n        \n        byte[] signBytes = signature.sign();\n        return Base64.getEncoder().encodeToString(signBytes);\n    }\n    \n    // 验证签名\n    public boolean verify(String data, String sign, PublicKey publicKey) throws Exception {\n        Signature signature = Signature.getInstance(\"SHA256withRSA\");\n        signature.initVerify(publicKey);\n        signature.update(data.getBytes());\n        \n        byte[] signBytes = Base64.getDecoder().decode(sign);\n        return signature.verify(signBytes);\n    }\n}\n```\n\n### 2. 数据脱敏\n\n**敏感数据脱敏**\n```java\n@Component\npublic class DataMaskingService {\n    \n    // 手机号脱敏\n    public String maskPhone(String phone) {\n        if (phone == null || phone.length() \u003c 11) {\n            return phone;\n        }\n        return phone.substring(0, 3) + \"****\" + phone.substring(7);\n    }\n    \n    // 邮箱脱敏\n    public String maskEmail(String email) {\n        if (email == null) {\n            return null;\n        }\n        \n        int atIndex = email.indexOf(\"@\");\n        if (atIndex \u003c= 1) {\n            return email;\n        }\n        \n        String username = email.substring(0, atIndex);\n        String domain = email.substring(atIndex);\n        \n        if (username.length() \u003c= 2) {\n            return username.charAt(0) + \"***\" + domain;\n        }\n        \n        return username.charAt(0) + \"***\" + \n               username.charAt(username.length() - 1) + domain;\n    }\n    \n    // 身份证脱敏\n    public String maskIdCard(String idCard) {\n        if (idCard == null || idCard.length() \u003c 8) {\n            return idCard;\n        }\n        return idCard.substring(0, 4) + \"**********\" + \n               idCard.substring(idCard.length() - 4);\n    }\n    \n    // 银行卡脱敏\n    public String maskBankCard(String bankCard) {\n        if (bankCard == null || bankCard.length() \u003c 8) {\n            return bankCard;\n        }\n        return bankCard.substring(0, 4) + \" **** **** \" + \n               bankCard.substring(bankCard.length() - 4);\n    }\n}\n\n// 脱敏注解\n@Target(ElementType.FIELD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface DataMasking {\n    MaskType type() default MaskType.NONE;\n}\n\n// 脱敏类型\npublic enum MaskType {\n    PHONE, EMAIL, ID_CARD, BANK_CARD, NAME\n}\n\n// 脱敏切面\n@Aspect\n@Component\npublic class DataMaskingAspect {\n    \n    @Autowired\n    private DataMaskingService maskingService;\n    \n    @Around(\"@annotation(org.springframework.web.bind.annotation.GetMapping)\")\n    public Object maskResponseData(ProceedingJoinPoint joinPoint) throws Throwable {\n        Object result = joinPoint.proceed();\n        \n        if (result instanceof ResponseEntity) {\n            ResponseEntity\u003c?\u003e response = (ResponseEntity\u003c?\u003e) result;\n            Object body = response.getBody();\n            \n            if (body != null) {\n                Object maskedBody = maskObject(body);\n                return new ResponseEntity\u003c\u003e(maskedBody, response.getHeaders(), \n                    response.getStatusCode());\n            }\n        }\n        \n        return result;\n    }\n    \n    private Object maskObject(Object obj) {\n        if (obj == null) {\n            return null;\n        }\n        \n        Class\u003c?\u003e clazz = obj.getClass();\n        \n        for (Field field : clazz.getDeclaredFields()) {\n            DataMasking annotation = field.getAnnotation(DataMasking.class);\n            if (annotation != null \u0026\u0026 annotation.type() != MaskType.NONE) {\n                field.setAccessible(true);\n                try {\n                    Object value = field.get(obj);\n                    if (value instanceof String) {\n                        String maskedValue = maskValue((String) value, annotation.type());\n                        field.set(obj, maskedValue);\n                    }\n                } catch (IllegalAccessException e) {\n                    // 日志记录\n                }\n            }\n        }\n        \n        return obj;\n    }\n    \n    private String maskValue(String value, MaskType type) {\n        switch (type) {\n            case PHONE:\n                return maskingService.maskPhone(value);\n            case EMAIL:\n                return maskingService.maskEmail(value);\n            case ID_CARD:\n                return maskingService.maskIdCard(value);\n            case BANK_CARD:\n                return maskingService.maskBankCard(value);\n            default:\n                return value;\n        }\n    }\n}\n```\n\n## 网络安全防护\n\n### 1. Web应用防火墙\n\n**WAF规则配置**\n```java\n@Component\npublic class WebApplicationFirewall {\n    \n    // SQL注入检测\n    public boolean detectSqlInjection(String input) {\n        String[] sqlPatterns = {\n            \"('|(\\\\-\\\\-)|(;)|(\\\\||\\\\|)|(\\\\*|\\\\*))\",\n            \"(exec(\\\\s|\\\\+)+(s|x)p\\\\w+)\",\n            \"insert(\\\\s|\\\\+)into\",\n            \"delete(\\\\s|\\\\+)from\",\n            \"select(\\\\s|\\\\+).*from\",\n            \"update(\\\\s|\\\\+).*set\",\n            \"union(\\\\s|\\\\+)select\"\n        };\n        \n        for (String pattern : sqlPatterns) {\n            if (input.toLowerCase().matches(\".*\" + pattern + \".*\")) {\n                return true;\n            }\n        }\n        \n        return false;\n    }\n    \n    // XSS攻击检测\n    public boolean detectXss(String input) {\n        String[] xssPatterns = {\n            \"\u003cscript\",\n            \"\u003c/script\u003e\",\n            \"\u003ciframe\",\n            \"javascript:\",\n            \"vbscript:\",\n            \"onload=\",\n            \"onerror=\",\n            \"onclick=\"\n        };\n        \n        for (String pattern : xssPatterns) {\n            if (input.toLowerCase().contains(pattern)) {\n                return true;\n            }\n        }\n        \n        return false;\n    }\n    \n    // CSRF防护\n    public String generateCsrfToken(HttpServletRequest request) {\n        String token = UUID.randomUUID().toString();\n        request.getSession().setAttribute(\"csrf_token\", token);\n        return token;\n    }\n    \n    public boolean validateCsrfToken(HttpServletRequest request, String token) {\n        String sessionToken = (String) request.getSession().getAttribute(\"csrf_token\");\n        return sessionToken != null \u0026\u0026 sessionToken.equals(token);\n    }\n}\n\n// WAF过滤器\n@Component\npublic class SecurityFilter implements Filter {\n    \n    @Autowired\n    private WebApplicationFirewall waf;\n    \n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response, \n                        FilterChain chain) throws IOException, ServletException {\n        \n        HttpServletRequest httpRequest = (HttpServletRequest) request;\n        HttpServletResponse httpResponse = (HttpServletResponse) response;\n        \n        // 检查SQL注入\n        String queryString = httpRequest.getQueryString();\n        if (queryString != null \u0026\u0026 waf.detectSqlInjection(queryString)) {\n            httpResponse.sendError(HttpServletResponse.SC_BAD_REQUEST, \"SQL注入攻击\");\n            return;\n        }\n        \n        // 检查XSS攻击\n        String userAgent = httpRequest.getHeader(\"User-Agent\");\n        if (userAgent != null \u0026\u0026 waf.detectXss(userAgent)) {\n            httpResponse.sendError(HttpServletResponse.SC_BAD_REQUEST, \"XSS攻击\");\n            return;\n        }\n        \n        chain.doFilter(request, response);\n    }\n}\n```\n\n### 2. DDoS防护\n\n**限流防护**\n```java\n@Component\npublic class RateLimitingService {\n    \n    private final Map\u003cString, Bucket\u003e buckets = new ConcurrentHashMap\u003c\u003e();\n    \n    // 令牌桶限流\n    public boolean allowRequest(String clientId, int capacity, double refillRate) {\n        Bucket bucket = buckets.computeIfAbsent(clientId, id -\u003e {\n            Refill refill = Refill.intervently(capacity, Duration.ofSeconds((int) (capacity / refillRate)));\n            return Bucket.builder()\n                .addLimit(Bandwidth.classic(capacity, refill))\n                .build();\n        });\n        \n        return bucket.tryConsume(1);\n    }\n    \n    // IP级别限流\n    @Component\n    public class IpRateLimitingFilter implements Filter {\n        \n        @Autowired\n        private RateLimitingService rateLimitingService;\n        \n        @Override\n        public void doFilter(ServletRequest request, ServletResponse response, \n                            FilterChain chain) throws IOException, ServletException {\n            \n            HttpServletRequest httpRequest = (HttpServletRequest) request;\n            HttpServletResponse httpResponse = (HttpServletResponse) response;\n            \n            String clientIp = getClientIp(httpRequest);\n            \n            // 每个IP每分钟最多100个请求\n            if (!rateLimitingService.allowRequest(clientIp, 100, 100/60.0)) {\n                httpResponse.sendError(HttpServletResponse.SC_TOO_MANY_REQUESTS, \"请求过于频繁\");\n                return;\n            }\n            \n            chain.doFilter(request, response);\n        }\n        \n        private String getClientIp(HttpServletRequest request) {\n            String xForwardedFor = request.getHeader(\"X-Forwarded-For\");\n            if (xForwardedFor != null \u0026\u0026 !xForwardedFor.isEmpty()) {\n                return xForwardedFor.split(\",\")[0].trim();\n            }\n            \n            return request.getRemoteAddr();\n        }\n    }\n}\n```\n\n## 安全监控与审计\n\n### 1. 安全日志\n\n**安全事件记录**\n```java\n@Component\npublic class SecurityAuditService {\n    \n    @Autowired\n    private AuditLogRepository auditLogRepository;\n    \n    // 记录登录事件\n    public void recordLogin(String username, String ip, boolean success) {\n        AuditLog log = new AuditLog();\n        log.setEventType(\"LOGIN\");\n        log.setUsername(username);\n        log.setIpAddress(ip);\n        log.setSuccess(success);\n        log.setEventTime(new Date());\n        log.setDescription(success ? \"登录成功\" : \"登录失败\");\n        \n        auditLogRepository.save(log);\n        \n        // 异步发送到日志系统\n        asyncSendToLogSystem(log);\n    }\n    \n    // 记录权限变更事件\n    public void recordPermissionChange(String operator, String targetUser, \n                                    String resource, String action) {\n        AuditLog log = new AuditLog();\n        log.setEventType(\"PERMISSION_CHANGE\");\n        log.setUsername(operator);\n        log.setTargetUser(targetUser);\n        log.setResource(resource);\n        log.setAction(action);\n        log.setEventTime(new Date());\n        log.setDescription(\"权限变更: \" + targetUser + \" \" + action + \" \" + resource);\n        \n        auditLogRepository.save(log);\n        asyncSendToLogSystem(log);\n    }\n    \n    // 记录数据访问事件\n    public void recordDataAccess(String username, String resource, \n                               String action, boolean success) {\n        AuditLog log = new AuditLog();\n        log.setEventType(\"DATA_ACCESS\");\n        log.setUsername(username);\n        log.setResource(resource);\n        log.setAction(action);\n        log.setSuccess(success);\n        log.setEventTime(new Date());\n        log.setDescription(\"数据访问: \" + username + \" \" + action + \" \" + resource);\n        \n        auditLogRepository.save(log);\n        asyncSendToLogSystem(log);\n    }\n    \n    private void asyncSendToLogSystem(AuditLog log) {\n        // 异步发送到ELK、Splunk等日志系统\n        CompletableFuture.runAsync(() -\u003e {\n            try {\n                // 发送逻辑\n                logSystemClient.send(log);\n            } catch (Exception e) {\n                // 错误处理\n            }\n        });\n    }\n}\n```\n\n### 2. 入侵检测\n\n**异常行为检测**\n```java\n@Component\npublic class IntrusionDetectionService {\n    \n    @Autowired\n    private SecurityAuditService auditService;\n    \n    // 检测异常登录\n    public void detectAnomalousLogin(String username, String ip) {\n        // 检查是否为新IP登录\n        if (isNewIpForUser(username, ip)) {\n            auditService.recordSecurityEvent(\"NEW_IP_LOGIN\", username, ip);\n        }\n        \n        // 检查是否为异地登录\n        if (isRemoteLogin(username, ip)) {\n            auditService.recordSecurityEvent(\"REMOTE_LOGIN\", username, ip);\n        }\n        \n        // 检查登录频率异常\n        if (isHighFrequencyLogin(username, ip)) {\n            auditService.recordSecurityEvent(\"HIGH_FREQUENCY_LOGIN\", username, ip);\n        }\n    }\n    \n    // 检测异常数据访问\n    public void detectAnomalousDataAccess(String username, String resource) {\n        // 检查是否为非工作时间访问\n        if (isAfterHoursAccess()) {\n            auditService.recordSecurityEvent(\"AFTER_HOURS_ACCESS\", username, resource);\n        }\n        \n        // 检查是否为大批量数据访问\n        if (isBulkDataAccess(username, resource)) {\n            auditService.recordSecurityEvent(\"BULK_DATA_ACCESS\", username, resource);\n        }\n        \n        // 检查是否为敏感数据访问\n        if (isSensitiveDataAccess(resource)) {\n            auditService.recordSecurityEvent(\"SENSITIVE_DATA_ACCESS\", username, resource);\n        }\n    }\n    \n    private boolean isNewIpForUser(String username, String ip) {\n        // 检查用户历史登录IP\n        List\u003cString\u003e historicalIps = getHistoricalIps(username);\n        return !historicalIps.contains(ip);\n    }\n    \n    private boolean isRemoteLogin(String username, String ip) {\n        // 检查IP地理位置\n        String location = getLocationByIp(ip);\n        String usualLocation = getUserUsualLocation(username);\n        return !location.equals(usualLocation);\n    }\n    \n    private boolean isHighFrequencyLogin(String username, String ip) {\n        // 检查最近5分钟内登录次数\n        int recentLogins = getRecentLoginCount(username, ip, 5);\n        return recentLogins \u003e 10;\n    }\n    \n    private boolean isAfterHoursAccess() {\n        int hour = LocalTime.now().getHour();\n        return hour \u003c 9 || hour \u003e 18;\n    }\n    \n    private boolean isBulkDataAccess(String username, String resource) {\n        // 检查最近1小时内的访问次数\n        int recentAccess = getRecentAccessCount(username, resource, 60);\n        return recentAccess \u003e 1000;\n    }\n    \n    private boolean isSensitiveDataAccess(String resource) {\n        // 检查是否为敏感资源\n        return resource.contains(\"admin\") || \n               resource.contains(\"config\") || \n               resource.contains(\"password\");\n    }\n}\n```\n\n## 漏洞管理\n\n### 1. 漏洞扫描\n\n**自动化漏洞扫描**\n```java\n@Component\npublic class VulnerabilityScanner {\n    \n    // SQL注入漏洞扫描\n    public List\u003cVulnerability\u003e scanSqlInjection(String target) {\n        List\u003cVulnerability\u003e vulnerabilities = new ArrayList\u003c\u003e();\n        \n        String[] payloads = {\n            \"' OR '1'='1\",\n            \"' UNION SELECT NULL--\",\n            \"'; DROP TABLE users--\"\n        };\n        \n        for (String payload : payloads) {\n            try {\n                String testUrl = target + \"?id=\" + URLEncoder.encode(payload, \"UTF-8\");\n                HttpResponse response = httpClient.execute(new HttpGet(testUrl));\n                \n                if (response.getEntity() != null \u0026\u0026 \n                    response.getEntity().getContentLength() \u003e 0) {\n                    \n                    Vulnerability vuln = new Vulnerability();\n                    vuln.setType(\"SQL_INJECTION\");\n                    vuln.setSeverity(\"HIGH\");\n                    vuln.setDescription(\"发现SQL注入漏洞\");\n                    vuln.setPayload(payload);\n                    vulnerabilities.add(vuln);\n                }\n            } catch (Exception e) {\n                // 忽略异常\n            }\n        }\n        \n        return vulnerabilities;\n    }\n    \n    // XSS漏洞扫描\n    public List\u003cVulnerability\u003e scanXss(String target) {\n        List\u003cVulnerability\u003e vulnerabilities = new ArrayList\u003c\u003e();\n        \n        String[] payloads = {\n            \"\u003cscript\u003ealert('XSS')\u003c/script\u003e\",\n            \"\u003cimg src=x onerror=alert('XSS')\u003e\",\n            \"javascript:alert('XSS')\"\n        };\n        \n        for (String payload : payloads) {\n            try {\n                String testUrl = target + \"?search=\" + URLEncoder.encode(payload, \"UTF-8\");\n                HttpResponse response = httpClient.execute(new HttpGet(testUrl));\n                \n                String content = EntityUtils.toString(response.getEntity());\n                if (content.contains(payload)) {\n                    Vulnerability vuln = new Vulnerability();\n                    vuln.setType(\"XSS\");\n                    vuln.setSeverity(\"MEDIUM\");\n                    vuln.setDescription(\"发现XSS漏洞\");\n                    vuln.setPayload(payload);\n                    vulnerabilities.add(vuln);\n                }\n            } catch (Exception e) {\n                // 忽略异常\n            }\n        }\n        \n        return vulnerabilities;\n    }\n}\n```\n\n### 2. 漏洞修复\n\n**安全编码规范**\n```java\n@Component\npublic class SecureCodingService {\n    \n    // 安全的SQL查询\n    public User getUserById(Long id) {\n        // 使用参数化查询防止SQL注入\n        String sql = \"SELECT * FROM users WHERE id = ?\";\n        return jdbcTemplate.queryForObject(sql, new Object[]{id}, new UserRowMapper());\n    }\n    \n    // 安全的输入验证\n    public boolean validateInput(String input, String pattern) {\n        if (input == null) {\n            return false;\n        }\n        \n        // 使用白名单验证\n        return input.matches(pattern);\n    }\n    \n    // 安全的文件上传\n    public String uploadFile(MultipartFile file) throws IOException {\n        // 验证文件类型\n        String contentType = file.getContentType();\n        if (!isAllowedContentType(contentType)) {\n            throw new SecurityException(\"不支持的文件类型\");\n        }\n        \n        // 验证文件大小\n        if (file.getSize() \u003e 10 * 1024 * 1024) { // 10MB\n            throw new SecurityException(\"文件过大\");\n        }\n        \n        // 生成安全的文件名\n        String originalFilename = file.getOriginalFilename();\n        String safeFilename = generateSafeFilename(originalFilename);\n        \n        // 保存文件\n        String filePath = \"/uploads/\" + safeFilename;\n        Files.copy(file.getInputStream(), Paths.get(filePath));\n        \n        return filePath;\n    }\n    \n    private boolean isAllowedContentType(String contentType) {\n        List\u003cString\u003e allowedTypes = Arrays.asList(\n            \"image/jpeg\",\n            \"image/png\",\n            \"application/pdf\",\n            \"text/plain\"\n        );\n        return allowedTypes.contains(contentType);\n    }\n    \n    private String generateSafeFilename(String originalFilename) {\n        String extension = originalFilename.substring(originalFilename.lastIndexOf(\".\"));\n        return UUID.randomUUID().toString() + extension;\n    }\n}\n```\n\n## 总结\n\n系统安全性保障是一个持续的过程，需要：\n\n1. **纵深防御**：建立多层次的防护体系\n2. **最小权限**：遵循最小权限原则\n3. **持续监控**：建立完善的安全监控体系\n4. **定期评估**：定期进行安全评估和漏洞扫描\n5. **应急响应**：建立完善的应急响应机制\n\n通过这些措施，可以构建安全可靠的系统，有效防范各种安全威胁。"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"children\":[[\"$\",\"$Ld\",null,{\"href\":\"/notes\",\"className\":\"back-button\",\"style\":{\"display\":\"inline-block\",\"background\":\"var(--primary-color)\",\"color\":\"white\",\"border\":\"none\",\"padding\":\"10px 20px\",\"borderRadius\":\"6px\",\"cursor\":\"pointer\",\"marginBottom\":\"20px\",\"textDecoration\":\"none\"},\"children\":[\"← 返回\",\"笔记\",\"列表\"]}],[\"$\",\"article\",null,{\"className\":\"section\",\"children\":[[\"$\",\"header\",null,{\"className\":\"article-header\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"article-title\",\"children\":\"系统安全性保障\"}],[\"$\",\"div\",null,{\"className\":\"article-meta\",\"children\":[\"$\",\"div\",null,{\"className\":\"article-tags\",\"children\":[[\"$\",\"span\",\"系统安全\",{\"className\":\"tag\",\"children\":\"系统安全\"}],[\"$\",\"span\",\"安全架构\",{\"className\":\"tag\",\"children\":\"安全架构\"}],[\"$\",\"span\",\"防护措施\",{\"className\":\"tag\",\"children\":\"防护措施\"}],[\"$\",\"span\",\"安全监控\",{\"className\":\"tag\",\"children\":\"安全监控\"}],[\"$\",\"span\",\"漏洞防护\",{\"className\":\"tag\",\"children\":\"漏洞防护\"}]]}]}]]}],[\"$\",\"div\",null,{\"className\":\"card markdown-content\",\"children\":[\"$\",\"$Le\",null,{\"content\":\"$f\"}]}]]}]]}]\n"])</script><script>self.__next_f.push([1,"9:[\"$\",\"html\",null,{\"lang\":\"zh-CN\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"link\",null,{\"rel\":\"stylesheet\",\"href\":\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css\"}],[\"$\",\"link\",null,{\"rel\":\"stylesheet\",\"href\":\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css\"}],[\"$\",\"script\",null,{\"src\":\"https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js\"}]]}],[\"$\",\"body\",null,{\"children\":[\"$\",\"div\",null,{\"className\":\"app\",\"children\":[[\"$\",\"$L10\",null,{\"siteConfig\":{\"name\":\"Rudy Yang\",\"bio\":\"JAVA | AI | WEB3\",\"social\":[{\"name\":\"github\",\"icon\":\"fab fa-github\",\"url\":\"https://github.com/suogongy\"},{\"name\":\"twitter\",\"icon\":\"fab fa-twitter\",\"url\":\"https://twitter.com/suogongy\"},{\"name\":\"email\",\"icon\":\"fas fa-envelope\",\"url\":\"mailto:haiyuan1832@163.com\"}]}}],[\"$\",\"main\",null,{\"className\":\"main-content\",\"children\":[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"系统安全性保障 - Personal GitHub Page\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"全面介绍系统安全架构设计、安全防护措施、安全漏洞防护和安全监控体系建设，帮助构建安全可靠的系统。\"}]]\n3:null\n"])</script></body></html>