3:I[4707,[],""]
6:I[6423,[],""]
4:["category","notes","d"]
5:["slug","popular-message-queues","d"]
0:["build",[[["",{"children":[["category","notes","d"],{"children":[["slug","popular-message-queues","d"],{"children":["__PAGE__?{\"category\":\"notes\",\"slug\":\"popular-message-queues\"}",{}]}]}]},"$undefined","$undefined",true],["",{"children":[["category","notes","d"],{"children":[["slug","popular-message-queues","d"],{"children":["__PAGE__",{},[["$L1","$L2",null],null],null]},[null,["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","$4","children","$5","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L6",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined"}]],null]},[null,["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","$4","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L6",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined"}]],null]},[[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/55b7a9e84b417e65.css","precedence":"next","crossOrigin":"$undefined"}]],"$L7"],null],null],["$L8",null]]]]
9:I[2972,["972","static/chunks/972-17ea62b17795b286.js","621","static/chunks/app/%5Bcategory%5D/%5Bslug%5D/page-e1b46fcdbbb20f68.js"],""]
b:I[7140,["972","static/chunks/972-17ea62b17795b286.js","185","static/chunks/app/layout-ca71fef930ed4111.js"],"default"]
a:T5b5f,<h1>热门MQ详解</h1>
<blockquote>
<p>消息队列是分布式系统的重要组件，选择合适的MQ对系统架构至关重要</p>
</blockquote>
<h2>消息队列概述</h2>
<h3>1. 消息队列的作用</h3>
<pre><code>消息队列核心价值：
├── 解耦
│   ├── 生产者与消费者解耦
│   ├── 业务逻辑与技术实现解耦
│   └── 系统模块间解耦
├── 异步
│   ├── 提升系统响应速度
│   ├── 改善用户体验
│   └── 提高系统吞吐量
├── 削峰
│   ├── 平滑流量峰值
│   ├── 保护后端系统
│   └── 提升系统稳定性
└── 可靠性
    ├── 消息持久化
    ├── 重试机制
    └── 事务支持
</code></pre>
<h3>2. 主流MQ对比</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>Kafka</th>
<th>RocketMQ</th>
<th>RabbitMQ</th>
<th>ActiveMQ</th>
</tr>
</thead>
<tbody><tr>
<td>吞吐量</td>
<td>极高</td>
<td>高</td>
<td>中等</td>
<td>中等</td>
</tr>
<tr>
<td>延迟</td>
<td>低</td>
<td>低</td>
<td>低</td>
<td>中等</td>
</tr>
<tr>
<td>可靠性</td>
<td>高</td>
<td>高</td>
<td>高</td>
<td>中等</td>
</tr>
<tr>
<td>复杂度</td>
<td>高</td>
<td>中等</td>
<td>低</td>
<td>低</td>
</tr>
<tr>
<td>生态</td>
<td>丰富</td>
<td>良好</td>
<td>一般</td>
<td>一般</td>
</tr>
</tbody></table>
<h2>Kafka详解</h2>
<h3>1. Kafka架构</h3>
<pre><code>Kafka架构图：
┌─────────────────────────────────────────────────────────────┐
│                    Kafka Cluster                            │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐           │
│  │  Broker 1   │  │  Broker 2   │  │  Broker 3   │           │
│  │             │  │             │  │             │           │
│  │ ┌─────────┐ │  │ ┌─────────┐ │  │ ┌─────────┐ │           │
│  │ │ Topic A │ │  │ │ Topic A │ │  │ │ Topic A │ │           │
│  │ └─────────┘ │  │ └─────────┘ │  │ └─────────┘ │           │
│  │ ┌─────────┐ │  │ ┌─────────┐ │  │ ┌─────────┐ │           │
│  │ │ Topic B │ │  │ │ Topic B │ │  │ │ Topic B │ │           │
│  │ └─────────┘ │  │ └─────────┘ │  │ └─────────┘ │           │
│  └─────────────┘  └─────────────┘  └─────────────┘           │
└─────────────────────────────────────────────────────────────┘
         ↑                    ↑                    ↑
    ┌─────────────┐     ┌─────────────┐     ┌─────────────┐
    │   Producer  │     │  Producer   │     │  Producer   │
    └─────────────┘     └─────────────┘     └─────────────┘
         ↓                    ↓                    ↓
    ┌─────────────┐     ┌─────────────┐     ┌─────────────┐
    │   Consumer  │     │  Consumer   │     │  Consumer   │
    │    Group    │     │   Group     │     │   Group     │
    └─────────────┘     └─────────────┘     └─────────────┘
</code></pre>
<h3>2. Kafka核心概念</h3>
<p><strong>Partition机制</strong></p>
<pre><code class="language-java">// Kafka生产者配置
Properties props = new Properties();
props.put(&quot;bootstrap.servers&quot;, &quot;localhost:9092&quot;);
props.put(&quot;key.serializer&quot;, &quot;org.apache.kafka.common.serialization.StringSerializer&quot;);
props.put(&quot;value.serializer&quot;, &quot;org.apache.kafka.common.serialization.StringSerializer&quot;);

// 创建生产者
KafkaProducer&lt;String, String&gt; producer = new KafkaProducer&lt;&gt;(props);

// 发送消息（指定分区）
ProducerRecord&lt;String, String&gt; record = 
    new ProducerRecord&lt;&gt;(&quot;topic-name&quot;, 0, &quot;key&quot;, &quot;value&quot;);

// 自定义分区策略
public class CustomPartitioner implements Partitioner {
    @Override
    public int partition(String topic, Object key, byte[] keyBytes, 
                       Object value, byte[] valueBytes, Cluster cluster) {
        // 自定义分区逻辑
        return Math.abs(key.hashCode()) % cluster.partitionCountForTopic(topic);
    }
}
</code></pre>
<p><strong>Consumer Group</strong></p>
<pre><code class="language-java">// Kafka消费者配置
Properties props = new Properties();
props.put(&quot;bootstrap.servers&quot;, &quot;localhost:9092&quot;);
props.put(&quot;group.id&quot;, &quot;consumer-group-1&quot;);
props.put(&quot;enable.auto.commit&quot;, &quot;true&quot;);
props.put(&quot;auto.commit.interval.ms&quot;, &quot;1000&quot;);
props.put(&quot;key.deserializer&quot;, &quot;org.apache.kafka.common.serialization.StringDeserializer&quot;);
props.put(&quot;value.deserializer&quot;, &quot;org.apache.kafka.common.serialization.StringDeserializer&quot;);

// 创建消费者
KafkaConsumer&lt;String, String&gt; consumer = new KafkaConsumer&lt;&gt;(props);

// 订阅主题
consumer.subscribe(Arrays.asList(&quot;topic-1&quot;, &quot;topic-2&quot;));

// 消费消息
while (true) {
    ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(100));
    for (ConsumerRecord&lt;String, String&gt; record : records) {
        System.out.printf(&quot;offset = %d, key = %s, value = %s%n&quot;, 
                         record.offset(), record.key(), record.value());
    }
}
</code></pre>
<h3>3. Kafka性能优化</h3>
<p><strong>生产者优化</strong></p>
<pre><code class="language-java">// 生产者性能优化配置
props.put(&quot;batch.size&quot;, 16384);           // 批量大小
props.put(&quot;linger.ms&quot;, 5);               // 等待时间
props.put(&quot;compression.type&quot;, &quot;snappy&quot;); // 压缩类型
props.put(&quot;acks&quot;, &quot;all&quot;);                // 确认机制
props.put(&quot;retries&quot;, 3);                 // 重试次数
props.put(&quot;max.in.flight.requests.per.connection&quot;, 5);

// 异步发送优化
List&lt;Future&lt;RecordMetadata&gt;&gt; futures = new ArrayList&lt;&gt;();

for (int i = 0; i &lt; 1000; i++) {
    ProducerRecord&lt;String, String&gt; record = 
        new ProducerRecord&lt;&gt;(&quot;topic-name&quot;, &quot;key-&quot; + i, &quot;value-&quot; + i);
    
    Future&lt;RecordMetadata&gt; future = producer.send(record, (metadata, exception) -&gt; {
        if (exception != null) {
            // 处理发送失败
            exception.printStackTrace();
        }
    });
    
    futures.add(future);
}

// 等待所有消息发送完成
for (Future&lt;RecordMetadata&gt; future : futures) {
    try {
        future.get();
    } catch (Exception e) {
        e.printStackTrace();
    }
}
</code></pre>
<h2>RocketMQ详解</h2>
<h3>1. RocketMQ架构</h3>
<pre><code>RocketMQ架构图：
┌─────────────────────────────────────────────────────────────┐
│                    Name Server                              │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐           │
│  │ NameServer1 │  │ NameServer2 │  │ NameServer3 │           │
│  └─────────────┘  └─────────────┘  └─────────────┘           │
└─────────────────────────────────────────────────────────────┘
         ↓                    ↓                    ↓
┌─────────────────────────────────────────────────────────────┐
│                    Broker Cluster                           │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐           │
│  │  Master 1   │  │  Master 2   │  │  Master 3   │           │
│  │             │  │             │  │             │           │
│  │ ┌─────────┐ │  │ ┌─────────┐ │  │ ┌─────────┐ │           │
│  │ │ Topic A │ │  │ │ Topic B │ │  │ │ Topic C │ │           │
│  │ └─────────┘ │  │ └─────────┘ │  │ └─────────┘ │           │
│  └─────────────┘  └─────────────┘  └─────────────┘           │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐           │
│  │  Slave 1    │  │  Slave 2    │  │  Slave 3    │           │
│  └─────────────┘  └─────────────┘  └─────────────┘           │
└─────────────────────────────────────────────────────────────┘
         ↑                    ↑                    ↑
    ┌─────────────┐     ┌─────────────┐     ┌─────────────┐
    │   Producer  │     │  Producer   │     │  Producer   │
    └─────────────┘     └─────────────┘     └─────────────┘
         ↓                    ↓                    ↓
    ┌─────────────┐     ┌─────────────┐     ┌─────────────┐
    │   Consumer  │     │  Consumer   │     │  Consumer   │
    └─────────────┘     └─────────────┘     └─────────────┘
</code></pre>
<h3>2. RocketMQ特性</h3>
<p><strong>事务消息</strong></p>
<pre><code class="language-java">// 事务消息生产者
TransactionMQProducer producer = new TransactionMQProducer(&quot;transaction-producer-group&quot;);
producer.setNamesrvAddr(&quot;localhost:9876&quot;);
producer.setTransactionListener(new TransactionListener() {
    
    @Override
    public LocalTransactionState executeLocalTransaction(Message msg, Object arg) {
        // 执行本地事务
        try {
            // 本地业务逻辑
            boolean success = processLocalTransaction(msg);
            return success ? LocalTransactionState.COMMIT_MESSAGE : 
                           LocalTransactionState.ROLLBACK_MESSAGE;
        } catch (Exception e) {
            return LocalTransactionState.ROLLBACK_MESSAGE;
        }
    }
    
    @Override
    public LocalTransactionState checkLocalTransaction(Message msg) {
        // 检查本地事务状态
        boolean success = checkLocalTransactionStatus(msg);
        return success ? LocalTransactionState.COMMIT_MESSAGE : 
                       LocalTransactionState.ROLLBACK_MESSAGE;
    }
});

// 发送事务消息
Message msg = new Message(&quot;topic-name&quot;, &quot;tag&quot;, &quot;key&quot;, &quot;message body&quot;.getBytes());
TransactionSendResult result = producer.sendMessageInTransaction(msg, null);
</code></pre>
<p><strong>顺序消息</strong></p>
<pre><code class="language-java">// 顺序消息生产者
DefaultMQProducer producer = new DefaultMQProducer(&quot;order-producer-group&quot;);
producer.setNamesrvAddr(&quot;localhost:9876&quot;);
producer.start();

// 发送顺序消息
for (int i = 0; i &lt; 10; i++) {
    Message msg = new Message(&quot;order-topic&quot;, &quot;order&quot;, 
        (&quot;order-&quot; + i).getBytes());
    
    // 使用相同的orderId作为选择队列的key
    SendResult result = producer.send(msg, new MessageQueueSelector() {
        @Override
        public MessageQueue select(List&lt;MessageQueue&gt; mqs, Message msg, Object arg) {
            String orderId = (String) arg;
            int index = Math.abs(orderId.hashCode()) % mqs.size();
            return mqs.get(index);
        }
    }, &quot;orderId-123&quot;);
}

// 顺序消息消费者
DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(&quot;order-consumer-group&quot;);
consumer.setNamesrvAddr(&quot;localhost:9876&quot;);
consumer.subscribe(&quot;order-topic&quot;, &quot;*&quot;);
consumer.registerMessageListener(new MessageListenerOrderly() {
    @Override
    public ConsumeOrderlyStatus consumeMessage(
        List&lt;MessageExt&gt; msgs, ConsumeOrderlyContext context) {
        
        for (MessageExt msg : msgs) {
            // 顺序处理消息
            processOrderMessage(msg);
        }
        
        return ConsumeOrderlyStatus.SUCCESS;
    }
});
consumer.start();
</code></pre>
<h2>RabbitMQ详解</h2>
<h3>1. RabbitMQ架构</h3>
<pre><code>RabbitMQ架构图：
┌─────────────────────────────────────────────────────────────┐
│                    RabbitMQ                                │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐           │
│  │   Exchange  │  │   Exchange  │  │   Exchange  │           │
│  │    Direct   │  │   Topic     │  │   Fanout    │           │
│  └─────────────┘  └─────────────┘  └─────────────┘           │
│         ↓                   ↓                   ↓           │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │                   Queue                                │ │
│  │  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐   │ │
│  │  │ Queue 1 │  │ Queue 2 │  │ Queue 3 │  │ Queue 4 │   │ │
│  │  └─────────┘  └─────────┘  └─────────┘  └─────────┘   │ │
│  └─────────────────────────────────────────────────────────┘ │
│         ↓                   ↓                   ↓           │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐           │
│  │   Consumer  │  │   Consumer  │  │   Consumer  │           │
│  └─────────────┘  └─────────────┘  └─────────────┘           │
└─────────────────────────────────────────────────────────────┘
</code></pre>
<h3>2. RabbitMQ特性</h3>
<p><strong>交换机类型</strong></p>
<pre><code class="language-java">// Direct Exchange（直连交换机）
@Configuration
public class RabbitConfig {
    
    @Bean
    public DirectExchange directExchange() {
        return new DirectExchange(&quot;direct.exchange&quot;);
    }
    
    @Bean
    public Queue directQueue1() {
        return QueueBuilder.durable(&quot;direct.queue.1&quot;).build();
    }
    
    @Bean
    public Binding directBinding1() {
        return BindingBuilder.bind(directQueue1())
            .to(directExchange()).with(&quot;routing.key.1&quot;);
    }
}

// Topic Exchange（主题交换机）
@Bean
public TopicExchange topicExchange() {
    return new TopicExchange(&quot;topic.exchange&quot;);
}

@Bean
public Queue topicQueue1() {
    return QueueBuilder.durable(&quot;topic.queue.1&quot;).build();
}

@Bean
public Binding topicBinding1() {
    return BindingBuilder.bind(topicQueue1())
        .to(topicExchange()).with(&quot;*.error&quot;);
}

// Fanout Exchange（扇出交换机）
@Bean
public FanoutExchange fanoutExchange() {
    return new FanoutExchange(&quot;fanout.exchange&quot;);
}

@Bean
public Queue fanoutQueue1() {
    return QueueBuilder.durable(&quot;fanout.queue.1&quot;).build();
}

@Bean
public Binding fanoutBinding1() {
    return BindingBuilder.bind(fanoutQueue1()).to(fanoutExchange());
}
</code></pre>
<p><strong>消息确认机制</strong></p>
<pre><code class="language-java">// 发送者确认
@Bean
public RabbitTemplate rabbitTemplate(ConnectionFactory connectionFactory) {
    RabbitTemplate template = new RabbitTemplate(connectionFactory);
    template.setConfirmCallback((correlationData, ack, cause) -&gt; {
        if (ack) {
            System.out.println(&quot;消息发送成功: &quot; + correlationData.getId());
        } else {
            System.err.println(&quot;消息发送失败: &quot; + cause);
        }
    });
    
    template.setReturnCallback((message, replyCode, replyText, exchange, routingKey) -&gt; {
        System.err.println(&quot;消息返回: &quot; + message);
    });
    
    return template;
}

// 消费者确认
@RabbitListener(queues = &quot;test.queue&quot;)
public void handleMessage(Message message, Channel channel) {
    try {
        // 处理消息
        String content = new String(message.getBody());
        processMessage(content);
        
        // 手动确认
        channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);
    } catch (Exception e) {
        try {
            // 拒绝消息（不重新入队）
            channel.basicNack(message.getMessageProperties().getDeliveryTag(), 
                            false, false);
        } catch (IOException ioException) {
            ioException.printStackTrace();
        }
    }
}
</code></pre>
<h2>MQ选型指南</h2>
<h3>1. 选型维度</h3>
<pre><code>MQ选型评估维度：
├── 性能要求
│   ├── 吞吐量
│   ├── 延迟
│   └── 并发能力
├── 功能需求
│   ├── 消息顺序
│   ├── 事务消息
│   ├── 消息重试
│   └── 死信队列
├── 可靠性
│   ├── 数据持久化
│   ├── 集群支持
│   ├── 故障恢复
│   └── 数据备份
├── 运维复杂度
│   ├── 部署难度
│   ├── 监控能力
│   ├── 故障排查
│   └── 扩展性
└── 生态系统
    ├── 社区活跃度
    ├── 文档完整性
    ├── 工具支持
    └── 学习成本
</code></pre>
<h3>2. 选型决策树</h3>
<pre><code>选型决策流程：
是否需要高吞吐量？
├── 是 → 是否需要强顺序性？
│   ├── 是 → RocketMQ
│   └── 否 → Kafka
└── 否 → 是否需要复杂路由？
    ├── 是 → RabbitMQ
    └── 否 → ActiveMQ/RocketMQ
</code></pre>
<h3>3. 最佳实践</h3>
<p><strong>消息设计原则</strong></p>
<pre><code class="language-java">// 消息结构设计
public class MessageEntity {
    private String messageId;    // 消息唯一ID
    private String topic;        // 主题
    private String tag;          // 标签
    private String body;         // 消息体
    private Long timestamp;      // 时间戳
    private Integer retryCount;  // 重试次数
    private Map&lt;String, String&gt; properties; // 扩展属性
}

// 消息生产者最佳实践
@Component
public class MessageProducer {
    
    @Autowired
    private KafkaTemplate&lt;String, String&gt; kafkaTemplate;
    
    public void sendMessage(String topic, Object message) {
        try {
            // 构建消息
            MessageEntity entity = new MessageEntity();
            entity.setMessageId(UUID.randomUUID().toString());
            entity.setTopic(topic);
            entity.setBody(JSON.toJSONString(message));
            entity.setTimestamp(System.currentTimeMillis());
            
            // 发送消息
            kafkaTemplate.send(topic, entity.getMessageId(), 
                JSON.toJSONString(entity))
                .addCallback(success -&gt; {
                    // 发送成功回调
                    log.info(&quot;消息发送成功: {}&quot;, entity.getMessageId());
                }, failure -&gt; {
                    // 发送失败回调
                    log.error(&quot;消息发送失败: {}&quot;, entity.getMessageId(), failure);
                    // 重试或补偿
                });
        } catch (Exception e) {
            log.error(&quot;发送消息异常&quot;, e);
        }
    }
}
</code></pre>
<h2>总结</h2>
<p>消息队列选型是一个重要的架构决策，需要综合考虑：</p>
<ol>
<li><strong>Kafka</strong>：适合大数据场景，吞吐量极高，延迟较低</li>
<li><strong>RocketMQ</strong>：适合金融场景，可靠性高，功能丰富</li>
<li><strong>RabbitMQ</strong>：适合企业应用，路由灵活，易于使用</li>
<li><strong>ActiveMQ</strong>：适合传统应用，成熟稳定，学习成本低</li>
</ol>
<p>选择MQ时，应该根据具体的业务需求、技术团队熟悉程度和运维能力来决定。没有最好的MQ，只有最适合的MQ。</p>
2:["$","div",null,{"children":[["$","$L9",null,{"href":"/notes","className":"back-button","style":{"display":"inline-block","background":"var(--primary-color)","color":"white","border":"none","padding":"10px 20px","borderRadius":"6px","cursor":"pointer","marginBottom":"20px","textDecoration":"none"},"children":["← 返回","笔记","列表"]}],["$","article",null,{"className":"section","children":[["$","header",null,{"className":"article-header","children":[["$","h1",null,{"className":"article-title","children":"热门MQ详解"}],["$","div",null,{"className":"article-meta","children":[["$","div",null,{"className":"article-meta-info","children":[["$","span",null,{"className":"article-date","children":"2024-10-14"}],["$","span",null,{"className":"article-category","children":["• ","笔记"]}]]}],["$","div",null,{"className":"article-tags","children":[["$","span","消息队列",{"className":"tag","children":"消息队列"}],["$","span","Kafka",{"className":"tag","children":"Kafka"}],["$","span","RocketMQ",{"className":"tag","children":"RocketMQ"}],["$","span","RabbitMQ",{"className":"tag","children":"RabbitMQ"}],["$","span","技术选型",{"className":"tag","children":"技术选型"}]]}]]}]]}],["$","div",null,{"className":"card markdown-content","dangerouslySetInnerHTML":{"__html":"$a"}}]]}]]}]
7:["$","html",null,{"lang":"zh-CN","children":[["$","head",null,{"children":[["$","link",null,{"rel":"stylesheet","href":"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"}],["$","link",null,{"rel":"stylesheet","href":"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css"}]]}],["$","body",null,{"children":["$","div",null,{"className":"app","children":[["$","$Lb",null,{"siteConfig":{"name":"Rudy Yang","bio":"JAVA | AI | WEB3","social":[{"name":"github","icon":"fab fa-github","url":"https://github.com/suogongy"},{"name":"twitter","icon":"fab fa-twitter","url":"https://twitter.com/suogongy"},{"name":"email","icon":"fas fa-envelope","url":"mailto:haiyuan1832@163.com"}]}}],["$","main",null,{"className":"main-content","children":["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L6",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":"404"}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],"notFoundStyles":[]}]}]]}]}]]}]
8:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"热门MQ详解 - Personal GitHub Page"}],["$","meta","3",{"name":"description","content":"深入分析主流消息队列的技术特点、架构设计、性能差异和选型建议，帮助开发者选择合适的消息中间件。"}]]
1:null
