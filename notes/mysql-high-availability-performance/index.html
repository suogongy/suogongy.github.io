<!DOCTYPE html><html lang="zh-CN"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/7b42d4e858e38c6b.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-c81f7fd28659d64f.js"/><script src="/_next/static/chunks/fd9d1056-e3d373074663785d.js" async=""></script><script src="/_next/static/chunks/117-86f31d03f8df68a5.js" async=""></script><script src="/_next/static/chunks/main-app-1bdc7b9537d0c130.js" async=""></script><script src="/_next/static/chunks/972-81dbad6abe39d3fa.js" async=""></script><script src="/_next/static/chunks/832-2b131d9fe9982edb.js" async=""></script><script src="/_next/static/chunks/app/%5Bcategory%5D/%5Bslug%5D/page-eb51aa11033a73a2.js" async=""></script><script src="/_next/static/chunks/app/layout-f3fa7e3100be56de.js" async=""></script><script src="https://cdn.jsdelivr.net/npm/mermaid@10.9.1/dist/mermaid.min.js" async=""></script><title>MySQL高可用高性能实战 - Personal GitHub Page</title><meta name="description" content="本文详细介绍MySQL高可用架构的设计原理、实现方案和性能优化实践，包括主从复制、集群部署、故障转移等核心技术。"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css"/><script src="https://unpkg.com/markmap-autoloader@0.17.2"></script><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body><div class="app"><header class="header "><nav class="nav-container"><a class="nav-brand" href="/"><i class="fas fa-terminal"></i>海元</a><ul class="nav-menu "><li><a class="nav-link " href="/"><i class="fas fa-home"></i> 首页</a></li><li><a class="nav-link " href="/about/"><i class="fas fa-user"></i> 关于</a></li><li><a class="nav-link " href="/projects/"><i class="fas fa-code"></i> 项目</a></li><li><a class="nav-link " href="/notes/"><i class="fas fa-book"></i> 笔记</a></li><li><a class="nav-link " href="/articles/"><i class="fas fa-pen"></i> 随笔</a></li></ul></nav></header><main class="main-content"><div><a class="back-button" style="display:inline-block;background:var(--primary-color);color:white;border:none;padding:10px 20px;border-radius:6px;cursor:pointer;margin-bottom:20px;text-decoration:none" href="/notes/">← 返回<!-- -->笔记<!-- -->列表</a><article class="section"><header class="article-header"><h1 class="article-title">MySQL高可用高性能实战</h1><div class="article-meta"><div class="article-tags"><span class="tag">MySQL</span><span class="tag">高可用</span><span class="tag">性能优化</span><span class="tag">数据库架构</span><span class="tag">主从复制</span></div></div></header><div class="card markdown-content"><div class="markdown-content"><div><h1>MySQL高可用高性能实战</h1>
<blockquote>
<p>构建稳定高效的MySQL架构是现代互联网应用的核心需求</p>
</blockquote>
<h2>引言</h2>
<p>在当今的互联网应用中，数据库的稳定性和性能直接影响整个系统的可用性。MySQL作为最流行的关系型数据库之一，其高可用和性能优化是每个技术团队必须掌握的核心技能。本文将详细介绍MySQL高可用架构设计和性能优化的实战经验。</p>
<h2>MySQL高可用架构概述</h2>
<h3>1. 高可用架构目标</h3>
<p><strong>可用性指标</strong></p>
<ul>
<li>99.99%可用性（年停机时间不超过52分钟）</li>
<li>99.999%可用性（年停机时间不超过5分钟）</li>
<li>快速故障检测和恢复（RTO &lt; 1分钟）</li>
<li>最小数据丢失（RPO接近0）</li>
</ul>
<p><strong>性能指标</strong></p>
<ul>
<li>高并发处理能力（万级QPS）</li>
<li>低延迟响应（P95 &lt; 100ms）</li>
<li>高吞吐量（百万级TPS）</li>
<li>线性扩展能力</li>
</ul>
<h3>2. 高可用架构模式</h3>
<p><strong>主从模式</strong></p>
<ul>
<li>一主多从的经典架构</li>
<li>读写分离，提升读性能</li>
<li>主节点故障时手动切换</li>
<li>适合中小型应用</li>
</ul>
<p><strong>双主模式</strong></p>
<ul>
<li>双主互备架构</li>
<li>支持双向数据同步</li>
<li>应用层需要处理写入冲突</li>
<li>适合跨机房部署</li>
</ul>
<p><strong>集群模式</strong></p>
<ul>
<li>基于Paxos/Raft协议的集群</li>
<li>自动故障检测和转移</li>
<li>强一致性保证</li>
<li>适合核心业务系统</li>
</ul>
<h2>主从复制架构实战</h2>
<h3>1. 传统异步复制</h3>
<p><strong>配置示例</strong>：</p>
<pre><code class="language-sql">-- 主服务器配置
[mysqld]
server-id=1
log-bin=mysql-bin
binlog-format=ROW
expire_logs_days=7
max_binlog_size=1G

-- 从服务器配置
[mysqld]
server-id=2
relay-log=mysql-relay
read-only=1
log-slave-updates=1
</code></pre>
<p><strong>复制用户创建</strong>：</p>
<pre><code class="language-sql">-- 在主服务器创建复制用户
CREATE USER &#39;repl&#39;@&#39;%&#39; IDENTIFIED BY &#39;strong_password&#39;;
GRANT REPLICATION SLAVE ON *.* TO &#39;repl&#39;@&#39;%&#39;;
FLUSH PRIVILEGES;

-- 获取主服务器状态
SHOW MASTER STATUS;
</code></pre>
<p><strong>从服务器配置</strong>：</p>
<pre><code class="language-sql">-- 配置主从复制
CHANGE MASTER TO
    MASTER_HOST=&#39;master-ip&#39;,
    MASTER_USER=&#39;repl&#39;,
    MASTER_PASSWORD=&#39;strong_password&#39;,
    MASTER_LOG_FILE=&#39;mysql-bin.000001&#39;,
    MASTER_LOG_POS=154;

START SLAVE;

-- 检查复制状态
SHOW SLAVE STATUS\G
</code></pre>
<h3>2. 半同步复制</h3>
<p><strong>安装配置</strong>：</p>
<pre><code class="language-sql">-- 安装半同步复制插件
INSTALL PLUGIN rpl_semi_sync_master SONAME &#39;semisync_master.so&#39;;
INSTALL PLUGIN rpl_semi_sync_slave SONAME &#39;semisync_slave.so&#39;;

-- 启用半同步复制
SET GLOBAL rpl_semi_sync_master_enabled = 1;
SET GLOBAL rpl_semi_sync_slave_enabled = 1;
</code></pre>
<p><strong>性能监控</strong>：</p>
<pre><code class="language-sql">-- 查看半同步状态
SHOW STATUS LIKE &#39;Rpl_semi_sync%&#39;;

-- 关键指标
-- Rpl_semi_sync_master_clients: 半同步从库数量
-- Rpl_semi_sync_master_status: 主库半同步状态
-- Rpl_semi_sync_master_avg_tx_wait_time: 平均等待时间
</code></pre>
<h3>3. GTID复制</h3>
<p><strong>GTID配置</strong>：</p>
<pre><code class="language-sql">[mysqld]
server-id=1
log-bin=mysql-bin
binlog-format=ROW
gtid-mode=ON
enforce-gtid-consistency=ON
log-slave-updates=1
</code></pre>
<p><strong>GTID复制配置</strong>：</p>
<pre><code class="language-sql">-- 基于GTID的主从复制
CHANGE MASTER TO
    MASTER_HOST=&#39;master-ip&#39;,
    MASTER_USER=&#39;repl&#39;,
    MASTER_PASSWORD=&#39;strong_password&#39;,
    MASTER_AUTO_POSITION=1;

START SLAVE;
</code></pre>
<p><strong>GTID操作</strong>：</p>
<pre><code class="language-sql">-- 查看GTID状态
SHOW GLOBAL VARIABLES LIKE &#39;gtid%&#39;;

-- 跳过错误事务
SET GTID_NEXT=&#39;UUID:NUMBER&#39;;
BEGIN; COMMIT;
SET GTID_NEXT=&#39;AUTOMATIC&#39;;
</code></pre>
<h2>MySQL集群架构</h2>
<h3>1. MySQL Group Replication</h3>
<p><strong>集群配置</strong>：</p>
<pre><code class="language-sql">-- 所有节点配置
[mysqld]
server-id=1
gtid-mode=ON
enforce-gtid-consistency=ON
master_info_repository=TABLE
relay_log_info_repository=TABLE
binlog_checksum=NONE
log_slave_updates=ON
log_bin=binlog
binlog_format=ROW

-- Group Replication配置
transaction_write_set_extraction=XXHASH64
loose-group_replication_group_name=&quot;aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa&quot;
loose-group_replication_start_on_boot=off
loose-group_replication_local_address=&quot;node1:33061&quot;
loose-group_replication_group_seeds=&quot;node1:33061,node2:33061,node3:33061&quot;
loose-group_replication_bootstrap_group=off
</code></pre>
<p><strong>启动集群</strong>：</p>
<pre><code class="language-sql">-- 在第一个节点启动集群
SET GLOBAL group_replication_bootstrap_group=ON;
START GROUP_REPLICATION;
SET GLOBAL group_replication_bootstrap_group=OFF;

-- 在其他节点加入集群
START GROUP_REPLICATION;

-- 查看集群状态
SELECT * FROM performance_schema.replication_group_members;
</code></pre>
<h3>2. InnoDB Cluster</h3>
<p><strong>部署脚本</strong>：</p>
<pre><code class="language-bash"># 安装MySQL Shell
sudo apt-get install mysql-shell

# 创建集群
mysqlsh root@localhost:3306

# 在MySQL Shell中执行
JS&gt; var cluster = dba.createCluster(&#39;myCluster&#39;);

# 添加实例
JS&gt; cluster.addInstance(&#39;root@node2:3306&#39;);
JS&gt; cluster.addInstance(&#39;root@node3:3306&#39;);

# 检查集群状态
JS&gt; cluster.status();

# 配置自动故障转移
JS&gt; cluster.setupAdminAccount(&#39;admin&#39;);
</code></pre>
<p><strong>集群监控</strong>：</p>
<pre><code class="language-sql">-- 查看集群状态
SELECT 
    MEMBER_ID,
    MEMBER_HOST,
    MEMBER_PORT,
    MEMBER_STATE,
    MEMBER_ROLE,
    MEMBER_VERSION
FROM performance_schema.replication_group_members;

-- 查看集群事务状态
SELECT 
    COUNT_TRANSACTIONS_IN_QUEUE,
    COUNT_TRANSACTIONS_CHECKED,
    COUNT_CONFLICTS_DETECTED,
    COUNT_TRANSACTIONS_ROWS_VALIDATING
FROM performance_schema.replication_group_member_stats;
</code></pre>
<h2>高可用中间件</h2>
<h3>1. MySQL Router</h3>
<p><strong>配置示例</strong>：</p>
<pre><code class="language-ini"># mysqlrouter.conf
[DEFAULT]
logging_folder=/var/log/mysqlrouter
runtime_folder=/var/run/mysqlrouter
config_folder=/etc/mysqlrouter

[logger]
level=INFO

[routing:primary]
bind_address=0.0.0.0
bind_port=6446
destinations=primary-server:3306
routing_strategy=first-available

[routing:secondary]
bind_address=0.0.0.0
bind_port=6447
destinations=secondary-server1:3306,secondary-server2:3306
routing_strategy=round-robin
</code></pre>
<p><strong>启动和监控</strong>：</p>
<pre><code class="language-bash"># 启动MySQL Router
mysqlrouter -c /etc/mysqlrouter/mysqlrouter.conf

# 检查路由状态
mysqlrouter --show-routing-status
</code></pre>
<h3>2. ProxySQL</h3>
<p><strong>配置示例</strong>：</p>
<pre><code class="language-sql">-- 插入MySQL服务器
INSERT INTO mysql_servers(hostgroup_id,hostname,port) 
VALUES (1,&#39;master-db&#39;,3306);
INSERT INTO mysql_servers(hostgroup_id,hostname,port) 
VALUES (2,&#39;slave-db1&#39;,3306);
INSERT INTO mysql_servers(hostgroup_id,hostname,port) 
VALUES (2,&#39;slave-db2&#39;,3306);

-- 配置读写分离规则
INSERT INTO mysql_query_rules(
    rule_id,active,match_pattern,destination_hostgroup,apply
) VALUES (
    1,1,&#39;^SELECT.*FOR UPDATE$&#39;,1,1
);

INSERT INTO mysql_query_rules(
    rule_id,active,match_pattern,destination_hostgroup,apply
) VALUES (
    2,1,&#39;^SELECT&#39;,2,1
);

-- 加载配置到运行时
LOAD MYSQL SERVERS TO RUNTIME;
SAVE MYSQL SERVERS TO DISK;
LOAD MYSQL QUERY RULES TO RUNTIME;
SAVE MYSQL QUERY RULES TO DISK;
</code></pre>
<h3>3. HAProxy配置</h3>
<p><strong>配置示例</strong>：</p>
<pre><code>global
    daemon
    maxconn 4096

defaults
    mode tcp
    timeout connect 5000ms
    timeout client 50000ms
    timeout server 50000ms

listen mysql-master
    bind 0.0.0.0:3306
    mode tcp
    option tcplog
    balance roundrobin
    server master1 master-db:3306 check
    server master2 backup-db:3306 check backup

listen mysql-slave
    bind 0.0.0.0:3307
    mode tcp
    option tcplog
    balance roundrobin
    server slave1 slave-db1:3306 check
    server slave2 slave-db2:3306 check
</code></pre>
<h2>故障检测和自动转移</h2>
<h3>1. MHA（Master High Availability）</h3>
<p><strong>配置文件</strong>：</p>
<pre><code class="language-perl"># /etc/masterha_default.cnf
[server default]
user=mha
password=mha_password
ssh_user=root
repl_user=repl
repl_password=repl_password
ping_interval=1

# /etc/app1.cnf
[server1]
hostname=master-db
master_binlog_dir=/var/lib/mysql
candidate_master=1

[server2]
hostname=slave-db1
master_binlog_dir=/var/lib/mysql
candidate_master=1

[server3]
hostname=slave-db2
master_binlog_dir=/var/lib/mysql
</code></pre>
<p><strong>故障转移脚本</strong>：</p>
<pre><code class="language-bash">#!/bin/bash
# masterha_manager --conf=/etc/app1.cnf

# 手动故障转移
masterha_master_switch --master_state=dead \
    --conf=/etc/app1.cnf \
    --dead_master_host=master-db \
    --new_master_host=slave-db1 \
    --ignore_last_failover

# 在线切换
masterha_master_switch --master_state=alive \
    --conf=/etc/app1.cnf \
    --orig_master_host=master-db \
    --new_master_host=slave-db1
</code></pre>
<h3>2. Orchestrator</h3>
<p><strong>配置示例</strong>：</p>
<pre><code class="language-json">{
    &quot;Debug&quot;: false,
    &quot;ListenAddress&quot;: &quot;:3000&quot;,
    &quot;MySQLTopologyUser&quot;: &quot;orchestrator&quot;,
    &quot;MySQLTopologyPassword&quot;: &quot;orch_password&quot;,
    &quot;MySQLReadUser&quot;: &quot;orchestrator&quot;,
    &quot;MySQLReadPassword&quot;: &quot;orch_password&quot;,
    &quot;MySQLInstanceUser&quot;: &quot;orchestrator&quot;,
    &quot;MySQLInstancePassword&quot;: &quot;orch_password&quot;,
    &quot;BackendDB&quot;: &quot;sqlite&quot;,
    &quot;SQLite3DataFile&quot;: &quot;/var/lib/orchestrator/orchestrator.sqlite3&quot;
}
</code></pre>
<p><strong>集群管理</strong>：</p>
<pre><code class="language-bash"># 发现集群
orchestrator -c discover -i master-db:3306

# 故障转移
orchestrator -c graceful-master-takeover -i master-db:3306

# 查看集群拓扑
orchestrator -c topology -i master-db:3306
</code></pre>
<h2>性能优化实战</h2>
<h3>1. 硬件优化</h3>
<p><strong>CPU配置</strong>：</p>
<pre><code class="language-bash"># CPU亲和性设置
taskset -c 0-3 mysqld

# CPU频率调节
cpufreq-set -g performance

# 中断亲和性
echo 0-3 &gt; /proc/irq/24/smp_affinity
</code></pre>
<p><strong>内存优化</strong>：</p>
<pre><code class="language-sql">-- InnoDB缓冲池配置
SET GLOBAL innodb_buffer_pool_size = &#39;8G&#39;;
SET GLOBAL innodb_buffer_pool_instances = 8;
SET GLOBAL innodb_old_blocks_time = 1000;

-- MyISAM键缓冲区
SET GLOBAL key_buffer_size = &#39;256M&#39;;
</code></pre>
<p><strong>存储优化</strong>：</p>
<pre><code class="language-bash"># SSD优化
echo deadline &gt; /sys/block/sda/queue/scheduler
echo 0 &gt; /sys/block/sda/queue/rotational

# 文件系统优化
mount -t ext4 -o noatime,nodiratime /dev/sda1 /mysql
</code></pre>
<h3>2. 数据库参数优化</h3>
<p><strong>InnoDB优化</strong>：</p>
<pre><code class="language-sql">-- InnoDB配置参数
SET GLOBAL innodb_flush_log_at_trx_commit = 2;
SET GLOBAL innodb_flush_method = &#39;O_DIRECT&#39;;
SET GLOBAL innodb_io_capacity = 2000;
SET GLOBAL innodb_io_capacity_max = 4000;
SET GLOBAL innodb_read_io_threads = 8;
SET GLOBAL innodb_write_io_threads = 8;
SET GLOBAL innodb_log_file_size = &#39;256M&#39;;
SET GLOBAL innodb_log_buffer_size = &#39;64M&#39;;
</code></pre>
<p><strong>连接优化</strong>：</p>
<pre><code class="language-sql">-- 连接相关参数
SET GLOBAL max_connections = 2000;
SET GLOBAL max_connect_errors = 10000;
SET GLOBAL connect_timeout = 10;
SET GLOBAL wait_timeout = 28800;
SET GLOBAL interactive_timeout = 28800;
</code></pre>
<p><strong>查询优化</strong>：</p>
<pre><code class="language-sql">-- 查询缓存（MySQL 5.7及以下）
SET GLOBAL query_cache_size = &#39;256M&#39;;
SET GLOBAL query_cache_type = ON;

-- 查询优化器
SET GLOBAL optimizer_switch = &#39;index_merge=on,index_merge_union=on,index_merge_sort_union=on&#39;;
</code></pre>
<h3>3. SQL优化</h3>
<p><strong>索引优化</strong>：</p>
<pre><code class="language-sql">-- 创建复合索引
CREATE INDEX idx_user_status ON users(status, created_at);

-- 分析索引使用情况
EXPLAIN SELECT * FROM users WHERE status = 1 ORDER BY created_at;

-- 删除无用索引
DROP INDEX idx_unused ON table_name;
</code></pre>
<p><strong>查询优化</strong>：</p>
<pre><code class="language-sql">-- 避免全表扫描
SELECT id, name FROM users WHERE status = 1 LIMIT 100;

-- 使用覆盖索引
SELECT id, status FROM users WHERE status = 1;

-- 批量插入优化
INSERT INTO orders (user_id, amount, created_at) VALUES 
    (1, 100, NOW()),
    (2, 200, NOW()),
    (3, 300, NOW());
</code></pre>
<p><strong>分页优化</strong>：</p>
<pre><code class="language-sql">-- 传统分页（性能较差）
SELECT * FROM orders ORDER BY id LIMIT 10000, 20;

-- 优化分页（使用书签）
SELECT * FROM orders WHERE id &gt; 10000 ORDER BY id LIMIT 20;

-- 复杂分页优化
SELECT o.* FROM orders o
INNER JOIN (SELECT id FROM orders ORDER BY id LIMIT 10000, 20) t ON o.id = t.id;
</code></pre>
<h2>监控和告警</h2>
<h3>1. 性能监控</h3>
<p><strong>关键指标监控</strong>：</p>
<pre><code class="language-sql">-- QPS和TPS
SHOW GLOBAL STATUS LIKE &#39;Com_%&#39;;
SHOW GLOBAL STATUS LIKE &#39;Questions&#39;;
SHOW GLOBAL STATUS LIKE &#39;Uptime&#39;;

-- 连接数
SHOW GLOBAL STATUS LIKE &#39;Threads%&#39;;
SHOW GLOBAL STATUS LIKE &#39;Max_used_connections&#39;;

-- 慢查询
SHOW GLOBAL STATUS LIKE &#39;Slow_queries&#39;;
SELECT * FROM mysql.slow_log ORDER BY start_time DESC LIMIT 10;
</code></pre>
<p><strong>InnoDB监控</strong>：</p>
<pre><code class="language-sql">-- InnoDB状态
SHOW ENGINE INNODB STATUS;

-- InnoDB指标
SHOW GLOBAL STATUS LIKE &#39;Innodb%&#39;;

-- 锁等待
SELECT * FROM sys.innodb_lock_waits;
</code></pre>
<h3>2. Prometheus监控</h3>
<p><strong>MySQL Exporter配置</strong>：</p>
<pre><code class="language-yaml"># prometheus.yml
global:
  scrape_interval: 15s

scrape_configs:
  - job_name: &#39;mysql&#39;
    static_configs:
      - targets: [&#39;mysql-exporter:9104&#39;]
</code></pre>
<p><strong>关键告警规则</strong>：</p>
<pre><code class="language-yaml"># mysql_alerts.yml
groups:
  - name: mysql
    rules:
      - alert: MySQLDown
        expr: mysql_up == 0
        for: 1m
        labels:
          severity: critical
        annotations:
          summary: &quot;MySQL instance is down&quot;
          
      - alert: MySQLTooManyConnections
        expr: mysql_global_status_threads_connected / mysql_global_variables_max_connections &gt; 0.8
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: &quot;MySQL has too many connections&quot;
</code></pre>
<h3>3. 日志分析</h3>
<p><strong>慢查询日志分析</strong>：</p>
<pre><code class="language-bash"># 启用慢查询日志
SET GLOBAL slow_query_log = &#39;ON&#39;;
SET GLOBAL long_query_time = 1;
SET GLOBAL slow_query_log_file = &#39;/var/log/mysql/slow.log&#39;;

# 使用pt-query-digest分析
pt-query-digest /var/log/mysql/slow.log

# 输出报告示例
# # Profile
# # Rank Query ID           Response time   Calls   R/Call   V/M   Item
# # ==== ================== ============== ======= ========= ===== ===============
# #    1 0xF9A57DD5A41847CA  2.5119  38%    1000   0.002512  0.10 SELECT users
</code></pre>
<h2>备份和恢复</h2>
<h3>1. 逻辑备份</h3>
<p><strong>mysqldump备份</strong>：</p>
<pre><code class="language-bash"># 全量备份
mysqldump -u root -p --single-transaction --routines --triggers --all-databases &gt; full_backup.sql

# 增量备份（基于binlog）
mysqlbinlog --start-datetime=&quot;2024-01-01 00:00:00&quot; --stop-datetime=&quot;2024-01-02 00:00:00&quot; mysql-bin.000001 &gt; incremental_backup.sql

# 恢复数据
mysql -u root -p &lt; full_backup.sql
mysql -u root -p &lt; incremental_backup.sql
</code></pre>
<h3>2. 物理备份</h3>
<p><strong>XtraBackup备份</strong>：</p>
<pre><code class="language-bash"># 全量备份
xtrabackup --backup --target-dir=/backup/full --user=backup --password=backup_password

# 增量备份
xtrabackup --backup --target-dir=/backup/inc1 --incremental-basedir=/backup/full --user=backup --password=backup_password

# 准备备份
xtrabackup --prepare --target-dir=/backup/full
xtrabackup --prepare --target-dir=/backup/full --incremental-dir=/backup/inc1

# 恢复备份
xtrabackup --copy-back --target-dir=/backup/full
</code></pre>
<h3>3. 自动化备份脚本</h3>
<p><strong>备份脚本示例</strong>：</p>
<pre><code class="language-bash">#!/bin/bash
# backup_mysql.sh

BACKUP_DIR=&quot;/backup/mysql&quot;
DATE=$(date +%Y%m%d_%H%M%S)
DB_USER=&quot;backup&quot;
DB_PASS=&quot;backup_password&quot;
RETENTION_DAYS=7

# 创建备份目录
mkdir -p $BACKUP_DIR/$DATE

# 全量备份
xtrabackup --backup --target-dir=$BACKUP_DIR/$DATE/full --user=$DB_USER --password=$DB_PASS

# 删除过期备份
find $BACKUP_DIR -type d -mtime +$RETENTION_DAYS -exec rm -rf {} \;

# 上传到云存储
aws s3 sync $BACKUP_DIR/$DATE s3://mysql-backup-bucket/$DATE
</code></pre>
<h2>总结</h2>
<p>构建MySQL高可用高性能架构需要综合考虑多个方面：</p>
<ol>
<li><strong>架构选择</strong>：根据业务需求选择合适的高可用架构</li>
<li><strong>性能优化</strong>：从硬件、参数、SQL等多个层面进行优化</li>
<li><strong>监控告警</strong>：建立完善的监控体系和告警机制</li>
<li><strong>备份恢复</strong>：制定可靠的备份策略和恢复方案</li>
<li><strong>运维管理</strong>：建立标准化的运维流程和工具链</li>
</ol>
<p>通过合理的架构设计和持续的优化改进，可以构建出稳定、高效、可扩展的MySQL数据库系统，为业务发展提供坚实的数据支撑。</p>
</div></div></div></article></div></main></div><script src="/_next/static/chunks/webpack-c81f7fd28659d64f.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/7b42d4e858e38c6b.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"2:I[2846,[],\"\"]\n5:I[4707,[],\"\"]\n8:I[6423,[],\"\"]\nb:I[1060,[],\"\"]\n6:[\"category\",\"notes\",\"d\"]\n7:[\"slug\",\"mysql-high-availability-performance\",\"d\"]\nc:[]\n0:[\"$\",\"$L2\",null,{\"buildId\":\"build\",\"assetPrefix\":\"\",\"urlParts\":[\"\",\"notes\",\"mysql-high-availability-performance\",\"\"],\"initialTree\":[\"\",{\"children\":[[\"category\",\"notes\",\"d\"],{\"children\":[[\"slug\",\"mysql-high-availability-performance\",\"d\"],{\"children\":[\"__PAGE__?{\\\"category\\\":\\\"notes\\\",\\\"slug\\\":\\\"mysql-high-availability-performance\\\"}\",{}]}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[[\"category\",\"notes\",\"d\"],{\"children\":[[\"slug\",\"mysql-high-availability-performance\",\"d\"],{\"children\":[\"__PAGE__\",{},[[\"$L3\",\"$L4\",null],null],null]},[null,[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$6\",\"children\",\"$7\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}]],null]},[null,[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"$6\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}]],null]},[[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/7b42d4e858e38c6b.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],\"$L9\"],null],null],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$La\"],\"globalErrorComponent\":\"$b\",\"missingSlots\":\"$Wc\"}]\n"])</script><script>self.__next_f.push([1,"d:I[2972,[\"972\",\"static/chunks/972-81dbad6abe39d3fa.js\",\"832\",\"static/chunks/832-2b131d9fe9982edb.js\",\"621\",\"static/chunks/app/%5Bcategory%5D/%5Bslug%5D/page-eb51aa11033a73a2.js\"],\"\"]\ne:I[5546,[\"972\",\"static/chunks/972-81dbad6abe39d3fa.js\",\"832\",\"static/chunks/832-2b131d9fe9982edb.js\",\"621\",\"static/chunks/app/%5Bcategory%5D/%5Bslug%5D/page-eb51aa11033a73a2.js\"],\"default\"]\n10:I[7140,[\"972\",\"static/chunks/972-81dbad6abe39d3fa.js\",\"185\",\"static/chunks/app/layout-f3fa7e3100be56de.js\"],\"default\"]\nf:T3bce,"])</script><script>self.__next_f.push([1,"\n# MySQL高可用高性能实战\n\n\u003e 构建稳定高效的MySQL架构是现代互联网应用的核心需求\n\n## 引言\n\n在当今的互联网应用中，数据库的稳定性和性能直接影响整个系统的可用性。MySQL作为最流行的关系型数据库之一，其高可用和性能优化是每个技术团队必须掌握的核心技能。本文将详细介绍MySQL高可用架构设计和性能优化的实战经验。\n\n## MySQL高可用架构概述\n\n### 1. 高可用架构目标\n\n**可用性指标**\n- 99.99%可用性（年停机时间不超过52分钟）\n- 99.999%可用性（年停机时间不超过5分钟）\n- 快速故障检测和恢复（RTO \u003c 1分钟）\n- 最小数据丢失（RPO接近0）\n\n**性能指标**\n- 高并发处理能力（万级QPS）\n- 低延迟响应（P95 \u003c 100ms）\n- 高吞吐量（百万级TPS）\n- 线性扩展能力\n\n### 2. 高可用架构模式\n\n**主从模式**\n- 一主多从的经典架构\n- 读写分离，提升读性能\n- 主节点故障时手动切换\n- 适合中小型应用\n\n**双主模式**\n- 双主互备架构\n- 支持双向数据同步\n- 应用层需要处理写入冲突\n- 适合跨机房部署\n\n**集群模式**\n- 基于Paxos/Raft协议的集群\n- 自动故障检测和转移\n- 强一致性保证\n- 适合核心业务系统\n\n## 主从复制架构实战\n\n### 1. 传统异步复制\n\n**配置示例**：\n```sql\n-- 主服务器配置\n[mysqld]\nserver-id=1\nlog-bin=mysql-bin\nbinlog-format=ROW\nexpire_logs_days=7\nmax_binlog_size=1G\n\n-- 从服务器配置\n[mysqld]\nserver-id=2\nrelay-log=mysql-relay\nread-only=1\nlog-slave-updates=1\n```\n\n**复制用户创建**：\n```sql\n-- 在主服务器创建复制用户\nCREATE USER 'repl'@'%' IDENTIFIED BY 'strong_password';\nGRANT REPLICATION SLAVE ON *.* TO 'repl'@'%';\nFLUSH PRIVILEGES;\n\n-- 获取主服务器状态\nSHOW MASTER STATUS;\n```\n\n**从服务器配置**：\n```sql\n-- 配置主从复制\nCHANGE MASTER TO\n    MASTER_HOST='master-ip',\n    MASTER_USER='repl',\n    MASTER_PASSWORD='strong_password',\n    MASTER_LOG_FILE='mysql-bin.000001',\n    MASTER_LOG_POS=154;\n\nSTART SLAVE;\n\n-- 检查复制状态\nSHOW SLAVE STATUS\\G\n```\n\n### 2. 半同步复制\n\n**安装配置**：\n```sql\n-- 安装半同步复制插件\nINSTALL PLUGIN rpl_semi_sync_master SONAME 'semisync_master.so';\nINSTALL PLUGIN rpl_semi_sync_slave SONAME 'semisync_slave.so';\n\n-- 启用半同步复制\nSET GLOBAL rpl_semi_sync_master_enabled = 1;\nSET GLOBAL rpl_semi_sync_slave_enabled = 1;\n```\n\n**性能监控**：\n```sql\n-- 查看半同步状态\nSHOW STATUS LIKE 'Rpl_semi_sync%';\n\n-- 关键指标\n-- Rpl_semi_sync_master_clients: 半同步从库数量\n-- Rpl_semi_sync_master_status: 主库半同步状态\n-- Rpl_semi_sync_master_avg_tx_wait_time: 平均等待时间\n```\n\n### 3. GTID复制\n\n**GTID配置**：\n```sql\n[mysqld]\nserver-id=1\nlog-bin=mysql-bin\nbinlog-format=ROW\ngtid-mode=ON\nenforce-gtid-consistency=ON\nlog-slave-updates=1\n```\n\n**GTID复制配置**：\n```sql\n-- 基于GTID的主从复制\nCHANGE MASTER TO\n    MASTER_HOST='master-ip',\n    MASTER_USER='repl',\n    MASTER_PASSWORD='strong_password',\n    MASTER_AUTO_POSITION=1;\n\nSTART SLAVE;\n```\n\n**GTID操作**：\n```sql\n-- 查看GTID状态\nSHOW GLOBAL VARIABLES LIKE 'gtid%';\n\n-- 跳过错误事务\nSET GTID_NEXT='UUID:NUMBER';\nBEGIN; COMMIT;\nSET GTID_NEXT='AUTOMATIC';\n```\n\n## MySQL集群架构\n\n### 1. MySQL Group Replication\n\n**集群配置**：\n```sql\n-- 所有节点配置\n[mysqld]\nserver-id=1\ngtid-mode=ON\nenforce-gtid-consistency=ON\nmaster_info_repository=TABLE\nrelay_log_info_repository=TABLE\nbinlog_checksum=NONE\nlog_slave_updates=ON\nlog_bin=binlog\nbinlog_format=ROW\n\n-- Group Replication配置\ntransaction_write_set_extraction=XXHASH64\nloose-group_replication_group_name=\"aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa\"\nloose-group_replication_start_on_boot=off\nloose-group_replication_local_address=\"node1:33061\"\nloose-group_replication_group_seeds=\"node1:33061,node2:33061,node3:33061\"\nloose-group_replication_bootstrap_group=off\n```\n\n**启动集群**：\n```sql\n-- 在第一个节点启动集群\nSET GLOBAL group_replication_bootstrap_group=ON;\nSTART GROUP_REPLICATION;\nSET GLOBAL group_replication_bootstrap_group=OFF;\n\n-- 在其他节点加入集群\nSTART GROUP_REPLICATION;\n\n-- 查看集群状态\nSELECT * FROM performance_schema.replication_group_members;\n```\n\n### 2. InnoDB Cluster\n\n**部署脚本**：\n```bash\n# 安装MySQL Shell\nsudo apt-get install mysql-shell\n\n# 创建集群\nmysqlsh root@localhost:3306\n\n# 在MySQL Shell中执行\nJS\u003e var cluster = dba.createCluster('myCluster');\n\n# 添加实例\nJS\u003e cluster.addInstance('root@node2:3306');\nJS\u003e cluster.addInstance('root@node3:3306');\n\n# 检查集群状态\nJS\u003e cluster.status();\n\n# 配置自动故障转移\nJS\u003e cluster.setupAdminAccount('admin');\n```\n\n**集群监控**：\n```sql\n-- 查看集群状态\nSELECT \n    MEMBER_ID,\n    MEMBER_HOST,\n    MEMBER_PORT,\n    MEMBER_STATE,\n    MEMBER_ROLE,\n    MEMBER_VERSION\nFROM performance_schema.replication_group_members;\n\n-- 查看集群事务状态\nSELECT \n    COUNT_TRANSACTIONS_IN_QUEUE,\n    COUNT_TRANSACTIONS_CHECKED,\n    COUNT_CONFLICTS_DETECTED,\n    COUNT_TRANSACTIONS_ROWS_VALIDATING\nFROM performance_schema.replication_group_member_stats;\n```\n\n## 高可用中间件\n\n### 1. MySQL Router\n\n**配置示例**：\n```ini\n# mysqlrouter.conf\n[DEFAULT]\nlogging_folder=/var/log/mysqlrouter\nruntime_folder=/var/run/mysqlrouter\nconfig_folder=/etc/mysqlrouter\n\n[logger]\nlevel=INFO\n\n[routing:primary]\nbind_address=0.0.0.0\nbind_port=6446\ndestinations=primary-server:3306\nrouting_strategy=first-available\n\n[routing:secondary]\nbind_address=0.0.0.0\nbind_port=6447\ndestinations=secondary-server1:3306,secondary-server2:3306\nrouting_strategy=round-robin\n```\n\n**启动和监控**：\n```bash\n# 启动MySQL Router\nmysqlrouter -c /etc/mysqlrouter/mysqlrouter.conf\n\n# 检查路由状态\nmysqlrouter --show-routing-status\n```\n\n### 2. ProxySQL\n\n**配置示例**：\n```sql\n-- 插入MySQL服务器\nINSERT INTO mysql_servers(hostgroup_id,hostname,port) \nVALUES (1,'master-db',3306);\nINSERT INTO mysql_servers(hostgroup_id,hostname,port) \nVALUES (2,'slave-db1',3306);\nINSERT INTO mysql_servers(hostgroup_id,hostname,port) \nVALUES (2,'slave-db2',3306);\n\n-- 配置读写分离规则\nINSERT INTO mysql_query_rules(\n    rule_id,active,match_pattern,destination_hostgroup,apply\n) VALUES (\n    1,1,'^SELECT.*FOR UPDATE$',1,1\n);\n\nINSERT INTO mysql_query_rules(\n    rule_id,active,match_pattern,destination_hostgroup,apply\n) VALUES (\n    2,1,'^SELECT',2,1\n);\n\n-- 加载配置到运行时\nLOAD MYSQL SERVERS TO RUNTIME;\nSAVE MYSQL SERVERS TO DISK;\nLOAD MYSQL QUERY RULES TO RUNTIME;\nSAVE MYSQL QUERY RULES TO DISK;\n```\n\n### 3. HAProxy配置\n\n**配置示例**：\n```\nglobal\n    daemon\n    maxconn 4096\n\ndefaults\n    mode tcp\n    timeout connect 5000ms\n    timeout client 50000ms\n    timeout server 50000ms\n\nlisten mysql-master\n    bind 0.0.0.0:3306\n    mode tcp\n    option tcplog\n    balance roundrobin\n    server master1 master-db:3306 check\n    server master2 backup-db:3306 check backup\n\nlisten mysql-slave\n    bind 0.0.0.0:3307\n    mode tcp\n    option tcplog\n    balance roundrobin\n    server slave1 slave-db1:3306 check\n    server slave2 slave-db2:3306 check\n```\n\n## 故障检测和自动转移\n\n### 1. MHA（Master High Availability）\n\n**配置文件**：\n```perl\n# /etc/masterha_default.cnf\n[server default]\nuser=mha\npassword=mha_password\nssh_user=root\nrepl_user=repl\nrepl_password=repl_password\nping_interval=1\n\n# /etc/app1.cnf\n[server1]\nhostname=master-db\nmaster_binlog_dir=/var/lib/mysql\ncandidate_master=1\n\n[server2]\nhostname=slave-db1\nmaster_binlog_dir=/var/lib/mysql\ncandidate_master=1\n\n[server3]\nhostname=slave-db2\nmaster_binlog_dir=/var/lib/mysql\n```\n\n**故障转移脚本**：\n```bash\n#!/bin/bash\n# masterha_manager --conf=/etc/app1.cnf\n\n# 手动故障转移\nmasterha_master_switch --master_state=dead \\\n    --conf=/etc/app1.cnf \\\n    --dead_master_host=master-db \\\n    --new_master_host=slave-db1 \\\n    --ignore_last_failover\n\n# 在线切换\nmasterha_master_switch --master_state=alive \\\n    --conf=/etc/app1.cnf \\\n    --orig_master_host=master-db \\\n    --new_master_host=slave-db1\n```\n\n### 2. Orchestrator\n\n**配置示例**：\n```json\n{\n    \"Debug\": false,\n    \"ListenAddress\": \":3000\",\n    \"MySQLTopologyUser\": \"orchestrator\",\n    \"MySQLTopologyPassword\": \"orch_password\",\n    \"MySQLReadUser\": \"orchestrator\",\n    \"MySQLReadPassword\": \"orch_password\",\n    \"MySQLInstanceUser\": \"orchestrator\",\n    \"MySQLInstancePassword\": \"orch_password\",\n    \"BackendDB\": \"sqlite\",\n    \"SQLite3DataFile\": \"/var/lib/orchestrator/orchestrator.sqlite3\"\n}\n```\n\n**集群管理**：\n```bash\n# 发现集群\norchestrator -c discover -i master-db:3306\n\n# 故障转移\norchestrator -c graceful-master-takeover -i master-db:3306\n\n# 查看集群拓扑\norchestrator -c topology -i master-db:3306\n```\n\n## 性能优化实战\n\n### 1. 硬件优化\n\n**CPU配置**：\n```bash\n# CPU亲和性设置\ntaskset -c 0-3 mysqld\n\n# CPU频率调节\ncpufreq-set -g performance\n\n# 中断亲和性\necho 0-3 \u003e /proc/irq/24/smp_affinity\n```\n\n**内存优化**：\n```sql\n-- InnoDB缓冲池配置\nSET GLOBAL innodb_buffer_pool_size = '8G';\nSET GLOBAL innodb_buffer_pool_instances = 8;\nSET GLOBAL innodb_old_blocks_time = 1000;\n\n-- MyISAM键缓冲区\nSET GLOBAL key_buffer_size = '256M';\n```\n\n**存储优化**：\n```bash\n# SSD优化\necho deadline \u003e /sys/block/sda/queue/scheduler\necho 0 \u003e /sys/block/sda/queue/rotational\n\n# 文件系统优化\nmount -t ext4 -o noatime,nodiratime /dev/sda1 /mysql\n```\n\n### 2. 数据库参数优化\n\n**InnoDB优化**：\n```sql\n-- InnoDB配置参数\nSET GLOBAL innodb_flush_log_at_trx_commit = 2;\nSET GLOBAL innodb_flush_method = 'O_DIRECT';\nSET GLOBAL innodb_io_capacity = 2000;\nSET GLOBAL innodb_io_capacity_max = 4000;\nSET GLOBAL innodb_read_io_threads = 8;\nSET GLOBAL innodb_write_io_threads = 8;\nSET GLOBAL innodb_log_file_size = '256M';\nSET GLOBAL innodb_log_buffer_size = '64M';\n```\n\n**连接优化**：\n```sql\n-- 连接相关参数\nSET GLOBAL max_connections = 2000;\nSET GLOBAL max_connect_errors = 10000;\nSET GLOBAL connect_timeout = 10;\nSET GLOBAL wait_timeout = 28800;\nSET GLOBAL interactive_timeout = 28800;\n```\n\n**查询优化**：\n```sql\n-- 查询缓存（MySQL 5.7及以下）\nSET GLOBAL query_cache_size = '256M';\nSET GLOBAL query_cache_type = ON;\n\n-- 查询优化器\nSET GLOBAL optimizer_switch = 'index_merge=on,index_merge_union=on,index_merge_sort_union=on';\n```\n\n### 3. SQL优化\n\n**索引优化**：\n```sql\n-- 创建复合索引\nCREATE INDEX idx_user_status ON users(status, created_at);\n\n-- 分析索引使用情况\nEXPLAIN SELECT * FROM users WHERE status = 1 ORDER BY created_at;\n\n-- 删除无用索引\nDROP INDEX idx_unused ON table_name;\n```\n\n**查询优化**：\n```sql\n-- 避免全表扫描\nSELECT id, name FROM users WHERE status = 1 LIMIT 100;\n\n-- 使用覆盖索引\nSELECT id, status FROM users WHERE status = 1;\n\n-- 批量插入优化\nINSERT INTO orders (user_id, amount, created_at) VALUES \n    (1, 100, NOW()),\n    (2, 200, NOW()),\n    (3, 300, NOW());\n```\n\n**分页优化**：\n```sql\n-- 传统分页（性能较差）\nSELECT * FROM orders ORDER BY id LIMIT 10000, 20;\n\n-- 优化分页（使用书签）\nSELECT * FROM orders WHERE id \u003e 10000 ORDER BY id LIMIT 20;\n\n-- 复杂分页优化\nSELECT o.* FROM orders o\nINNER JOIN (SELECT id FROM orders ORDER BY id LIMIT 10000, 20) t ON o.id = t.id;\n```\n\n## 监控和告警\n\n### 1. 性能监控\n\n**关键指标监控**：\n```sql\n-- QPS和TPS\nSHOW GLOBAL STATUS LIKE 'Com_%';\nSHOW GLOBAL STATUS LIKE 'Questions';\nSHOW GLOBAL STATUS LIKE 'Uptime';\n\n-- 连接数\nSHOW GLOBAL STATUS LIKE 'Threads%';\nSHOW GLOBAL STATUS LIKE 'Max_used_connections';\n\n-- 慢查询\nSHOW GLOBAL STATUS LIKE 'Slow_queries';\nSELECT * FROM mysql.slow_log ORDER BY start_time DESC LIMIT 10;\n```\n\n**InnoDB监控**：\n```sql\n-- InnoDB状态\nSHOW ENGINE INNODB STATUS;\n\n-- InnoDB指标\nSHOW GLOBAL STATUS LIKE 'Innodb%';\n\n-- 锁等待\nSELECT * FROM sys.innodb_lock_waits;\n```\n\n### 2. Prometheus监控\n\n**MySQL Exporter配置**：\n```yaml\n# prometheus.yml\nglobal:\n  scrape_interval: 15s\n\nscrape_configs:\n  - job_name: 'mysql'\n    static_configs:\n      - targets: ['mysql-exporter:9104']\n```\n\n**关键告警规则**：\n```yaml\n# mysql_alerts.yml\ngroups:\n  - name: mysql\n    rules:\n      - alert: MySQLDown\n        expr: mysql_up == 0\n        for: 1m\n        labels:\n          severity: critical\n        annotations:\n          summary: \"MySQL instance is down\"\n          \n      - alert: MySQLTooManyConnections\n        expr: mysql_global_status_threads_connected / mysql_global_variables_max_connections \u003e 0.8\n        for: 5m\n        labels:\n          severity: warning\n        annotations:\n          summary: \"MySQL has too many connections\"\n```\n\n### 3. 日志分析\n\n**慢查询日志分析**：\n```bash\n# 启用慢查询日志\nSET GLOBAL slow_query_log = 'ON';\nSET GLOBAL long_query_time = 1;\nSET GLOBAL slow_query_log_file = '/var/log/mysql/slow.log';\n\n# 使用pt-query-digest分析\npt-query-digest /var/log/mysql/slow.log\n\n# 输出报告示例\n# # Profile\n# # Rank Query ID           Response time   Calls   R/Call   V/M   Item\n# # ==== ================== ============== ======= ========= ===== ===============\n# #    1 0xF9A57DD5A41847CA  2.5119  38%    1000   0.002512  0.10 SELECT users\n```\n\n## 备份和恢复\n\n### 1. 逻辑备份\n\n**mysqldump备份**：\n```bash\n# 全量备份\nmysqldump -u root -p --single-transaction --routines --triggers --all-databases \u003e full_backup.sql\n\n# 增量备份（基于binlog）\nmysqlbinlog --start-datetime=\"2024-01-01 00:00:00\" --stop-datetime=\"2024-01-02 00:00:00\" mysql-bin.000001 \u003e incremental_backup.sql\n\n# 恢复数据\nmysql -u root -p \u003c full_backup.sql\nmysql -u root -p \u003c incremental_backup.sql\n```\n\n### 2. 物理备份\n\n**XtraBackup备份**：\n```bash\n# 全量备份\nxtrabackup --backup --target-dir=/backup/full --user=backup --password=backup_password\n\n# 增量备份\nxtrabackup --backup --target-dir=/backup/inc1 --incremental-basedir=/backup/full --user=backup --password=backup_password\n\n# 准备备份\nxtrabackup --prepare --target-dir=/backup/full\nxtrabackup --prepare --target-dir=/backup/full --incremental-dir=/backup/inc1\n\n# 恢复备份\nxtrabackup --copy-back --target-dir=/backup/full\n```\n\n### 3. 自动化备份脚本\n\n**备份脚本示例**：\n```bash\n#!/bin/bash\n# backup_mysql.sh\n\nBACKUP_DIR=\"/backup/mysql\"\nDATE=$(date +%Y%m%d_%H%M%S)\nDB_USER=\"backup\"\nDB_PASS=\"backup_password\"\nRETENTION_DAYS=7\n\n# 创建备份目录\nmkdir -p $BACKUP_DIR/$DATE\n\n# 全量备份\nxtrabackup --backup --target-dir=$BACKUP_DIR/$DATE/full --user=$DB_USER --password=$DB_PASS\n\n# 删除过期备份\nfind $BACKUP_DIR -type d -mtime +$RETENTION_DAYS -exec rm -rf {} \\;\n\n# 上传到云存储\naws s3 sync $BACKUP_DIR/$DATE s3://mysql-backup-bucket/$DATE\n```\n\n## 总结\n\n构建MySQL高可用高性能架构需要综合考虑多个方面：\n\n1. **架构选择**：根据业务需求选择合适的高可用架构\n2. **性能优化**：从硬件、参数、SQL等多个层面进行优化\n3. **监控告警**：建立完善的监控体系和告警机制\n4. **备份恢复**：制定可靠的备份策略和恢复方案\n5. **运维管理**：建立标准化的运维流程和工具链\n\n通过合理的架构设计和持续的优化改进，可以构建出稳定、高效、可扩展的MySQL数据库系统，为业务发展提供坚实的数据支撑。"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"children\":[[\"$\",\"$Ld\",null,{\"href\":\"/notes\",\"className\":\"back-button\",\"style\":{\"display\":\"inline-block\",\"background\":\"var(--primary-color)\",\"color\":\"white\",\"border\":\"none\",\"padding\":\"10px 20px\",\"borderRadius\":\"6px\",\"cursor\":\"pointer\",\"marginBottom\":\"20px\",\"textDecoration\":\"none\"},\"children\":[\"← 返回\",\"笔记\",\"列表\"]}],[\"$\",\"article\",null,{\"className\":\"section\",\"children\":[[\"$\",\"header\",null,{\"className\":\"article-header\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"article-title\",\"children\":\"MySQL高可用高性能实战\"}],[\"$\",\"div\",null,{\"className\":\"article-meta\",\"children\":[\"$\",\"div\",null,{\"className\":\"article-tags\",\"children\":[[\"$\",\"span\",\"MySQL\",{\"className\":\"tag\",\"children\":\"MySQL\"}],[\"$\",\"span\",\"高可用\",{\"className\":\"tag\",\"children\":\"高可用\"}],[\"$\",\"span\",\"性能优化\",{\"className\":\"tag\",\"children\":\"性能优化\"}],[\"$\",\"span\",\"数据库架构\",{\"className\":\"tag\",\"children\":\"数据库架构\"}],[\"$\",\"span\",\"主从复制\",{\"className\":\"tag\",\"children\":\"主从复制\"}]]}]}]]}],[\"$\",\"div\",null,{\"className\":\"card markdown-content\",\"children\":[\"$\",\"$Le\",null,{\"content\":\"$f\"}]}]]}]]}]\n"])</script><script>self.__next_f.push([1,"9:[\"$\",\"html\",null,{\"lang\":\"zh-CN\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"link\",null,{\"rel\":\"stylesheet\",\"href\":\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css\"}],[\"$\",\"link\",null,{\"rel\":\"stylesheet\",\"href\":\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css\"}],[\"$\",\"script\",null,{\"src\":\"https://cdn.jsdelivr.net/npm/mermaid@10.9.1/dist/mermaid.min.js\",\"async\":true}],[\"$\",\"script\",null,{\"src\":\"https://unpkg.com/markmap-autoloader@0.17.2\"}]]}],[\"$\",\"body\",null,{\"children\":[\"$\",\"div\",null,{\"className\":\"app\",\"children\":[[\"$\",\"$L10\",null,{\"siteConfig\":{\"name\":\"海元\",\"bio\":\"JAVA | AI | WEB3\",\"social\":[{\"name\":\"github\",\"icon\":\"fab fa-github\",\"url\":\"https://github.com/suogongy\"},{\"name\":\"twitter\",\"icon\":\"fab fa-twitter\",\"url\":\"https://twitter.com/suogongy\"},{\"name\":\"email\",\"icon\":\"fas fa-envelope\",\"url\":\"mailto:haiyuan1832@163.com\"}]}}],[\"$\",\"main\",null,{\"className\":\"main-content\",\"children\":[\"$\",\"$L5\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L8\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[]}]}]]}]}]]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"MySQL高可用高性能实战 - Personal GitHub Page\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"本文详细介绍MySQL高可用架构的设计原理、实现方案和性能优化实践，包括主从复制、集群部署、故障转移等核心技术。\"}]]\n3:null\n"])</script></body></html>